<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Blog &middot; Ember CLI Mirage
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/style.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <div class="Topbar">
      <div class="Container">
      </div>
    </div>

    <header class="Header">
  <div class="Container">
    <nav class='Header__nav'>
      <ul class='Header__nav-list'>
        <li class='Header__nav-item'>
          <a href='/docs/v0.3.x' class="Header__nav-item-link">
            <span class="u-mobile">Docs</span>
            <span class="u-desktop">Documentation</span>
          </a>
        </li>
        <li class='Header__nav-item'>
          <a href='/blog' class="Header__nav-item-link active">Blog</a>
        </li>
        <li class='Header__nav-item'>
          <a href='/about' class="Header__nav-item-link">About</a>
        </li>
        <li class='Header__nav-item'>
          <a href="http://localhost:4000" class='Header__nav-item-link' target="_blank">GitHub</a>
        </li>
      </ul>
    </nav>
    <a class="Header__logo" href="/">
      <span class='Header__logo-minor'>Ember CLI</span><br>
      <span class='Header__logo-major'>Mirage</span>
    </a>
  </div>
</header>


    <div class="Wrapper">
      <div class="Content">
        <div class="Blog">

  
    <div class='Blog__post'>
      <div class="Blog__post-info">
        <h1 class='Blog__title'><a href="/blog/2017/01/09/0-3-0-beta-series/">Mirage 0.3.0 beta series</a></h1>
        <p class='Blog__byline'>January 9, 2017</p>
        <hr class='Blog__divider'>
      </div>
      <div class='Blog__content'>
        <p>I’ve started the beta series of Mirage v0.3.0. You can install the latest release (0.3.0-beta.4 as of this writing) with</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code>ember install ember-cli-mirage@beta
</code></pre>
</div>

<p>Recent updates to the ORM required some breaking changes, which is why I’m bumping Mirage’s “major” version from 0.2 to 0.3. I’m hoping this is the last release series before landing a 1.0 final.</p>

<ul>
  <li><a href="#motivation">Motivation</a></li>
  <li><a href="#usage">Usage</a></li>
  <li><a href="#examples">Examples</a></li>
  <li><a href="#roadmap">Roadmap</a></li>
</ul>

<h2 id="motivation">Motivation</h2>

<p>The ORM that was added in 0.2 has proved useful, and recent factory enhancements (the <code class="highlighter-rouge">afterCreate</code> hook along with traits and associations) have really improved the ergonomics of creating complex object graphs.</p>

<p>The biggest challenge since the 0.2 release has been the ORM’s lack of support for several relationship types:</p>

<ul>
  <li>one-way</li>
  <li>one-to-one</li>
  <li>many-to-many</li>
  <li>reflexive</li>
  <li>polymorphic</li>
</ul>

<p>I went ahead with the 0.2.0 release anyway, because the serialization layer made working with JSON:API so much more pleasant. However, ever since the release users have been forced to write custom code in order to deal with these missing relationship types.</p>

<p>When I began work on these missing types several months ago, I expected it to be relatively simple. Mirage’s ORM was based off of ActiveRecord, and I felt I had a good understanding of the APIs that needed to be implemented. I started with one-to-one relationships, and nearly finished before I encountered a fundamental problem.</p>

<p>In Rails, relationships are mapped on top of databases. Databases have fixed, known schemas, and ActiveRecord’s APIs are designed to work with these known quantities. Questions like which records have foreign keys and whether two models are related via has-one or has-many are unambiguous, so ActiveRecord’s API doesn’t need to account for this.</p>

<p>Modern HTTP APIs, however, are quite different. For example, take the following totally valid JSON:API response:</p>

<div class="language-json highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nt">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"authors"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"attributes"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Martin Fowler"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nt">"relationships"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"books"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nt">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="p">{</span><span class="w">
            </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"books"</span><span class="w">
          </span><span class="p">}</span><span class="w">
        </span><span class="p">]</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nt">"included"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
    </span><span class="nt">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"books"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"attributes"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nt">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Refactoring: Improving the Design of Existing Code"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>We can see that an author <code class="highlighter-rouge">has many</code> books. But what about the relationship from books to authors? In the response it’s ambiguous. We might assume it’s many-to-one - but we could be wrong. Perhaps our app has the book <em>Refactoring</em>, which four authors. So the relationship between authors and book could turn out to be many-to-many.</p>

<p>This is just one example of the ambiguity inherent in many HTTP responses. Trying to make assumptions about the underlying schema can make Mirage’s abstractions even more complicated. In the 0.2 ORM, the <code class="highlighter-rouge">hasMany</code> and <code class="highlighter-rouge">belongsTo</code> helpers always assumed one side of the relationship was “belongs to”, and added a foreign key to it. In the above example, this would mean books would get an <code class="highlighter-rouge">authorId</code> key. But with the need for many to many relationships, this turns out to be wrong. What to do?</p>

<p>We could have kept the <code class="highlighter-rouge">authorId</code> as a default assumption, and then changed it when the user specified both sides. But what if the relationship turned out to be only one-way? You often come across this as well. Even if your backend has the relationship mapped out unambiguously, your API may choose to expose only one side. So, more assumptions like this give rise to even more indirection and unnecessary complexity.</p>

<p>Further, keeping a foreign key on the belongs-to side at the database level but adding an ids array to the has-many side at the ORM level is an abstraction, and something else developers need to learn. Understanding Mirage’s database structure is still useful for seeding test data and writing test assertions. And the abstractions needed to support all relationship types would be even more complex.</p>

<p>Putting the <code class="highlighter-rouge">authorId</code> foreign key on a book when the user only ever needed an author to have many books (and therefore a <code class="highlighter-rouge">bookIds: []</code> array) turned out to be too confusing, and too much magic. If the user specifies that an author has many books, I decided that an author should simply get a <code class="highlighter-rouge">bookIds: []</code> array to manage the foreign keys — and nothing more. This decision automatically allows for relationships to be one-way only, and it also expands to support the other relationship types. In the event that there <em>is</em> a bidirectional relationship, the keys would now need to be kept in sync on both sides - which is precisely what I’ve been working on, and is now handled in the 0.3 series. Further, giving models an <code class="highlighter-rouge">id</code> or <code class="highlighter-rouge">ids</code> property that corresponds directly to their relationships more closely matches Ember Data’s approach. Overall, it feels like the right decision.</p>

<h2 id="usage">Usage</h2>

<p>The <code class="highlighter-rouge">hasMany</code> and <code class="highlighter-rouge">belongsTo</code> helpers are still present in 0.3, but they work a bit differently.</p>

<p>Say we have the following models:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="c1">// mirage/models/author.js</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Model</span><span class="p">,</span> <span class="nx">hasMany</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'ember-cli-mirage'</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

  <span class="na">books</span><span class="p">:</span> <span class="nx">hasMany</span><span class="p">()</span>

<span class="p">});</span>
</code></pre>
</div>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="c1">// mirage/models/book.js</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Model</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'ember-cli-mirage'</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

<span class="p">});</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">hasMany</code> helper adds a <code class="highlighter-rouge">bookIds</code> array to each author model that it uses for bookkeeping. If we have an author instance</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">author</span> <span class="o">=</span> <span class="nx">schema</span><span class="p">.</span><span class="nx">authors</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p>then the helper method <code class="highlighter-rouge">author.books</code> will use the <code class="highlighter-rouge">author.bookIds</code> property to find the related books.</p>

<p>Creating related books updates the <code class="highlighter-rouge">ids</code> property</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">steinbeck</span> <span class="o">=</span> <span class="nx">schema</span><span class="p">.</span><span class="nx">authors</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'John Steinbeck'</span> <span class="p">});</span>

<span class="nx">steinbeck</span><span class="p">.</span><span class="nx">createBook</span><span class="p">({</span> <span class="na">title</span><span class="p">:</span> <span class="s1">'Of Mice and Men'</span> <span class="p">});</span>
<span class="nx">steinbeck</span><span class="p">.</span><span class="nx">createBook</span><span class="p">({</span> <span class="na">title</span><span class="p">:</span> <span class="s1">'The Grapes of Wrath'</span> <span class="p">});</span>

<span class="nx">steinbeck</span><span class="p">.</span><span class="nx">bookIds</span><span class="p">;</span> <span class="c1">// [ 1, 2 ]</span>
</code></pre>
</div>

<p>as does associating new books</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">hemingway</span> <span class="o">=</span> <span class="nx">schema</span><span class="p">.</span><span class="nx">authors</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'Ernest Hemingway'</span> <span class="p">});</span>
<span class="kd">let</span> <span class="nx">oldMan</span> <span class="o">=</span> <span class="nx">schema</span><span class="p">.</span><span class="nx">books</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="na">title</span><span class="p">:</span> <span class="s1">'The Old Man and the Sea'</span> <span class="p">});</span>

<span class="nx">hemingway</span><span class="p">.</span><span class="nx">books</span> <span class="o">=</span> <span class="p">[</span> <span class="nx">oldMan</span> <span class="p">];</span>
<span class="nx">hemingway</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>

<span class="nx">hemingway</span><span class="p">.</span><span class="nx">bookIds</span><span class="p">;</span> <span class="c1">// [ 3 ]</span>
</code></pre>
</div>

<p>Notice that so far, <em>books themselves don’t have any knowledge of this relationship</em>. This is the biggest change in the ORM. Before, the book would automatically get an <code class="highlighter-rouge">authorId</code>, and so this would be available in tests, and it would also be sent over in responses as a relationship on the book. But in the case of 0.3, the relationship helpers are one-way. Basically, it works more like Ember Data does.</p>

<p>This means if you want a book to have an <code class="highlighter-rouge">authorId</code>, you’ll need to also define the relationship on the book:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="c1">// mirage/models/book.js</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Model</span><span class="p">,</span> <span class="nx">belongsTo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'ember-cli-mirage'</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

  <span class="na">author</span><span class="p">:</span> <span class="nx">belongsTo</span><span class="p">()</span>

<span class="p">});</span>
</code></pre>
</div>

<p>This helper will add an <code class="highlighter-rouge">authorId</code> to the book, and, like Ember Data, look for an implicit inverse on the <code class="highlighter-rouge">author</code>. If it can find one, the ORM will keep the ids on both sides of the relationship in sync.</p>

<h2 id="examples">Examples</h2>

<p>Here are some Twiddles showcasing various relationship configurations:</p>

<ul>
  <li><strong><a href="https://ember-twiddle.com/802cd2f92e8c6c7280f42b054f393097?openFiles=mirage.config.js%2C">One-Way Has Many</a></strong>. Notice how the author’s keys are updated when you delete a book.</li>
  <li><strong><a href="https://ember-twiddle.com/24d6101792f2932e9c7edf5f0934b02c?openFiles=models.book.js%2C">One-Way Belongs To</a></strong>. Deleting the author will ensure existing book’s keys are nulled out (i.e. they become orphans so that the database is kept consistent).</li>
  <li><strong><a href="https://ember-twiddle.com/5031fb20898b277fa6aea8fe89571148?openFiles=templates.application.hbs%2C">One to Many</a></strong>. The keys on both sides of the relationship are kept in sync. If you delete the author, the books become orphaned records with null keys.</li>
  <li><strong><a href="https://ember-twiddle.com/012bd753cb03c7ae375210d47b623ccb?openFiles=mirage.config.js%2C">One to One</a></strong>. Another bidirectional relationship with keys managed on both sides.</li>
  <li><strong><a href="https://ember-twiddle.com/104407460799f1c16c4c0dc88daf975a?openFiles=templates.application.hbs%2C">Many to Many</a></strong>. And another.</li>
</ul>

<h2 id="roadmap">Roadmap</h2>

<p>Here are my plans for Mirage’s next steps. First, after enough folks try out the beta series we can land 0.3. Then I’ll be able to add polymorphic relationships, which will round out the ORM.</p>

<p>At this point I’d like to move towards a 1.0 release, barring any glaring issues in the API. Mirage has been around for nearly two years and plenty of people are using it. It’s past time we hit an official major version and lock down the API.</p>

<p>After 1.0, I’d like to move forward on an Ember Data integration layer, which is now possible since Mirage’s ORM is able to represent Ember Data’s possible schemas. The layer would simply read in your application’s Ember Data schema and reproduce it in-memory for Mirage’s ORM to use. This would yield big ergonomic gains for users of the library, as you’d no longer need to duplicate your Ember Data models for Mirage, and also lower the learning curve for new users.</p>

<p>There are several more features I want to move forward on now that the core API is stabilizing. Getting Mirage to be able to run in Node in an Express server would be great, since responses would be real HTTP responses, developers could use the network tab and more.</p>

<p>My primary goal in 2017 is delegation. For too long my personal availability has been a bottleneck for Mirage’s development. I am going to focus on finding contributors and planning instead of actual implementation. It should help move the library forward faster while getting more folks knowledgeable about the internals, while also freeing up my time to focus more on <a href="https://embermap.com/">my business</a>.</p>

<p>If you’d like to help, join #ec-mirage on Ember’s slack community and reach out! Also be sure to drop a message there or open an issue if you have any feedback on 0.3.</p>

<p>I’m so happy to be part of such an awesome community and look forward to seeing you at SoEmber and EmberConf. Here’s to an exciting 2017!</p>

      </div>
    </div>
  
    <div class='Blog__post'>
      <div class="Blog__post-info">
        <h1 class='Blog__title'><a href="/blog/2016/05/31/0-2-0-released/">Mirage 0.2.0 released</a></h1>
        <p class='Blog__byline'>May 31, 2016</p>
        <hr class='Blog__divider'>
      </div>
      <div class='Blog__content'>
        <p>Mirage v0.2.0 has been released! Check out <a href="https://github.com/samselikoff/ember-cli-mirage/releases/tag/v0.2.0-beta.9">the release notes</a> for the breaking changes and enhancements from 0.2.0-beta.9. Also see <a href="https://blog.abuiles.com/blog/2016/05/27/upgrading-to-mirage-v0-dot-2-0-beta-dot-9-with-jscodeshift/">Adolfo’s script</a> to help with some of the breaking changes from <code class="highlighter-rouge">beta.7</code> to <code class="highlighter-rouge">beta.9</code>.</p>

<p>If you’re upgrading an app from 0.1.x to 0.2, be sure to read through <a href="http://www.ember-cli-mirage.com/docs/v0.2.x/">the 0.2.x docs</a>. When you’re ready to upgrade, consult <a href="http://www.ember-cli-mirage.com/docs/v0.2.x/upgrading/">the upgrade guide</a>, and open an issue if the guide left something out.</p>

<hr />

<p>Even though there’s more work I want to do to smooth out the API in a few places, it’s time to get 0.2 released. Most (if not all) of the planned changes should be backwards compatible with 0.2, so users should start using 0.2 today.</p>

<p>Next, I’m hoping to address two of the biggest pain points I saw during the beta series:</p>

<ol>
  <li>
    <p><strong>Creating object graphs in tests.</strong> Currently, seeding Mirage with a graph of related data looks something like this:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code> let author = server.create('author');
 let post1 = server.create('post', { author });
 server.createList('comment', 10, { post: post1 });

 let post2 = server.create('post', { author });
 server.createList('comment', 5, { post: post2 });
</code></pre>
    </div>

    <p>Two features planned for the factory layer will help with this: an <code class="highlighter-rouge">afterCreate</code> hook, and <code class="highlighter-rouge">traits</code>.</p>
  </li>
  <li>
    <p><strong>Responding with has-one or many-to-many relationships in the Serializer.</strong> Originally I was going to add a <code class="highlighter-rouge">hasAndBelongsToMany</code> helper to solve this, but now I think <a href="https://github.com/samselikoff/ember-cli-mirage/issues/754">ad hoc Serializer methods</a> is a better short-term solution, and something I wanted to add anyway. Some folks are keen on getting this working, so hopefully it will land soon.</p>
  </li>
</ol>

<hr />

<p>Thanks to everyone who braved the beta series, you were crucial to all the iterations on the API, and to all the amazing contributors who helped push it through!</p>

<p>Happy coding everyone!</p>

      </div>
    </div>
  
    <div class='Blog__post'>
      <div class="Blog__post-info">
        <h1 class='Blog__title'><a href="/blog/2016/01/03/0-2-0-beta.9-released/">Mirage 0.2.0-beta.9 released</a></h1>
        <p class='Blog__byline'>May 13, 2016</p>
        <hr class='Blog__divider'>
      </div>
      <div class='Blog__content'>
        <p>Mirage v0.2.0-beta.9 has been released. Check out <a href="https://github.com/samselikoff/ember-cli-mirage/releases/tag/v0.2.0-beta.9">the release notes</a> for the breaking changes and enhancements.</p>

<h2 id="update-on-a-02-stable-release">Update on a 0.2 stable release</h2>

<p>I wanted to jot down some of my recent thoughts while putting this release together. Pardon the rambling.</p>

<p>Originally I had planned for beta.9 to be the last beta release before cutting 0.2. Since folks have started using the 0.2 beta series, however, pain points around data modeling have been cropping up. In particular, dealing with <code class="highlighter-rouge">has-one</code> and <code class="highlighter-rouge">many-to-many</code> associations is quite difficult with the current set of abstractions.</p>

<p>My first thought was to ship 0.2 as is, and then work on adding helpers for <code class="highlighter-rouge">hasAndBelongsToMany</code> and <code class="highlighter-rouge">hasOne</code>. After some more thought &amp; discussions with various users, I realized that the ORM’s abstractions might be a touch off. Let me explain.</p>

<p>Mirage’s ORM was built to support features like JSON:API includes and the planned factory relationships. The ORM is a way to encode association information, since there was no good place to do this in <code class="highlighter-rouge">v0.1</code>. My approach was to largely mimic server-side frameworks like Rails, since they’ve already solved this problem. After all, your models already live on the backend in database tables, so why not use the same concepts? Tables with foreign keys are familiar to backend devs, so let’s just emulate those concepts in Mirage.</p>

<p>So, that’s been the plan so far. The ORM has working <code class="highlighter-rouge">hasMany</code> and <code class="highlighter-rouge">belongsTo</code> associations, and those take care of many cases. The <code class="highlighter-rouge">manyToMany</code> case is interesting, though, because there’s not necessarily a standard conventional way that all Ember developers or servers approach this problem.</p>

<p>Take a simple <code class="highlighter-rouge">belongsTo</code>, like a <code class="highlighter-rouge">post</code> that belongs to an <code class="highlighter-rouge">author</code>. The <code class="highlighter-rouge">post</code> probably owns the foreign key, something like <code class="highlighter-rouge">author_id</code>. Persisting this relationship, then, is as simple as saving any other attribute on the <code class="highlighter-rouge">post</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PUT /api/posts/1

{
  post: {
    id: 1,
    title: 'Hipster ipsum',
    author_id: 24
  }
}
</code></pre>
</div>

<p><code class="highlighter-rouge">author_id</code> is all that’s needed to tell both Ember Data and the server about the new relationship.</p>

<p><code class="highlighter-rouge">hasMany</code> is where things start to get tricky. Let’s assume we’ve also defined the inverse of the above relationship, so an <code class="highlighter-rouge">author</code> has many <code class="highlighter-rouge">posts</code>. If you updated an author with new posts, how would you persist those new relationships?</p>

<p>As above, the foreign key on each <code class="highlighter-rouge">post</code> is all that’s needed to tell both the frontend and the backend about the new relationship, so typically I would handle it like this:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">post1</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'author'</span><span class="p">,</span> <span class="nx">author</span><span class="p">);</span>
<span class="nx">post1</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>

<span class="nx">post2</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'author'</span><span class="p">,</span> <span class="nx">author</span><span class="p">);</span>
<span class="nx">post2</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>
</code></pre>
</div>

<p>and so on. You can write code that batches these requests, but the point here is that this is pretty straightforward stuff. Persisting a relationship is just boring old CRUD on a resource.</p>

<p>Interestingly, the <a href="https://guides.emberjs.com/v2.5.0/models/relationships/#toc_creating-records">Ember Data guides</a> show code that suggests persisting a <code class="highlighter-rouge">hasMany</code> relationship by calling <code class="highlighter-rouge">save</code> on the parent, which looks something like this:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">author</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'posts'</span><span class="p">).</span><span class="nx">pushObjects</span><span class="p">([</span><span class="nx">post1</span><span class="p">,</span> <span class="nx">post3</span><span class="p">]);</span>
<span class="nx">author</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>
</code></pre>
</div>

<p>Now, Ember Data can understand this, and in fact this is how some teams work. But what does the request/response look like? Maybe something like</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PUT /authors/1
{
  author: {
    id: 1,
    name: 'Frank',
    post_ids: [1, 3]
  }
}
</code></pre>
</div>

<p>This is a request to update a single <code class="highlighter-rouge">author</code> resource - but behind the scenes, is your backend actually updating the foreign keys on two different post records? If so, we’ve kind of moved out of the realm of doing boring CRUD on resources, because now our server is doing something different or more than what we asked of it: we asked it to update the <code class="highlighter-rouge">author:1</code> resource, and in reality it’s updating two other <code class="highlighter-rouge">post</code> resources. Interestingly I’ve asked several folks in the community how they deal with this issue, and the response varies.</p>

<p>The story gets even trickier with many-to-many relationships. Sometimes people model the join record in their Ember apps, sometimes they don’t. If they don’t, a PUT to an <code class="highlighter-rouge">author</code> resource could actually be <em>creating</em> multiple server resources behind the scenes, via a join table.</p>

<p>This obviously has implications for Mirage, which works best with conventional server endpoints. A PUT to a resource updates that resource, and so on. But plenty of people write their servers this way, and it got me thinking: perhaps database tables and foreign keys are the wrong abstraction for Mirage to emulate. Perhaps transport of HTTP resources is a bit more generic and abstract than that.</p>

<p>Take, for example, the following Ember Data model definitions:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="c1">// models/post.js</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

  <span class="na">categories</span><span class="p">:</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">hasMany</span><span class="p">();</span>

<span class="p">});</span>

<span class="c1">// models/category.js</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>

  <span class="na">name</span><span class="p">:</span> <span class="nx">DS</span><span class="p">.</span><span class="nx">attr</span><span class="p">()</span>

<span class="p">});</span>
</code></pre>
</div>

<p>That is a perfectly valid and legitimate domain model. By looking at those two models, can you tell me which entity owns the foreign key? Nope. In fact, you don’t even know if this is a one-to-many or many-to-many relationship. And yet, from the perspective of HTTP resources (including a valid implementation of a JSON:API server), this is totally valid.</p>

<p>Here’s the JSON:API response, for example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>GET /posts/1?include=categories

{
  data: {
    type: 'posts',
    id: 1,
    relationships: {
      categories: [
        {
          data: {
            type: 'categories',
            id: '2'
          }
        },
        {
          data: {
            type: 'categories',
            id: '5'
          }
        }
      ]
    }
  },
  included: [
    {
      type: 'categories',
      id: '2',
      attributes: {
        name: 'Economics'
      }
    },
    {
      type: 'categories',
      id: '5',
      attributes: {
        name: 'Programming'
      }
    }
  ]
}
</code></pre>
</div>

<p>Totally valid, and also impossible to ascertain whether this is a one-to-many or many-to-many relationship.</p>

<p>Basing Mirage’s ORM on database tables and foreign keys makes some things really easy and familiar, but for these situations it’s a pain. If your actual Ember app and your actual server can handle a request like</p>

<div class="highlighter-rouge"><pre class="highlight"><code>PUT /posts/1
{
  post: {
    id: 1,
    tag_ids: [1, 4]
  }
}
</code></pre>
</div>

<p>just fine, you shouldn’t have to add extra logic or models to make your fake Mirage server work.</p>

<p>The solution I have in mind for this problem is to replace the foreign key implementation with an associations map. This map will be a singleton that all models will have a reference to, and it will be used to persist model relationships.</p>

<p>The external API of Mirage’s ORM won’t change. For example, say you had a <code class="highlighter-rouge">author</code> that has many <code class="highlighter-rouge">posts</code>:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="c1">// mirage/models/author.js</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="na">posts</span><span class="p">:</span> <span class="nx">hasMany</span><span class="p">()</span>
<span class="p">});</span>

<span class="c1">// mirage/models/post.js</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
<span class="p">});</span>
</code></pre>
</div>

<p>Currently (in 0.2.0-beta.9), Mirage makes an assumption here that the <code class="highlighter-rouge">post</code> resource has an <code class="highlighter-rouge">author_id</code> foreign key. As we’ve just shown, this is potentially a false assumption. My previous plan was to write a <code class="highlighter-rouge">hasAndBelongsToMany</code> helper for many-to-many relationships. Then, if this relationship turned out to be a many-to-many, the user would need to do something like the following:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="c1">// mirage/models/author.js</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="na">posts</span><span class="p">:</span> <span class="nx">hasAndBelongsToMany</span><span class="p">()</span>
<span class="p">});</span>
</code></pre>
</div>

<p>This would tell Mirage to transparently create a <code class="highlighter-rouge">author-post</code> join table, and deal with the persistence there.</p>

<p>Again, this now feels like the wrong abstraction, and it also introduces concepts that aren’t necessarily appropriate for the domain of the frontend. Instead, the original domain model with the <code class="highlighter-rouge">hasMany</code> declaration will add an <code class="highlighter-rouge">author.posts</code> key to the singleton associations map, where all the relationship data can be stored. This has an added benefit of simplifying Mirage’s interface for creating relationships in factories and elsewhere, as now developers will be able to do things like</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">author</span> <span class="o">=</span> <span class="nx">server</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="s1">'author'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">categoryIds</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">});</span>
</code></pre>
</div>

<p>in their tests, similar to what they’re used to doing in Ember Data. We can also make Mirage’s shorthands understand both forms of saving <code class="highlighter-rouge">hasMany</code> relationships, since the ids on the models will just be pointers to the associations map. Serializers can be used to customize which ids are sent along with the response.</p>

<p>This change will also make it easier to ascertain all model information from an existing set of Ember Data models in the future. I’m confident the overall learning curve will be easier and resulting code will be cleaner.</p>

<p>While this will take a bit more time to get right, I think it’s important. I also feel like I have a better grasp of something important, namely that Mirage as an HTTP faking layer should not necessarily emulate various server abstractions, but rather focus on concepts that come from HTTP. It turns out that single-owner foreign keys is not one of those concepts, and therefore this abstraction does not belong in Mirage.</p>

<p>I’ll probably release 0.2, and work the associations map into a 0.3 release. Still thinking this through, though.</p>

<p>My closing thought is that these HTTP concepts are crucial to understand if you’re going to write an Ember app, and they can’t just be left to the backend team. It’s true that a frontend developer doesn’t need to know that Rails has a <code class="highlighter-rouge">has_and_belongs_to_many</code> method that abstracts away join tables on many-to-many relationships; however, the developer does need to understand how her Ember app will retrieve and persist many-to-many relationships across the network. Domain modeling and HTTP transport is a central part of Ember development and unfortunately at the moment, many parts of it are still non-standard and unconventional.</p>

      </div>
    </div>
  
    <div class='Blog__post'>
      <div class="Blog__post-info">
        <h1 class='Blog__title'><a href="/blog/2016/01/03/0-2-update-only-inject-schema/">Mirage 0.2 update</a></h1>
        <p class='Blog__byline'>January 3, 2016</p>
        <hr class='Blog__divider'>
      </div>
      <div class='Blog__content'>
        <p>Here’s a quick update on Mirage 0.2.</p>

<p>When I started working on the ORM/Serializer layer, I knew we were going to need to bump Mirage to 0.2. However, I thought it was worth keeping the library completely backwards compatible. I wanted users to be able to update to 0.2 without breaking any of their existing route handlers.</p>

<p>The more I learned while developing, the more I realized some of the assumptions I made in 0.1 were simply bad. For example, using the formatting of fixture files (including their names) to determine the format of JSON responses from mocked routes.</p>

<p>Now that we have a proper ORM and serializer layer, I’d like the story for how to set up your mock server to be clear, especially to newcomers.</p>

<p>In 0.1, route handlers receive the <code class="highlighter-rouge">db</code> as the first argument:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/users'</span><span class="p">,</span> <span class="p">(</span><span class="nx">db</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nx">users</span><span class="p">;</span>
<span class="p">});</span>
</code></pre>
</div>

<p>This made sense in a world where there was only a <code class="highlighter-rouge">db</code>, acting as a dumb data store, and all formatting decisions were left up to the user.</p>

<p>Then, we added the ORM and Serializer. Originally, the idea was, if you defined your models - that is, if you opted in to Mirage’s ORM - we’d inject a <code class="highlighter-rouge">schema</code> object instead of the comparatively dumb <code class="highlighter-rouge">db</code>:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/users'</span><span class="p">,</span> <span class="p">(</span><span class="nx">schema</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">schema</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">all</span><span class="p">();</span>
<span class="p">});</span>
</code></pre>
</div>

<p>This returned a User Collection, which the Serializer layer knew how to serialize.</p>

<p>This has been working well - but obviously, this is a breaking change for old route handlers. I also wanted people to be able to opt-in to the ORM layer, but still be able to dive into the raw <code class="highlighter-rouge">db</code> if they ever wanted to. <code class="highlighter-rouge">db</code> is an object that hangs directly off of <code class="highlighter-rouge">schema</code>, so you can always access it, even if you’ve opted in to the ORM:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/users'</span><span class="p">,</span> <span class="p">(</span><span class="nx">schema</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">schema</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">users</span><span class="p">;</span>
<span class="p">});</span>
</code></pre>
</div>

<p>This would bypass the model-specific serializers.</p>

<p>ES6 destructring makes this even better:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'/users'</span><span class="p">,</span> <span class="p">({</span><span class="nx">db</span><span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nx">users</span><span class="p">;</span>
<span class="p">});</span>
</code></pre>
</div>

<p>Given this, I feel it’s worth making the breaking change, and <em>only</em> injecting <code class="highlighter-rouge">schema</code> to route handlers. The upgrade path for existing route handlers should be a simple change:</p>

<div class="language-diff highlighter-rouge"><pre class="highlight"><code><span class="gd">- this.get('/users', (db) =&gt; {
</span><span class="gi">+ this.get('/users', ({db}) =&gt; {
</span>    return db.users;
  });
</code></pre>
</div>

<p>along with possibly specifying a default Application serializer.</p>

<p>The main reason I want to make this change, is to simplify the story around how Mirage data gets set up. In 0.1, Mirage looked for defined fixtures and/or factories to set up its database. In traditional server frameworks (e.g. Rails), you have a <code class="highlighter-rouge">schema</code> file that specifies the schema of your db. Using a mixture of fixtures and factories is confusing and unnecessary. Further, factories should be seen as an extension of the models (db collections) they’re creating, rather than their definitions.</p>

<p>This is why going forward, the story for configuring Mirage will be a unified one: Models define your schema/database. So, new users will define models for each table/collection they want in their Mirage mock server. That sets up the database tables, and also gives the user a very easy starting point when they <em>do</em> want to opt into the relationship/serializer support. <code class="highlighter-rouge">server.create</code> will still use a factory if it exists, but if no factory exists, it will simply create an empty model.</p>

<p>I’m confident this change will make Mirage simpler and more approachable. The downside is, existing users will need to define blank models for each collection they have. We’ll have a generator, which will help some, but this could prove to be annoying. My hope is that having a single <code class="highlighter-rouge">/models</code> directory, while being able to delete empty factory and fixture files, will simplify things. Also, this paves the way for a planned future addon, <code class="highlighter-rouge">mirage-ember-data</code>. The purpose of this addon is to ascertain, at run-time, the server models and their relationships, based on a user’s Ember Data models. This would eliminate the need to define models again, in Mirage-land.</p>

<p>This addon is still a ways off, but this change - enforcing users to simply define their models as the single source of truth for their backend schema - paves the way.</p>

<hr />

<p>You can see all the open items left before we release 0.2.0 <a href="https://github.com/samselikoff/ember-cli-mirage/issues?q=is%3Aopen+is%3Aissue+milestone%3A0.2.0">here</a>. Bugs, Help Wanted and Good for New Contributors are great tags to look out for if you’d like to help push us towards release!</p>

<p>If you have any thoughts or comments, tweet @samselikoff or <a href="https://github.com/samselikoff/ember-cli-mirage/issues">open an issue</a>.</p>

      </div>
    </div>
  
    <div class='Blog__post'>
      <div class="Blog__post-info">
        <h1 class='Blog__title'><a href="/blog/2015/11/03/inside-ember-cli-mirage/">Video: Inside Ember CLI Mirage</a></h1>
        <p class='Blog__byline'>November 3, 2015</p>
        <hr class='Blog__divider'>
      </div>
      <div class='Blog__content'>
        <p>On October 10 I spoke at the Global Ember Meetup about why I built Mirage, and what’s planned for the next version. Here’s the video:</p>

<div class="fixed-ratio fixed-ratio-video">
    <iframe src="https://player.vimeo.com/video/144256352" class="fixed-ratio-inner" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
</div>

      </div>
    </div>
  
    <div class='Blog__post'>
      <div class="Blog__post-info">
        <h1 class='Blog__title'><a href="/blog/2015/10/19/serializers-ready/">Serializers are ready for testing</a></h1>
        <p class='Blog__byline'>October 19, 2015</p>
        <hr class='Blog__divider'>
      </div>
      <div class='Blog__content'>
        <p>Yesterday I merged in the <a href="https://github.com/samselikoff/ember-cli-mirage/commit/9927a7f7a2232ddf8df15e01991e538eefadee9c">JSON:API Serializer</a>, which is the last piece of planned work I have for the serializer layer. That means it’s ready to test! I’m sure there’s plenty I haven’t thought of yet, but I think it’s time to get some people kicking the tires.</p>

<p>For the brave, I’ll be writing documentation this week about how to take advantage of the ORM and Serializer layer in your route handlers. Migration will be at your own pace: you should be able to switch over, keep old custom route handlers that access the db directly, and switch them over one at a time to use the new <code>schema</code> object - the ORM. Using a schema in your route handler lets you respond with a model or collection, which is the basis for your serializers knowing how to transform your response into an appropriately-formatted JSON payload.</p>

<p>The docs should be landing soon. But, the code is already in master (since the entire ORM is opt-in) - so, for the <em>truly</em> brave, you can try this out right now, by doing something like the following:</p>

<ol>
  <li>Upgrade to master (“samselikoff/ember-cli-mirage” in your package.json)</li>
  <li>
    <p>Define your models. For each model create a file under <code class="highlighter-rouge">mirage/models</code> that looks like the following:</p>

    <div class="language-js highlighter-rouge"><pre class="highlight"><code> <span class="c1">// mirage/models/post.js</span>
 <span class="kr">import</span> <span class="p">{</span> <span class="nx">Model</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'ember-cli-mirage'</span><span class="p">;</span>

 <span class="kr">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">;</span>
</code></pre>
    </div>

    <p>Use the singular version of your model for the filename.</p>
  </li>
  <li>
    <p>Define your serializer. There are two named serializers, JSON:API and ActiveModelSerializer. You can customize these as well the basic Serializer that’s also included.</p>

    <div class="language-js highlighter-rouge"><pre class="highlight"><code> <span class="c1">// mirage/serializers/application.js</span>
 <span class="kr">import</span> <span class="nx">Serializer</span> <span class="nx">from</span> <span class="s1">'ember-cli-mirage/serializers/json-api-serializer'</span><span class="p">;</span>

 <span class="kr">export</span> <span class="k">default</span> <span class="nx">Serializer</span><span class="p">;</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>Once you do the above, Mirage will now be using an ORM. This means your custom route handlers will no longer have the signature</p>

    <div class="language-js highlighter-rouge"><pre class="highlight"><code> <span class="kd">function</span><span class="p">(</span><span class="nx">db</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
</code></pre>
    </div>

    <p>but rather</p>

    <div class="language-js highlighter-rouge"><pre class="highlight"><code> <span class="kd">function</span><span class="p">(</span><span class="nx">schema</span><span class="p">,</span> <span class="nx">request</span><span class="p">)</span>
</code></pre>
    </div>

    <p>where <code>schema</code> is the ORM object. Fortunately, the <code>db</code> is available at <code>schema.db</code>. This means you can give your old route handlers access to the <code>db</code> by doing the following refactoring:</p>

    <div class="language-diff highlighter-rouge"><pre class="highlight"><code> - this.get('/some/path', function(db, request), {
 + this.get('/some/path', function({db}, request), {
    // your custom route handler
 });
</code></pre>
    </div>

    <p>Not bad, thanks to the magic of ES6 object destructuring!</p>

    <p>Additionally, the ORM standardizes the formatting of database attributes and collections. Previously, for example, the name of the database collection was based on the filename of your fixture or factory - so, you could have a collection called <code>db.blog_posts</code>. With the ORM, everything is camel-cased (we are writing JS, after all). So, this may necessitate some refactoring of your custom route handler code.</p>
  </li>
</ol>

<p>Adding relationship support looks like this:</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="c1">// mirage/models/author.js</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Model</span><span class="p">,</span> <span class="nx">hasMany</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'ember-cli-mirage'</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="na">posts</span><span class="p">:</span> <span class="nx">hasMany</span><span class="p">()</span>
<span class="p">});</span>

<span class="c1">// mirage/models/post.js</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Model</span><span class="p">,</span> <span class="nx">belongsTo</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'ember-cli-mirage'</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="na">author</span><span class="p">:</span> <span class="nx">belongsTo</span><span class="p">()</span>
<span class="p">});</span>

<span class="c1">// mirage/serializers/author.js</span>
<span class="kr">import</span> <span class="nx">ApplicationSerializer</span> <span class="nx">from</span> <span class="s1">'./application'</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">ApplicationSerializer</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="na">relationships</span><span class="p">:</span> <span class="p">[</span><span class="s1">'posts'</span><span class="p">]</span>
<span class="p">});</span>
</code></pre>
</div>

<p>and now, the GET shorthands to <code>/authors</code> should return included posts!</p>

<hr />

<p>That’s just a taste of what’s to come! I want to reiterate this is very new and I basically don’t suggest using it. But, if you’re feeling adventurous, dive in! I would love to hear any feedback. If you do try it out, hit me up on Slack if you have questions.</p>

      </div>
    </div>
  
    <div class='Blog__post'>
      <div class="Blog__post-info">
        <h1 class='Blog__title'><a href="/blog/2015/09/15/router-handler/">Refactoring Server, adding a Route Handler object</a></h1>
        <p class='Blog__byline'>September 15, 2015</p>
        <hr class='Blog__divider'>
      </div>
      <div class='Blog__content'>
        <p>Updating the shorthands to work with the serializer layer proved harder than I thought. Serializers made it clear that the shorthands were making assumptions about the shape of the JSON payload. Now that users will be able to use serializers to transform how their data looks going out, I’ll also need a way for them to specify how the data looks coming in. This is similar to Ember Data’s <code class="highlighter-rouge">normalize</code> function.</p>

<p>If a user is using a PUT or POST shorthand, I’ll need to first deserialize the payload into a standard format, so the shorthands know what to do with it. I’ll use the JSON:API format for the standard; that way, if you’re using JSON:API, <code class="highlighter-rouge">normalize</code> will be a no-op, and AMS-style responses will simply convert to JSON:API.</p>

<p>This sounds a lot like Ember Data, and I’ve even considered using Ember Data for the data store/identity map portion of Mirage; but at this point, there are still too many unknowns. I’d rather get the rest of the main features incorporated + wait for the API to stabilize, before making such a big decision.</p>

<p>Mirage’s ORM has very different needs than Ember Data’s: it’s a synchronous in-memory store, and while ED also has a clientside store, it was designed around an async layer, incorporates Ember.Object for KVO, requires attr declarations, and much more. Mirage’s orm uses <code class="highlighter-rouge">object.defineProperty</code> to keep things as lightweight as possible, so you’ll be able to <code class="highlighter-rouge">user.createPost</code>, <code class="highlighter-rouge">user.posts = [1]</code>, <code class="highlighter-rouge">post.user = user</code> etc. in your routes. Adding the ceremony of  <code class="highlighter-rouge">.get(), </code>.set()<code class="highlighter-rouge">, and </code>createRecord` everywhere would make Mirage feel like more of a burden, and I think it’s important to try to keep things as slim and easy-to-use as possible, given that Mirage is designed for mocking.</p>

<p>In any case, the shorthands were originally simple functions that were unit tested. Now that there’s a bit more going on, I felt the need to refactor the server/controller code a bit. I also got around to slimming down the initializer, moving that code to the Server, and moving a lot of route-handling-related code from Server to a new RouteHandler class. My next step will be to turn the shorthand functions into RouteHandlers (probably subclasses), which will hopefully provide some direction on how the data will flow from request, through normalize, to the shorthands and out to a response.</p>

      </div>
    </div>
  
    <div class='Blog__post'>
      <div class="Blog__post-info">
        <h1 class='Blog__title'><a href="/blog/2015/09/10/orm-not-ready-yet/">The ORM is not ready, yet</a></h1>
        <p class='Blog__byline'>September 10, 2015</p>
        <hr class='Blog__divider'>
      </div>
      <div class='Blog__content'>
        <p>I wanted to quickly note that, although <a href="https://github.com/samselikoff/ember-cli-mirage/pull/82">the models PR</a> has been merged into master, it is not quite ready for use. To be really effective, Mirage also needs a serializer layer (in progress), and an update to the factory layer (to support associations and traits).</p>

<p>My plan is to document all three of these features (models, serializers and updated factories) at once, since they all rely on the orm, and will all require you to write simple model definitions to take advantage of.</p>

<p>Once you add a model definition, say by defining an <code class="highlighter-rouge">author</code> model</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="c1">// mirage/models/author.js</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">Mirage</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
  <span class="na">posts</span><span class="p">:</span> <span class="nx">Mirage</span><span class="p">.</span><span class="nx">hasMany</span><span class="p">()</span>
<span class="p">});</span>
</code></pre>
</div>

<p>then you opt into the orm. Now, routes will get a <code class="highlighter-rouge">schema</code> object injected instead of a <code class="highlighter-rouge">db</code> (the <code class="highlighter-rouge">db</code> will be accessible via <code class="highlighter-rouge">schema.db</code>), and shorthands and factories will leverage the <code class="highlighter-rouge">schema</code>, and you’ll be able to use serializers as well.</p>

<p>I’ve hit some snags writing serializers, and there’s a lot of hidden complexity in this effort, but I’m hoping I can wrap this all up in the next few weeks.</p>

      </div>
    </div>
  
    <div class='Blog__post'>
      <div class="Blog__post-info">
        <h1 class='Blog__title'><a href="/blog/2015/09/06/thoughts-on-model-attribute-formatting/">Thoughts on model attribute formatting</a></h1>
        <p class='Blog__byline'>September 6, 2015</p>
        <hr class='Blog__divider'>
      </div>
      <div class='Blog__content'>
        <p>I ran into an interesting problem while working on the serializer layer. I was just wrapping up AMS-style responses and was going to start working on the JSON:API version, when a wrinkle came up: the formatting of attribute names, both on Mirage’s model layer instances, and on the field names of Mirage’s database.</p>

<p>Currently, Mirage’s database simply takes whatever POJO of attrs you give it, and sticks that in its db. So if you write</p>

<div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">users</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="na">first_name</span><span class="p">:</span> <span class="s1">'Link'</span> <span class="p">})</span>
</code></pre>
</div>

<p>then you’ll end up with that POJO in the db, but if you use <code class="highlighter-rouge">first-name</code>, you’ll get that instead. This was originally done to make things as simple as possible - your db fields matched your API responses, so fixtures would “just work”, and accessing the data is as you’d expect based on your API.</p>

<p>When I introduced the model layer, I added attr accessors that simply matched the keys in the db. But right now, it’s a naive implementation that just wraps the db attrs. So, if you’re working with a <code class="highlighter-rouge">user</code> model (e.g. in your route handler), you would either access <code class="highlighter-rouge">user.first_name</code> or <code class="highlighter-rouge">user['first-name']</code>, depending on how your database looked.</p>

<p>It seems like attrs on models should be consistently camelCase. One would expect to write <code class="highlighter-rouge">user.firstName</code> on a JavaScript model. That’s the convention. I <em>could</em> keep the model’s attrs in the format of your API (i.e. whatever’s in your db), so we’d have something like <code class="highlighter-rouge">user.first_name</code>. But, what happens when you switch your app over to JSON:API? Now, you have to rewrite all the custom parts of your Mirage server, since it’s now <code class="highlighter-rouge">user['first-name']</code> in JSON:API. That’s pretty crappy. Not to mention, the dynamic methods added by the model layer, like <code class="highlighter-rouge">user.createPost</code>, should probably be consistent across API formats.</p>

<p>So, I think models should have camelCase attributes. That way you’re always using camelCase, regardless of the format of your API - which makes sense, since you’re writing a (mock) JavaScript server.</p>

<p>This presents an interesting challenge. How should the db fields be formatted? There’s three ways to create db data. Fixture files, factories, and using the ORM in a route handler (e.g. <code class="highlighter-rouge">schema.user.create(...)</code>). The latter two seem like they should be camelCase (again, you don’t want to have to update all your factories if you change from AMS to JSON:API…you may have to update some parts of your routes). But fixtures should always “just work”.</p>

<p>This leads me to think there should be a part of the “serializer layer” that can deserialize an API payload and get the attrs for the model(s), or at least in some way standardize it. This would mean if you change your API, you’d be able to use new fixture files just by specifying your new serializer. Also, it’d make the shorthands more versatile - they could basically use your serializers to deserialize the payload, and then they’d be able to create/update/delete the appropriate models regardless of your API format. Right now, they are coupled to AMS-style responses.</p>

<p>I’ll have to think more about this, but right now this feels like the right move.</p>

      </div>
    </div>
  

</div>

      </div>
    </div>

    <footer class="Footer">
  <div class="Container Grid Grid--gutters Grid--full med-Grid--fit">
    <div class="Grid-cell">
      <p>Project and site maintained by <a href="https://twitter.com/samselikoff">Sam Selikoff</a> and <a href="https://github.com/samselikoff/ember-cli-mirage/graphs/contributors">contributors</a>.</p>
    </div>
    <div class="Grid-cell">
      <div class="Github-stars">
        <iframe src="https://ghbtns.com/github-btn.html?user=samselikoff&repo=ember-cli-mirage&type=star&count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js"></script>
<script>
  /* global anchors */
  // anchors.options = {
  //   placement: 'left',
  //   visible: 'always'
  // };
  anchors.add('h2:not(.Home-page__feature-heading)');
</script>


  </body>
</html>
