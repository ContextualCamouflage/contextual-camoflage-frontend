'use strict';

define('dummy/tests/acceptance/contact-test', ['exports', 'qunit', 'dummy/tests/helpers/module-for-acceptance'], function (exports, _qunit, _dummyTestsHelpersModuleForAcceptance) {

  var contact = undefined;

  (0, _dummyTestsHelpersModuleForAcceptance['default'])('Acceptance | Contact', {
    beforeEach: function beforeEach() {
      contact = server.create('contact');
    }
  });

  (0, _qunit.test)('I can view a contact', function (assert) {
    visit('/1');

    andThen(function () {
      assert.equal(currentRouteName(), 'contact');
      assert.equal(find('p:first').text(), 'The contact is ' + contact.name);
    });
  });

  (0, _qunit.test)('I can delete a contact', function (assert) {
    visit('/1');
    click('button:contains(Delete)');

    andThen(function () {
      assert.equal(currentRouteName(), 'contacts');
      assert.equal(find('p').length, 0);
    });
  });
});
define('dummy/tests/acceptance/contact-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - acceptance/contact-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'acceptance/contact-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/acceptance/contacts-test', ['exports', 'qunit', 'dummy/tests/helpers/module-for-acceptance'], function (exports, _qunit, _dummyTestsHelpersModuleForAcceptance) {

  var contacts = undefined;

  (0, _dummyTestsHelpersModuleForAcceptance['default'])('Acceptance | Contacts', {
    beforeEach: function beforeEach() {
      contacts = server.createList('contact', 2);
    }
  });

  (0, _qunit.test)('I can view the contacts', function (assert) {
    visit('/');

    andThen(function () {
      assert.equal(currentRouteName(), 'contacts');
      assert.equal(find('p').length, 2);
      assert.equal(find('p:first').text(), contacts[0].name);
    });
  });

  (0, _qunit.test)('I can create a new contact', function (assert) {
    visit('/');
    fillIn('input', 'Ganon');
    click('button:contains(Create)');

    andThen(function () {
      assert.equal(currentRouteName(), 'contacts');
      assert.equal(find('p').length, 3);
      assert.equal(find('p:last').text(), 'Ganon');
    });
  });

  (0, _qunit.test)('If the server errors on /contacts, the first error message should show', function (assert) {
    server.get('/contacts', {
      errors: ['improper auth']
    }, 404);

    visit('/');

    andThen(function () {
      assert.equal(find('.error span').text(), 'improper auth');
    });
  });
});
define('dummy/tests/acceptance/contacts-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - acceptance/contacts-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'acceptance/contacts-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/acceptance/custom-handlers-test', ['exports', 'ember', 'dummy/tests/helpers/module-for-acceptance', 'qunit'], function (exports, _ember, _dummyTestsHelpersModuleForAcceptance, _qunit) {
  var ajax = _ember['default'].$.ajax;

  var appStore = undefined,
      rex = undefined;

  (0, _dummyTestsHelpersModuleForAcceptance['default'])('Acceptance | Custom handlers', {
    beforeEach: function beforeEach() {
      appStore = this.application.__container__.lookup('service:store');
      rex = server.create('pet', { name: 'Rex', alive: true });
      server.create('pet', { name: 'Toby', alive: false });
      server.create('pet', { name: 'Sam', alive: false });
      server.create('pet', { name: 'Andy', alive: true });
    }
  });

  (0, _qunit.test)('You can customize the response by passing a handler function that returns the desired body', function (assert) {
    var done = assert.async();
    appStore.findAll('pet').then(function (pets) {
      assert.deepEqual(pets.mapBy('name'), ['Rex', 'Andy']);
    })['finally'](done);
  });

  (0, _qunit.test)('You can customize the response code of a custom handler passing the code as 3rd argument', function (assert) {
    var done = assert.async();
    var request = ajax({
      url: '/pets/${rex.id}',
      method: 'delete'
    });

    request.then(function (response, statusText, jqXHR) {
      assert.equal(jqXHR.status, 200, 'The status code is 200 instead od 204');
      done();
    });
  });

  (0, _qunit.test)('You can can programatically returns a tailored response by returning a Mirage.Response', function (assert) {
    var done = assert.async();
    var request = ajax({
      url: '/pets',
      method: 'post',
      data: JSON.stringify({ pet: { alive: true } })
    });

    request.then(function () {/* noop */}, function (response) {
      assert.equal(response.status, 422, 'The status code is 422');
      assert.equal(response.responseText, '{"errors":{"name":["can\'t be blank"]}}', 'The response body is correct');
      assert.equal(response.getResponseHeader('some'), 'header', 'The response contains the custom header');
      done();
    });
  });

  (0, _qunit.test)('returning a non-blank response from a custom handler whose default status is 204 changes the status to 200', function (assert) {
    var done = assert.async();
    var request = ajax({
      url: '/pets/${rex.id}',
      method: 'put',
      data: JSON.stringify({ pet: { id: rex.id, name: 'The Rex', alive: true } })
    });

    request.then(function (response, statusText, jqXHR) {
      assert.equal(jqXHR.status, 200, 'The status code is 200 instead of 204');
      assert.deepEqual(response, { id: '1', name: 'The Rex', alive: true }, 'The response is correct');
      done();
    });
  });
});
define('dummy/tests/acceptance/custom-handlers-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - acceptance/custom-handlers-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'acceptance/custom-handlers-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/acceptance/edit-test', ['exports', 'qunit', 'dummy/tests/helpers/module-for-acceptance'], function (exports, _qunit, _dummyTestsHelpersModuleForAcceptance) {

  (0, _dummyTestsHelpersModuleForAcceptance['default'])('Acceptance | Edit');

  (0, _qunit.test)('I can edit a contact', function (assert) {
    server.create('contact');

    visit('/1');
    click('button:contains(Edit)');
    fillIn('input', 'Shiek');
    click('button:contains(Save)');

    andThen(function () {
      assert.equal(currentRouteName(), 'contact');
      assert.equal(find('p:first').text(), 'The contact is Shiek');
    });
  });
});
define('dummy/tests/acceptance/edit-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - acceptance/edit-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'acceptance/edit-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/acceptance/fixtures-test', ['exports', 'dummy/tests/helpers/module-for-acceptance', 'qunit'], function (exports, _dummyTestsHelpersModuleForAcceptance, _qunit) {

  (0, _dummyTestsHelpersModuleForAcceptance['default'])('Acceptance | Fixtures', {
    beforeEach: function beforeEach() {
      this.store = this.application.__container__.lookup('service:store');
    }
  });

  (0, _qunit.test)('I can use fixtures', function (assert) {
    var _this = this;

    server.loadFixtures();

    visit('/word-smiths/1');

    andThen(function () {
      var wordSmithsInStore = _this.store.peekAll('word-smith');
      var blogPostsInStore = _this.store.peekAll('blog-post');

      assert.equal(wordSmithsInStore.get('length'), 1);
      assert.equal(blogPostsInStore.get('length'), 3);
    });
  });

  (0, _qunit.test)('I can use fixtures with the filename api', function (assert) {
    var _this2 = this;

    server.loadFixtures('word-smiths', 'blog-posts');

    visit('/word-smiths/1');

    andThen(function () {
      var wordSmithsInStore = _this2.store.peekAll('word-smith');
      var blogPostsInStore = _this2.store.peekAll('blog-post');

      assert.equal(wordSmithsInStore.get('length'), 1);
      assert.equal(blogPostsInStore.get('length'), 3);
    });
  });
});
define('dummy/tests/acceptance/fixtures-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - acceptance/fixtures-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'acceptance/fixtures-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/acceptance/friends-test', ['exports', 'qunit', 'dummy/tests/helpers/module-for-acceptance'], function (exports, _qunit, _dummyTestsHelpersModuleForAcceptance) {

  (0, _dummyTestsHelpersModuleForAcceptance['default'])('Acceptance | Friends');

  (0, _qunit.test)('I can view the friends', function (assert) {
    var friend = server.create('friend');
    var youngFriend = server.create('friend', { name: 'Tommy', age: 10 });

    visit('/friends');

    andThen(function () {
      assert.equal(currentRouteName(), 'friends');
      assert.equal(find('p').length, 2);
      assert.equal(friend.isYoung, false);
      assert.equal(youngFriend.isYoung, true);

      assert.ok(find('p:first').text().match(friend.name));
      assert.ok(find('p:first').text().match(friend.age));
      assert.ok(find('p:last').text().match('Tommy'));
      assert.ok(find('p:last').text().match(10));
    });
  });

  (0, _qunit.test)('I can view the selected friends', function (assert) {
    server.create('friend', { name: 'Jane', age: 30 });
    server.create('friend', { name: 'Tommy', age: 10 });
    server.create('friend', { name: 'Bob', age: 28 });

    visit('/close-friends');

    andThen(function () {
      assert.equal(currentRouteName(), 'close-friends');
      assert.equal(find('p').length, 2);

      assert.ok(find('p:first').text().match('Jane'));
      assert.ok(find('p:first').text().match(30));
      assert.ok(find('p:last').text().match('Bob'));
      assert.ok(find('p:last').text().match(28));
    });
  });

  (0, _qunit.test)('I can view a friend that was configured only for test mode', function (assert) {
    var friend = server.create('friend', { name: 'The Dude' });

    visit('/friends/' + friend.id);

    andThen(function () {
      assert.equal(currentRouteName(), 'friend');
      assert.ok(find('h2.friend-name').text().match('The Dude'));
    });
  });
});
define('dummy/tests/acceptance/friends-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - acceptance/friends-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'acceptance/friends-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/acceptance/manually-starting-test', ['exports', 'ember', 'qunit', 'dummy/tests/helpers/start-app', 'dummy/initializers/ember-cli-mirage', 'dummy/config/environment'], function (exports, _ember, _qunit, _dummyTestsHelpersStartApp, _dummyInitializersEmberCliMirage, _dummyConfigEnvironment) {
  var run = _ember['default'].run;

  var App = undefined;

  (0, _qunit.module)('Acceptance: Manually starting Mirage', {
    beforeEach: function beforeEach() {
      _dummyConfigEnvironment['default']['ember-cli-mirage'] = { enabled: false };
      App = (0, _dummyTestsHelpersStartApp['default'])();
    },

    afterEach: function afterEach() {
      server.shutdown();
      run(App, 'destroy');
      _dummyConfigEnvironment['default']['ember-cli-mirage'].enabled = undefined;
    }
  });

  (0, _qunit.test)('The server can be started manually when configured with { enabled: false }', function (assert) {
    assert.equal(window.server, undefined, 'There is no server at first');
    (0, _dummyInitializersEmberCliMirage.startMirage)();
    assert.ok(window.server, 'There is a server after starting');

    var contact = server.create('contact');
    visit('/1');

    andThen(function () {
      assert.equal(currentRouteName(), 'contact');
      assert.equal(find('p:first').text(), 'The contact is ' + contact.name, 'The manually started server works');
    });
  });
});
define('dummy/tests/acceptance/manually-starting-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - acceptance/manually-starting-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'acceptance/manually-starting-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/acceptance/pets-test', ['exports', 'qunit', 'dummy/tests/helpers/module-for-acceptance'], function (exports, _qunit, _dummyTestsHelpersModuleForAcceptance) {

  var pets = undefined;

  (0, _dummyTestsHelpersModuleForAcceptance['default'])('Acceptance | Pets', {
    beforeEach: function beforeEach() {
      pets = server.createList('pet', 3);
    }
  });

  (0, _qunit.test)('I can view the pets', function (assert) {
    visit('/pets');

    andThen(function () {
      assert.equal(currentRouteName(), 'pets');
      assert.equal(find('li').length, 3);
      assert.equal(find('li:first .name').text().trim(), pets[0].name);
    });
  });

  (0, _qunit.test)('I can create a new pet', function (assert) {
    visit('/pets');

    fillIn('input', 'Brownie');
    click('button:contains(create)');

    andThen(function () {
      assert.equal(currentRouteName(), 'pets');
      assert.equal(find('li').length, 4);
      assert.equal(find('li:last .name').text(), 'Brownie');
    });
  });
});
define('dummy/tests/acceptance/pets-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - acceptance/pets-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'acceptance/pets-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/acceptance/serializers-test', ['exports', 'dummy/tests/helpers/module-for-acceptance', 'qunit'], function (exports, _dummyTestsHelpersModuleForAcceptance, _qunit) {

  (0, _dummyTestsHelpersModuleForAcceptance['default'])('Acceptance | Serializers', {
    beforeEach: function beforeEach() {
      this.store = this.application.__container__.lookup('service:store');
    }
  });

  (0, _qunit.test)('Serializers can provide default includes', function (assert) {
    var _this = this;

    var wordSmith = server.create('word-smith');
    server.createList('blog-post', 3, { wordSmithId: wordSmith.id });

    visit('/word-smiths/' + wordSmith.id);

    andThen(function () {
      var wordSmithsInStore = _this.store.peekAll('word-smith');
      var blogPostsInStore = _this.store.peekAll('blog-post');

      assert.equal(wordSmithsInStore.get('length'), 1);
      assert.equal(blogPostsInStore.get('length'), 3);
    });
  });
});
define('dummy/tests/acceptance/serializers-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - acceptance/serializers-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'acceptance/serializers-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/adapters/application.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - adapters/application.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'adapters/application.js should pass ESLint.\n');
  });
});
define('dummy/tests/adapters/word-smith.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - adapters/word-smith.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'adapters/word-smith.js should pass ESLint.\n');
  });
});
define('dummy/tests/app.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - app.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'app.js should pass ESLint.\n');
  });
});
define('dummy/tests/controllers/application.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - controllers/application.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'controllers/application.js should pass ESLint.\n');
  });
});
define('dummy/tests/fixtures/config/environment-development-disabled', ['exports'], function (exports) {
  /* eslint-env node */
  /* eslint no-empty: 0 */

  module.exports = function (environment) {
    var ENV = {
      modulePrefix: 'scaffold-test',
      environment: environment,
      baseURL: '/',
      locationType: 'auto',
      EmberENV: {
        FEATURES: {
          // Here you can enable experimental features on an ember canary build
          // e.g. 'with-controller': true
        }
      },

      APP: {
        // Here you can pass flags/options to your application instance
        // when it is created
      }
    };

    if (environment === 'development') {
      // ENV.APP.LOG_RESOLVER = true;
      // ENV.APP.LOG_ACTIVE_GENERATION = true;
      // ENV.APP.LOG_TRANSITIONS = true;
      // ENV.APP.LOG_TRANSITIONS_INTERNAL = true;
      // ENV.APP.LOG_VIEW_LOOKUPS = true;
      ENV['ember-cli-mirage'] = {
        enabled: false
      };
    }

    if (environment === 'test') {
      // Testem prefers this...
      ENV.baseURL = '/';
      ENV.locationType = 'none';

      // keep test console output quieter
      ENV.APP.LOG_ACTIVE_GENERATION = false;
      ENV.APP.LOG_VIEW_LOOKUPS = false;

      ENV.APP.rootElement = '#ember-testing';
    }

    if (environment === 'production') {}

    return ENV;
  };
});
define('dummy/tests/fixtures/config/environment-development-disabled.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - fixtures/config/environment-development-disabled.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'fixtures/config/environment-development-disabled.js should pass ESLint.\n');
  });
});
define('dummy/tests/fixtures/config/environment-production-enabled', ['exports'], function (exports) {
  /* eslint-env node */

  module.exports = function (environment) {
    var ENV = {
      modulePrefix: 'scaffold-test',
      environment: environment,
      baseURL: '/',
      locationType: 'auto',
      EmberENV: {
        FEATURES: {
          // Here you can enable experimental features on an ember canary build
          // e.g. 'with-controller': true
        }
      },

      APP: {
        // Here you can pass flags/options to your application instance
        // when it is created
      }
    };

    if (environment === 'development') {
      // ENV.APP.LOG_RESOLVER = true;
      // ENV.APP.LOG_ACTIVE_GENERATION = true;
      // ENV.APP.LOG_TRANSITIONS = true;
      // ENV.APP.LOG_TRANSITIONS_INTERNAL = true;
      // ENV.APP.LOG_VIEW_LOOKUPS = true;
    }

    if (environment === 'test') {
      // Testem prefers this...
      ENV.baseURL = '/';
      ENV.locationType = 'none';

      // keep test console output quieter
      ENV.APP.LOG_ACTIVE_GENERATION = false;
      ENV.APP.LOG_VIEW_LOOKUPS = false;

      ENV.APP.rootElement = '#ember-testing';
    }

    if (environment === 'production') {
      ENV['ember-cli-mirage'] = {
        enabled: true
      };
    }

    return ENV;
  };
});
define('dummy/tests/fixtures/config/environment-production-enabled.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - fixtures/config/environment-production-enabled.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'fixtures/config/environment-production-enabled.js should pass ESLint.\n');
  });
});
define('dummy/tests/fixtures/config/environment-test-disabled', ['exports'], function (exports) {
  /* eslint-env node */
  /* eslint no-empty: 0 */

  module.exports = function (environment) {
    var ENV = {
      modulePrefix: 'scaffold-test',
      environment: environment,
      baseURL: '/',
      locationType: 'auto',
      EmberENV: {
        FEATURES: {
          // Here you can enable experimental features on an ember canary build
          // e.g. 'with-controller': true
        }
      },

      APP: {
        // Here you can pass flags/options to your application instance
        // when it is created
      }
    };

    if (environment === 'development') {
      // ENV.APP.LOG_RESOLVER = true;
      // ENV.APP.LOG_ACTIVE_GENERATION = true;
      // ENV.APP.LOG_TRANSITIONS = true;
      // ENV.APP.LOG_TRANSITIONS_INTERNAL = true;
      // ENV.APP.LOG_VIEW_LOOKUPS = true;
    }

    if (environment === 'test') {
      // Testem prefers this...
      ENV.baseURL = '/';
      ENV.locationType = 'none';

      // keep test console output quieter
      ENV.APP.LOG_ACTIVE_GENERATION = false;
      ENV.APP.LOG_VIEW_LOOKUPS = false;

      ENV.APP.rootElement = '#ember-testing';
      ENV['ember-cli-mirage'] = {
        enabled: false
      };
    }

    if (environment === 'production') {}

    return ENV;
  };
});
define('dummy/tests/fixtures/config/environment-test-disabled.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - fixtures/config/environment-test-disabled.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'fixtures/config/environment-test-disabled.js should pass ESLint.\n');
  });
});
define('dummy/tests/helpers/destroy-app', ['exports', 'ember'], function (exports, _ember) {
  exports['default'] = destroyApp;
  var run = _ember['default'].run;

  function destroyApp(application) {
    run(function () {
      application.destroy();

      server.shutdown();
    });
  }
});
define('dummy/tests/helpers/destroy-app.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - helpers/destroy-app.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/destroy-app.js should pass ESLint.\n');
  });
});
define('dummy/tests/helpers/module-for-acceptance', ['exports', 'qunit', 'ember', 'dummy/tests/helpers/start-app', 'dummy/tests/helpers/destroy-app'], function (exports, _qunit, _ember, _dummyTestsHelpersStartApp, _dummyTestsHelpersDestroyApp) {
  var Promise = _ember['default'].RSVP.Promise;

  exports['default'] = function (name) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    (0, _qunit.module)(name, {
      beforeEach: function beforeEach() {
        this.application = (0, _dummyTestsHelpersStartApp['default'])();

        if (options.beforeEach) {
          return options.beforeEach.apply(this, arguments);
        }
      },

      afterEach: function afterEach() {
        var _this = this;

        var afterEach = options.afterEach && options.afterEach.apply(this, arguments);
        return Promise.resolve(afterEach).then(function () {
          return (0, _dummyTestsHelpersDestroyApp['default'])(_this.application);
        });
      }
    });
  };
});
define('dummy/tests/helpers/module-for-acceptance.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - helpers/module-for-acceptance.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/module-for-acceptance.js should pass ESLint.\n');
  });
});
define('dummy/tests/helpers/resolver', ['exports', 'dummy/resolver', 'dummy/config/environment'], function (exports, _dummyResolver, _dummyConfigEnvironment) {

  var resolver = _dummyResolver['default'].create();

  resolver.namespace = {
    modulePrefix: _dummyConfigEnvironment['default'].modulePrefix,
    podModulePrefix: _dummyConfigEnvironment['default'].podModulePrefix
  };

  exports['default'] = resolver;
});
define('dummy/tests/helpers/resolver.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - helpers/resolver.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/resolver.js should pass ESLint.\n');
  });
});
define('dummy/tests/helpers/start-app', ['exports', 'ember', 'dummy/app', 'dummy/config/environment'], function (exports, _ember, _dummyApp, _dummyConfigEnvironment) {
  exports['default'] = startApp;
  var merge = _ember['default'].merge;
  var run = _ember['default'].run;

  function startApp(attrs) {
    var application = undefined;

    var attributes = merge({}, _dummyConfigEnvironment['default'].APP);
    attributes = merge(attributes, attrs); // use defaults, but you can override;

    run(function () {
      application = _dummyApp['default'].create(attributes);
      application.setupForTesting();
      application.injectTestHelpers();
    });

    return application;
  }
});
define('dummy/tests/helpers/start-app.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - helpers/start-app.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'helpers/start-app.js should pass ESLint.\n');
  });
});
define('dummy/tests/index-named-imports-test', ['exports', 'qunit', 'ember-cli-mirage'], function (exports, _qunit, _emberCliMirage) {

  (0, _qunit.test)('Factory is present in named exports from ember-cli-mirage', function (assert) {
    assert.ok(_emberCliMirage.Factory);
  });

  (0, _qunit.test)('Response is present in named exports from ember-cli-mirage', function (assert) {
    assert.ok(_emberCliMirage.Response);
  });

  (0, _qunit.test)('faker is present in named exports from ember-cli-mirage', function (assert) {
    assert.ok(_emberCliMirage.faker);
  });

  (0, _qunit.test)('Model is present in named exports from ember-cli-mirage', function (assert) {
    assert.ok(_emberCliMirage.Model);
  });

  (0, _qunit.test)('serializers are present in named exports from ember-cli-mirage', function (assert) {
    assert.ok(_emberCliMirage.ActiveModelSerializer);
    assert.ok(_emberCliMirage.JSONAPISerializer);
    assert.ok(_emberCliMirage.Serializer);
  });

  (0, _qunit.test)('relationship helpers are present in named exports from ember-cli-mirage', function (assert) {
    assert.ok(_emberCliMirage.hasMany);
    assert.ok(_emberCliMirage.belongsTo);
  });
});
define('dummy/tests/index-named-imports-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - index-named-imports-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'index-named-imports-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/initializers/es2015-polyfills.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - initializers/es2015-polyfills.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'initializers/es2015-polyfills.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/database-test', ['exports', 'qunit', 'ember-cli-mirage/server', 'ember-cli-mirage'], function (exports, _qunit, _emberCliMirageServer, _emberCliMirage) {

  (0, _qunit.module)('Integration | Database', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        scenarios: {
          'default': function _default() {}
        },
        models: {
          author: _emberCliMirage.Model
        },
        factories: {
          author: _emberCliMirage.Factory
        },
        fixtures: {
          authors: [{ id: 1, name: 'Zelda' }]
        }
      });
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('[regression] When loaded, fixture files correctly update the database\'s autoincrement id', function (assert) {
    this.server.loadFixtures();

    this.server.schema.authors.create({});

    var authors = this.server.db.authors;

    assert.equal(authors.length, 2);
    assert.deepEqual(authors.map(function (a) {
      return a.id;
    }), ['1', '2']);
  });
});
define('dummy/tests/integration/database-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/database-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/database-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/factories/after-create-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirage, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Server | Factories | afterCreate', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'test',
        models: {
          author: _emberCliMirage.Model,
          post: _emberCliMirage.Model.extend({
            author: (0, _emberCliMirage.belongsTo)()
          }),
          comment: _emberCliMirage.Model.extend({
            post: (0, _emberCliMirage.belongsTo)()
          })
        },
        factories: {
          author: _emberCliMirage.Factory.extend({
            afterCreate: function afterCreate(author, server) {
              author.update({ name: 'Sam' });
              server.create('post', { author: author });
            }
          }),
          post: _emberCliMirage.Factory.extend({
            title: 'Lorem ipsum',
            afterCreate: function afterCreate(post, server) {
              server.create('comment', { post: post });
            }
          }),
          comment: _emberCliMirage.Factory.extend({
            text: 'Yo soy el nino'
          })
        }
      });
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('it works for models', function (assert) {
    var author = this.server.create('author');

    assert.equal(author.name, 'Sam');
    assert.deepEqual(this.server.db.posts.length, 1);
    assert.deepEqual(this.server.db.posts[0], { id: '1', title: 'Lorem ipsum', authorId: '1' });
    assert.deepEqual(this.server.db.comments.length, 1);
    assert.deepEqual(this.server.db.comments[0], { id: '1', text: 'Yo soy el nino', postId: '1' });
  });

  // test('it works for db records', function(assert) {
  // });
});
define('dummy/tests/integration/factories/after-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/factories/after-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/factories/after-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/factories/helpers-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirage, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Server | Factories | helpers', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'test',
        models: {
          author: _emberCliMirage.Model.extend({
            posts: (0, _emberCliMirage.hasMany)()
          }),
          category: _emberCliMirage.Model.extend({
            posts: (0, _emberCliMirage.hasMany)('post', { inverse: 'kind' })
          }),
          post: _emberCliMirage.Model.extend({
            author: (0, _emberCliMirage.belongsTo)(),
            kind: (0, _emberCliMirage.belongsTo)('category')
          })
        },
        factories: {
          author: _emberCliMirage.Factory.extend({
            name: 'Sam'
          }),
          category: _emberCliMirage.Factory.extend({
            name: 'awesome software'
          }),
          post: _emberCliMirage.Factory.extend({
            title: 'Lorem ipsum',

            author: (0, _emberCliMirage.association)(),

            withCategory: (0, _emberCliMirage.trait)({
              kind: (0, _emberCliMirage.association)()
            })
          })
        }
      });
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('it creates associations with "association" helper combininig with traits', function (assert) {
    var post = this.server.create('post', 'withCategory');

    assert.ok(post.kind);
    assert.ok(post.author);

    var db = this.server.db;

    assert.equal(db.posts.length, 1);
    assert.deepEqual(db.posts[0], {
      id: '1',
      title: 'Lorem ipsum',
      authorId: '1',
      kindId: '1'
    });

    assert.equal(db.authors.length, 1);
    assert.deepEqual(db.authors[0], {
      id: '1',
      name: 'Sam',
      postIds: ['1']
    });

    assert.equal(db.categories.length, 1);
    assert.deepEqual(db.categories[0], {
      id: '1',
      name: 'awesome software',
      postIds: ['1']
    });
  });
});
define('dummy/tests/integration/factories/helpers-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/factories/helpers-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/factories/helpers-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/http-verbs-test', ['exports', 'qunit', 'ember-cli-mirage/server', 'ember-cli-mirage'], function (exports, _qunit, _emberCliMirageServer, _emberCliMirage) {

  (0, _qunit.module)('Integration | HTTP Verbs', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        models: {
          contact: _emberCliMirage.Model
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('mirage responds to get', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server.get('/contacts', function () {
      return true;
    });

    $.ajax({
      method: 'GET',
      url: '/contacts'
    }).done(function (res) {
      assert.equal(res, true);
      done();
    });
  });

  (0, _qunit.test)('mirage responds to post', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server.post('/contacts', function () {
      return true;
    });

    $.ajax({
      method: 'POST',
      url: '/contacts'
    }).done(function (res) {
      assert.equal(res, true);
      done();
    });
  });

  (0, _qunit.test)('mirage responds to put', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server.put('/contacts', function () {
      return true;
    });

    $.ajax({
      method: 'PUT',
      url: '/contacts'
    }).done(function (res) {
      assert.equal(res, true);
      done();
    });
  });

  (0, _qunit.test)('mirage responds to delete', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server['delete']('/contacts', function () {
      return true;
    });

    $.ajax({
      method: 'DELETE',
      url: '/contacts'
    }).done(function (res) {
      assert.equal(res, true);
      done();
    });
  });

  (0, _qunit.test)('mirage responds to patch', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server.patch('/contacts', function () {
      return true;
    });

    $.ajax({
      method: 'PATCH',
      url: '/contacts'
    }).done(function (res) {
      assert.equal(res, true);
      done();
    });
  });

  (0, _qunit.test)('mirage responds to resource', function (assert) {
    assert.expect(0);
    var done = assert.async();

    this.server.resource('contacts');

    $.ajax({
      method: 'GET',
      url: '/contacts'
    }).done(function () {
      done();
    });
  });

  (0, _qunit.test)('response code can be customized', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server.get('/contacts', {}, 404);

    $.ajax({
      method: 'GET',
      url: '/contacts',
      complete: function complete(res) {
        assert.ok(res.status, 404);
        done();
      }
    });
  });
});
define('dummy/tests/integration/http-verbs-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/http-verbs-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/http-verbs-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/load-fixtures-test', ['exports', 'qunit', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Server #loadFixtures', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        scenarios: {
          'default': function _default() {}
        },
        factories: {
          author: {},
          post: {},
          comment: {}
        },
        fixtures: {
          authors: [{ id: 1, name: 'Zelda' }, { id: 2, name: 'Link' }],
          posts: [{ id: 1, title: 'Lorem' }, { id: 2, title: 'Ipsum' }],
          comments: [{ id: 1, title: 'Lorem' }]
        }
      });
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('it can load all fixtures in the map', function (assert) {
    this.server.loadFixtures();

    assert.equal(this.server.db.authors.length, 2);
    assert.equal(this.server.db.posts.length, 2);
    assert.equal(this.server.db.comments.length, 1);
  });

  (0, _qunit.test)('it can load a single named fixture file', function (assert) {
    this.server.loadFixtures('authors');

    assert.equal(this.server.db.authors.length, 2);
    assert.equal(this.server.db.posts.length, 0);
    assert.equal(this.server.db.comments.length, 0);
  });

  (0, _qunit.test)('it can load several named single fixtures', function (assert) {
    this.server.loadFixtures('authors', 'posts');

    assert.equal(this.server.db.authors.length, 2);
    assert.equal(this.server.db.posts.length, 2);
    assert.equal(this.server.db.comments.length, 0);
  });
});
define('dummy/tests/integration/load-fixtures-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/load-fixtures-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/load-fixtures-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/all-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'ember-cli-mirage/orm/collection', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _emberCliMirageOrmCollection, _qunit) {

  (0, _qunit.module)('Integration | ORM | #all');

  (0, _qunit.test)('it can return all models', function (assert) {
    var db = new _emberCliMirageDb['default']({
      users: [{ id: 1, name: 'Link' }, { id: 2, name: 'Zelda' }]
    });
    var User = _emberCliMirageOrmModel['default'].extend();
    var schema = new _emberCliMirageOrmSchema['default'](db, {
      user: User
    });

    var users = schema.users.all();
    assert.ok(users instanceof _emberCliMirageOrmCollection['default'], 'it returns a collection');
    assert.ok(users.models[0] instanceof User, 'each member of the collection is a model');
    assert.equal(users.models.length, 2);
    assert.deepEqual(users.models[1].attrs, { id: '2', name: 'Zelda' });
  });

  (0, _qunit.test)('it returns an empty array when no models exist', function (assert) {
    var db = new _emberCliMirageDb['default']({ users: [] });

    var User = _emberCliMirageOrmModel['default'].extend();
    var schema = new _emberCliMirageOrmSchema['default'](db, {
      user: User
    });

    var users = schema.users.all();

    assert.ok(users instanceof _emberCliMirageOrmCollection['default'], 'it returns a collection');
    assert.equal(users.modelName, 'user', 'the collection knows its type');
    assert.equal(users.models.length, 0);
  });
});
define('dummy/tests/integration/orm/all-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/all-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/all-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/attrs-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _qunit) {

  var db, schema, User;
  (0, _qunit.module)('Integration | ORM | attrs', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']({ users: [{ id: 1, name: 'Link', evil: false }] });

      User = _emberCliMirageOrmModel['default'].extend();
      schema = new _emberCliMirageOrmSchema['default'](db, {
        user: User
      });
    }
  });

  (0, _qunit.test)('attrs returns the models attributes', function (assert) {
    var user = schema.users.find(1);

    assert.deepEqual(user.attrs, { id: '1', name: 'Link', evil: false });
  });

  (0, _qunit.test)('attributes can be read via plain property access', function (assert) {
    var user = schema.users.find(1);

    assert.equal(user.name, 'Link');
  });
});
define('dummy/tests/integration/orm/attrs-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/attrs-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/attrs-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a belongsTo association can be in six states
    with respect to its association. This helper class
    returns a child (and its association) in these various states.
  
    The return value is an array of the form
  
      [ child, parent ]
  
    where the parent may be undefined.
  */

  var BelongsToHelper = (function () {
    function BelongsToHelper() {
      _classCallCheck(this, BelongsToHelper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        author: _emberCliMirage.Model.extend(),
        post: _emberCliMirage.Model.extend({
          author: (0, _emberCliMirage.belongsTo)()
        })
      });
    }

    _createClass(BelongsToHelper, [{
      key: 'savedChildNoParent',
      value: function savedChildNoParent() {
        var insertedPost = this.db.posts.insert({ title: 'Lorem' });

        return [this.schema.posts.find(insertedPost.id), undefined];
      }
    }, {
      key: 'savedChildNewParent',
      value: function savedChildNewParent() {
        var insertedPost = this.db.posts.insert({ title: 'Lorem' });
        var post = this.schema.posts.find(insertedPost.id);
        var author = this.schema.authors['new']({ name: 'Bob' });

        post.author = author;

        return [post, author];
      }
    }, {
      key: 'savedChildSavedParent',
      value: function savedChildSavedParent() {
        var insertedAuthor = this.db.authors.insert({ name: 'Bob' });
        var insertedPost = this.db.posts.insert({ title: 'Lorem', authorId: insertedAuthor.id });
        var post = this.schema.posts.find(insertedPost.id);
        var author = this.schema.authors.find(insertedAuthor.id);

        return [post, author];
      }
    }, {
      key: 'newChildNoParent',
      value: function newChildNoParent() {
        return [this.schema.posts['new']({ title: 'Lorem' }), undefined];
      }
    }, {
      key: 'newChildNewParent',
      value: function newChildNewParent() {
        var post = this.schema.posts['new']({ title: 'Lorem' });
        var newAuthor = this.schema.authors['new']({ name: 'Bob' });
        post.author = newAuthor;

        return [post, newAuthor];
      }
    }, {
      key: 'newChildSavedParent',
      value: function newChildSavedParent() {
        var insertedAuthor = this.db.authors.insert({ name: 'Bob' });
        var post = this.schema.posts['new']({ title: 'Lorem' });
        var savedAuthor = this.schema.authors.find(insertedAuthor.id);

        post.author = savedAuthor;

        return [post, savedAuthor];
      }

      // Just a saved unassociated parent.
    }, {
      key: 'savedParent',
      value: function savedParent() {
        var insertedAuthor = this.db.authors.insert({ name: 'Bob' });

        return this.schema.authors.find(insertedAuthor.id);
      }
    }, {
      key: 'newParent',
      value: function newParent() {
        return this.schema.authors['new']({ name: 'Bob' });
      }
    }]);

    return BelongsToHelper;
  })();

  exports['default'] = BelongsToHelper;
  var states = ['savedChildNoParent', 'savedChildNewParent', 'savedChildSavedParent', 'newChildNoParent', 'newChildNewParent', 'newChildSavedParent'];
  exports.states = states;
});
define('dummy/tests/integration/orm/belongs-to/1-basic/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/_regressions-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Basic | regressions');

  (0, _qunit.test)('belongsTo accessors works when foreign key is present but falsy', function (assert) {
    var db = new _emberCliMirageDb['default']({
      posts: [{ id: 1, authorId: 0, name: 'some post' }],
      authors: [{ id: 0, name: 'Foo' }]
    });

    var schema = new _emberCliMirageOrmSchema['default'](db, {
      author: _emberCliMirage.Model.extend(),
      post: _emberCliMirage.Model.extend({
        author: (0, _emberCliMirage.belongsTo)()
      })
    });

    var post = schema.posts.find(1);
    assert.equal(post.author.name, 'Foo');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/_regressions-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/_regressions-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/_regressions-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/accessor-test', ['exports', 'dummy/tests/integration/orm/belongs-to/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Basic | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo1Basic_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var post = _helper$state2[0];
      var author = _helper$state2[1];

      assert.deepEqual(post.author, author ? author : null, 'the model reference is correct');
      assert.equal(post.authorId, author ? author.id : null, 'the modelId reference is correct');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/association-create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Basic | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo1Basic_helper['default']();
    }
  });

  /*
    The model can create a belongs-to association, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var post = _helper$state2[0];

      var ganon = post.createAuthor({ name: 'Ganon' });

      assert.ok(ganon.id, 'the parent was persisted');
      assert.deepEqual(post.author.attrs, ganon.attrs);
      assert.equal(post.authorId, ganon.id);
      assert.equal(this.helper.schema.posts.find(post.id).authorId, ganon.id, 'the child was persisted');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/association-new-test', ['exports', 'dummy/tests/integration/orm/belongs-to/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Basic | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo1Basic_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmBelongsTo1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var post = _helper$state2[0];

      var ganon = post.newAuthor({ name: 'Ganon' });

      assert.ok(!ganon.id, 'the parent was not persisted');
      assert.deepEqual(post.author, ganon);
      assert.equal(post.authorId, null);

      post.save();

      assert.ok(ganon.id, 'saving the child persists the parent');
      assert.equal(post.authorId, ganon.id, 'the childs fk was updated');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/association-set-id-test', ['exports', 'dummy/tests/integration/orm/belongs-to/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Basic | association #setId', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo1Basic_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var post = _helper$state2[0];

      var savedAuthor = this.helper.savedParent();

      post.authorId = savedAuthor.id;

      assert.equal(post.authorId, savedAuthor.id);
      assert.deepEqual(post.author.attrs, savedAuthor.attrs);
    });
  });

  ['savedChildSavedParent', 'newChildSavedParent'].forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var post = _helper$state32[0];

      post.authorId = null;

      assert.equal(post.authorId, null);
      assert.deepEqual(post.author, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/association-set-id-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/association-set-id-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/association-set-id-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/association-set-test', ['exports', 'dummy/tests/integration/orm/belongs-to/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Basic | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo1Basic_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var post = _helper$state2[0];

      var savedAuthor = this.helper.savedParent();

      post.author = savedAuthor;

      assert.equal(post.authorId, savedAuthor.id);
      assert.deepEqual(post.author, savedAuthor);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var post = _helper$state32[0];

      var newAuthor = this.helper.newParent();

      post.author = newAuthor;

      assert.equal(post.authorId, null);
      assert.deepEqual(post.author, newAuthor);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a null parent', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var post = _helper$state42[0];

      post.author = null;

      assert.equal(post.authorId, null);
      assert.deepEqual(post.author, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/1-basic/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo1Basic_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Basic | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo1Basic_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var author = this.helper.schema.create('author');
    var post = this.helper.schema.create('post', {
      authorId: author.id
    });

    assert.equal(post.authorId, author.id);
    assert.deepEqual(post.author.attrs, author.attrs);
    assert.equal(this.helper.schema.db.authors.length, 1);
    assert.deepEqual(this.helper.schema.db.authors[0], { id: '1' });
    assert.equal(this.helper.schema.db.posts.length, 1);
    assert.deepEqual(this.helper.schema.db.posts[0], { id: '1', authorId: '1' });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the association itself', function (assert) {
    var author = this.helper.schema.create('author');
    var post = this.helper.schema.create('post', {
      author: author
    });

    assert.equal(post.authorId, author.id);
    assert.deepEqual(post.author.attrs, author.attrs);
    assert.equal(this.helper.schema.db.authors.length, 1);
    assert.deepEqual(this.helper.schema.db.authors[0], { id: '1' });
    assert.equal(this.helper.schema.db.posts.length, 1);
    assert.deepEqual(this.helper.schema.db.posts[0], { id: '1', authorId: '1' });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('post', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('post', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/delete-test', ['exports', 'dummy/tests/integration/orm/belongs-to/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Basic | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo1Basic_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmBelongsTo1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting the parent updates the child\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var post = _helper$state2[0];
      var author = _helper$state2[1];

      if (author) {
        author.destroy();
        post.reload();
      }

      assert.equal(post.authorId, null);
      assert.deepEqual(post.author, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/instantiating-test', ['exports', 'dummy/tests/integration/orm/belongs-to/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo1Basic_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Basic | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo1Basic_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the child accepts a saved parent id', function (assert) {
    var author = this.helper.savedParent();
    var post = this.schema.posts['new']({ authorId: author.id });

    assert.equal(post.authorId, author.id);
    assert.deepEqual(post.author, author);
    assert.deepEqual(post.attrs, { authorId: author.id });
  });

  (0, _qunit.test)('the child errors if the parent id doesnt exist', function (assert) {
    assert.throws(function () {
      this.schema.posts['new']({ authorId: 2 });
    }, /You're instantiating a post that has a authorId of 2, but that record doesn't exist in the database/);
  });

  (0, _qunit.test)('the child accepts a null parent id', function (assert) {
    var post = this.schema.posts['new']({ authorId: null });

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, null);
    assert.deepEqual(post.attrs, { authorId: null });
  });

  (0, _qunit.test)('the child accepts a saved parent model', function (assert) {
    var author = this.helper.savedParent();
    var post = this.schema.posts['new']({ author: author });

    assert.equal(post.authorId, 1);
    assert.deepEqual(post.author, author);
  });

  (0, _qunit.test)('the child accepts a new parent model', function (assert) {
    var zelda = this.schema.authors['new']({ name: 'Zelda' });
    var post = this.schema.posts['new']({ author: zelda });

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, zelda);
    assert.deepEqual(post.attrs, { authorId: null });
  });

  (0, _qunit.test)('the child accepts a null parent model', function (assert) {
    var post = this.schema.posts['new']({ author: null });

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, null);
    assert.deepEqual(post.attrs, { authorId: null });
  });

  (0, _qunit.test)('the child accepts a parent model and id', function (assert) {
    var author = this.helper.savedParent();
    var post = this.schema.posts['new']({ author: author, authorId: author.id });

    assert.equal(post.authorId, '1');
    assert.deepEqual(post.author, author);
    assert.deepEqual(post.attrs, { authorId: author.id });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model as empty obj', function (assert) {
    var post = this.schema.posts['new']({});

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, null);
    assert.deepEqual(post.attrs, { authorId: null });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model', function (assert) {
    var post = this.schema.posts['new']();

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, null);
    assert.deepEqual(post.attrs, { authorId: null });
  });
});
define('dummy/tests/integration/orm/belongs-to/1-basic/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/1-basic/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/1-basic/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a belongsTo association can be in six states
    with respect to its association. This helper class
    returns a child (and its association) in these various states.
  
    The return value is an array of the form
  
      [ child, parent ]
  
    where the parent may be undefined.
  */

  var BelongsToHelper = (function () {
    function BelongsToHelper() {
      _classCallCheck(this, BelongsToHelper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend(),
        post: _emberCliMirage.Model.extend({
          author: (0, _emberCliMirage.belongsTo)('user')
        })
      });
    }

    _createClass(BelongsToHelper, [{
      key: 'savedChildNoParent',
      value: function savedChildNoParent() {
        var insertedPost = this.db.posts.insert({ title: 'Lorem' });

        return [this.schema.posts.find(insertedPost.id), undefined];
      }
    }, {
      key: 'savedChildNewParent',
      value: function savedChildNewParent() {
        var insertedPost = this.db.posts.insert({ title: 'Lorem' });
        var post = this.schema.posts.find(insertedPost.id);
        var author = this.schema.users['new']({ name: 'Bob' });

        post.author = author;

        return [post, author];
      }
    }, {
      key: 'savedChildSavedParent',
      value: function savedChildSavedParent() {
        var insertedAuthor = this.db.users.insert({ name: 'Bob' });
        var insertedPost = this.db.posts.insert({ title: 'Lorem', authorId: insertedAuthor.id });
        var post = this.schema.posts.find(insertedPost.id);
        var author = this.schema.users.find(insertedAuthor.id);

        return [post, author];
      }
    }, {
      key: 'newChildNoParent',
      value: function newChildNoParent() {
        return [this.schema.posts['new']({ title: 'Lorem' }), undefined];
      }
    }, {
      key: 'newChildNewParent',
      value: function newChildNewParent() {
        var post = this.schema.posts['new']({ title: 'Lorem' });
        var newAuthor = this.schema.users['new']({ name: 'Bob' });
        post.author = newAuthor;

        return [post, newAuthor];
      }
    }, {
      key: 'newChildSavedParent',
      value: function newChildSavedParent() {
        var insertedAuthor = this.db.users.insert({ name: 'Bob' });
        var post = this.schema.posts['new']({ title: 'Lorem' });
        var savedAuthor = this.schema.users.find(insertedAuthor.id);

        post.author = savedAuthor;

        return [post, savedAuthor];
      }

      // Just a saved unassociated parent.
    }, {
      key: 'savedParent',
      value: function savedParent() {
        var insertedAuthor = this.db.users.insert({ name: 'Bob' });

        return this.schema.users.find(insertedAuthor.id);
      }
    }, {
      key: 'newParent',
      value: function newParent() {
        return this.schema.users['new']({ name: 'Bob' });
      }
    }]);

    return BelongsToHelper;
  })();

  exports['default'] = BelongsToHelper;
  var states = ['savedChildNoParent', 'savedChildNewParent', 'savedChildSavedParent', 'newChildNoParent', 'newChildNewParent', 'newChildSavedParent'];
  exports.states = states;
});
define('dummy/tests/integration/orm/belongs-to/2-named/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/2-named/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/2-named/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/accessor-test', ['exports', 'dummy/tests/integration/orm/belongs-to/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo2Named_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var post = _helper$state2[0];
      var author = _helper$state2[1];

      assert.deepEqual(post.author, author ? author : null, 'the model reference is correct');
      assert.equal(post.authorId, author ? author.id : null, 'the modelId reference is correct');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/2-named/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/2-named/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/association-create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo2Named_helper['default']();
    }
  });

  /*
    The model can create a belongs-to association, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var post = _helper$state2[0];

      var ganon = post.createAuthor({ name: 'Ganon' });

      assert.ok(ganon.id, 'the parent was persisted');
      assert.deepEqual(post.author, ganon);
      assert.equal(post.authorId, ganon.id);
      assert.equal(this.helper.schema.posts.find(post.id).authorId, ganon.id, 'the child was persisted');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/2-named/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/2-named/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/association-new-test', ['exports', 'dummy/tests/integration/orm/belongs-to/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo2Named_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmBelongsTo2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var post = _helper$state2[0];

      var ganon = post.newAuthor({ name: 'Ganon' });

      assert.ok(!ganon.id, 'the parent was not persisted');
      assert.deepEqual(post.author, ganon);
      assert.equal(post.authorId, null);

      post.save();

      assert.ok(ganon.id, 'saving the child persists the parent');
      assert.equal(post.authorId, ganon.id, 'the childs fk was updated');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/2-named/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/2-named/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/association-set-id-test', ['exports', 'dummy/tests/integration/orm/belongs-to/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named | association #setId', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo2Named_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var post = _helper$state2[0];

      var savedAuthor = this.helper.savedParent();

      post.authorId = savedAuthor.id;

      assert.equal(post.authorId, savedAuthor.id);
      assert.deepEqual(post.author, savedAuthor);
    });
  });

  ['savedChildSavedParent', 'newChildSavedParent'].forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var post = _helper$state32[0];

      post.authorId = null;

      assert.equal(post.authorId, null);
      assert.deepEqual(post.author, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/association-set-id-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/2-named/association-set-id-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/2-named/association-set-id-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/association-set-test', ['exports', 'dummy/tests/integration/orm/belongs-to/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo2Named_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var post = _helper$state2[0];

      var savedAuthor = this.helper.savedParent();

      post.author = savedAuthor;

      assert.equal(post.authorId, savedAuthor.id);
      assert.deepEqual(post.author, savedAuthor);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var post = _helper$state32[0];

      var newAuthor = this.helper.newParent();

      post.author = newAuthor;

      assert.equal(post.authorId, null);
      assert.deepEqual(post.author, newAuthor);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a null parent', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var post = _helper$state42[0];

      post.author = null;

      assert.equal(post.authorId, null);
      assert.deepEqual(post.author, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/2-named/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/2-named/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/2-named/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo2Named_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Named | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo2Named_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var author = this.helper.schema.create('user');
    var post = this.helper.schema.create('post', {
      authorId: author.id
    });

    assert.equal(post.authorId, author.id);
    assert.deepEqual(post.author.attrs, author.attrs);
    assert.equal(this.helper.schema.db.users.length, 1);
    assert.deepEqual(this.helper.schema.db.users[0], { id: '1' });
    assert.equal(this.helper.schema.db.posts.length, 1);
    assert.deepEqual(this.helper.schema.db.posts[0], { id: '1', authorId: '1' });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the association itself', function (assert) {
    var author = this.helper.schema.create('user');
    var post = this.helper.schema.create('post', {
      author: author
    });

    assert.equal(post.authorId, author.id);
    assert.deepEqual(post.author.attrs, author.attrs);
    assert.equal(this.helper.schema.db.users.length, 1);
    assert.deepEqual(this.helper.schema.db.users[0], { id: '1' });
    assert.equal(this.helper.schema.db.posts.length, 1);
    assert.deepEqual(this.helper.schema.db.posts[0], { id: '1', authorId: '1' });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('post', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('post', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/2-named/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/2-named/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/delete-test', ['exports', 'dummy/tests/integration/orm/belongs-to/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo2Named_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmBelongsTo2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting the parent updates the child\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var post = _helper$state2[0];
      var user = _helper$state2[1];

      if (user) {
        user.destroy();
        post.reload();
      }

      assert.equal(post.authorId, null);
      assert.deepEqual(post.author, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/2-named/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/2-named/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/instantiating-test', ['exports', 'dummy/tests/integration/orm/belongs-to/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo2Named_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Named | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo2Named_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the child accepts a saved parent id', function (assert) {
    var author = this.helper.savedParent();
    var post = this.schema.posts['new']({ authorId: author.id });

    assert.equal(post.authorId, author.id);
    assert.deepEqual(post.author, author);
    assert.deepEqual(post.attrs, { authorId: author.id });
  });

  (0, _qunit.test)('the child errors if the parent id doesnt exist', function (assert) {
    assert.throws(function () {
      this.schema.posts['new']({ authorId: 2 });
    }, /You're instantiating a post that has a authorId of 2, but that record doesn't exist in the database/);
  });

  (0, _qunit.test)('the child accepts a null parent id', function (assert) {
    var post = this.schema.posts['new']({ authorId: null });

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, null);
    assert.deepEqual(post.attrs, { authorId: null });
  });

  (0, _qunit.test)('the child accepts a saved parent model', function (assert) {
    var author = this.helper.savedParent();
    var post = this.schema.posts['new']({ author: author });

    assert.equal(post.authorId, 1);
    assert.deepEqual(post.author, author);
  });

  (0, _qunit.test)('the child accepts a new parent model', function (assert) {
    var zelda = this.schema.users['new']({ name: 'Zelda' });
    var post = this.schema.posts['new']({ author: zelda });

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, zelda);
    assert.deepEqual(post.attrs, { authorId: null });
  });

  (0, _qunit.test)('the child accepts a null parent model', function (assert) {
    var post = this.schema.posts['new']({ author: null });

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, null);
    assert.deepEqual(post.attrs, { authorId: null });
  });

  (0, _qunit.test)('the child accepts a parent model and id', function (assert) {
    var author = this.helper.savedParent();
    var post = this.schema.posts['new']({ author: author, authorId: author.id });

    assert.equal(post.authorId, '1');
    assert.deepEqual(post.author, author);
    assert.deepEqual(post.attrs, { authorId: author.id });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model as empty obj', function (assert) {
    var post = this.schema.posts['new']({});

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, null);
    assert.deepEqual(post.attrs, { authorId: null });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model', function (assert) {
    var post = this.schema.posts['new']();

    assert.equal(post.authorId, null);
    assert.deepEqual(post.author, null);
    assert.deepEqual(post.attrs, { authorId: null });
  });
});
define('dummy/tests/integration/orm/belongs-to/2-named/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/2-named/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/2-named/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a belongsTo association can be in six states
    with respect to its association. This helper class
    returns a child (and its association) in these various states.
  
    The return value is an array of the form
  
      [ child, parent ]
  
    where the parent may be undefined.
  */

  var BelongsToHelper = (function () {
    function BelongsToHelper() {
      _classCallCheck(this, BelongsToHelper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          user: (0, _emberCliMirage.belongsTo)() // implicit inverse
        })
      });
    }

    _createClass(BelongsToHelper, [{
      key: 'savedChildNoParent',
      value: function savedChildNoParent() {
        var insertedUser = this.db.users.insert({ name: 'Link' });

        return [this.schema.users.find(insertedUser.id), undefined];
      }
    }, {
      key: 'savedChildNewParent',
      value: function savedChildNewParent() {
        var user = this.schema.users.create({ name: 'Link' });
        var friend = this.schema.users['new']({ name: 'Bob' });

        user.user = friend;

        return [user, friend];
      }
    }, {
      key: 'savedChildSavedParent',
      value: function savedChildSavedParent() {
        var insertedFriend = this.db.users.insert({ name: 'Bob' });
        var insertedUser = this.db.users.insert({ name: 'Link', userId: insertedFriend.id });
        this.db.users.update(insertedFriend.id, { userId: insertedUser.id });
        var user = this.schema.users.find(insertedUser.id);
        var friend = this.schema.users.find(insertedFriend.id);

        return [user, friend];
      }
    }, {
      key: 'newChildNoParent',
      value: function newChildNoParent() {
        return [this.schema.users['new']({ name: 'Link' }), undefined];
      }
    }, {
      key: 'newChildNewParent',
      value: function newChildNewParent() {
        var friend = this.schema.users['new']({ name: 'Link' });
        var user = this.schema.users['new']({ name: 'Bob' });
        user.user = friend;

        return [user, friend];
      }
    }, {
      key: 'newChildSavedParent',
      value: function newChildSavedParent() {
        var insertedFriend = this.db.users.insert({ name: 'Bob' });
        var user = this.schema.users['new']({ name: 'Link' });
        var savedFriend = this.schema.users.find(insertedFriend.id);

        user.user = savedFriend;

        return [user, savedFriend];
      }

      // Just a saved unassociated parent.
    }, {
      key: 'savedParent',
      value: function savedParent() {
        var insertedParent = this.db.users.insert({ name: 'Bob' });

        return this.schema.users.find(insertedParent.id);
      }
    }, {
      key: 'newParent',
      value: function newParent() {
        return this.schema.users['new']({ name: 'Bob' });
      }
    }]);

    return BelongsToHelper;
  })();

  exports['default'] = BelongsToHelper;
  var states = ['savedChildNoParent', 'savedChildNewParent', 'savedChildSavedParent', 'newChildNoParent', 'newChildNewParent', 'newChildSavedParent'];
  exports.states = states;
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/3-reflexive/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/3-reflexive/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/accessor-test', ['exports', 'dummy/tests/integration/orm/belongs-to/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Reflexive | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var friend = _helper$state2[1];

      // We use .attrs here because otherwise deepEqual goes on infinite recursive comparison
      if (friend) {
        assert.deepEqual(user.user.attrs, friend.attrs, 'the model reference is correct');
        assert.equal(user.userId, friend.id, 'the modelId reference is correct');
      } else {
        assert.deepEqual(user.user, null, 'the model reference is correct');
        assert.equal(user.userId, null, 'the modelId reference is correct');
      }

      // If there's a friend in this state, make sure the inverse association is correct
      if (friend) {
        assert.deepEqual(friend.user.attrs, user.attrs, 'the inverse model reference is correct');
        assert.equal(friend.userId, user.id, 'the inverse modelId reference is correct');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/3-reflexive/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/3-reflexive/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/association-create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Reflexive | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper['default']();
    }
  });

  /*
    The model can create a belongs-to association, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var originalUser = _helper$state2[1];

      var ganon = user.createUser({ name: 'Ganon' });

      assert.ok(ganon.id, 'the parent was persisted');
      assert.deepEqual(user.user.attrs, ganon.attrs);
      assert.deepEqual(ganon.user.attrs, user.attrs, 'the inverse was set');
      assert.equal(user.userId, ganon.id);
      assert.equal(ganon.userId, user.id, 'the inverse was set');
      assert.equal(this.helper.schema.users.find(user.id).userId, ganon.id, 'the user was persisted');

      if (originalUser) {
        originalUser.reload();
        assert.equal(originalUser.userId, null, 'old inverses were cleared out');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/3-reflexive/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/3-reflexive/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/association-new-test', ['exports', 'dummy/tests/integration/orm/belongs-to/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Reflexive | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var originalUser = _helper$state2[1];

      var ganon = user.newUser({ name: 'Ganon' });

      assert.ok(!ganon.id, 'the parent was not persisted');
      assert.deepEqual(user.user, ganon);
      assert.equal(user.userId, null);
      assert.deepEqual(ganon.user, user, 'the inverse was set');

      user.save();

      assert.ok(ganon.id, 'saving the child persists the parent');
      assert.equal(user.userId, ganon.id, 'the childs fk was updated');

      if (originalUser) {
        originalUser.reload();
        assert.equal(originalUser.userId, null, 'old inverses were cleared out');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/3-reflexive/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/3-reflexive/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/association-set-id-test', ['exports', 'dummy/tests/integration/orm/belongs-to/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Reflexive | association #setId', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var originalUser = _helper$state2[1];

      var friend = this.helper.savedParent();

      user.userId = friend.id;

      assert.equal(user.userId, friend.id);
      assert.deepEqual(user.user.attrs, friend.attrs);

      user.save();
      if (originalUser) {
        originalUser.reload();
        assert.equal(originalUser.userId, null, 'old inverses were cleared out');
      }
    });
  });

  ['savedChildSavedParent', 'newChildSavedParent'].forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var user = _helper$state32[0];
      var originalUser = _helper$state32[1];

      user.userId = null;

      assert.equal(user.userId, null);
      assert.equal(user.user, null);

      user.save();
      if (originalUser) {
        originalUser.reload();
        assert.equal(originalUser.userId, null, 'old inverses were cleared out');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/association-set-id-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/3-reflexive/association-set-id-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/3-reflexive/association-set-id-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/association-set-test', ['exports', 'dummy/tests/integration/orm/belongs-to/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Reflexive | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var originalUser = _helper$state2[1];

      var friend = this.helper.savedParent();

      user.user = friend;

      assert.equal(user.userId, friend.id);
      assert.deepEqual(user.user.attrs, friend.attrs);

      user.save();
      if (originalUser) {
        originalUser.reload();
        assert.equal(originalUser.userId, null, 'old inverses were cleared out');
      }
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var user = _helper$state32[0];
      var originalUser = _helper$state32[1];

      var friend = this.helper.newParent();

      user.user = friend;

      assert.equal(user.userId, null);
      assert.deepEqual(user.user.attrs, friend.attrs);

      user.save();
      if (originalUser) {
        originalUser.reload();
        assert.equal(originalUser.userId, null, 'old inverses were cleared out');
      }
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a null parent', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 2);

      var user = _helper$state42[0];
      var originalUser = _helper$state42[1];

      user.user = null;

      assert.equal(user.userId, null);
      assert.deepEqual(user.user, null);

      user.save();
      if (originalUser) {
        originalUser.reload();
        assert.equal(originalUser.userId, null, 'old inverses were cleared out');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/3-reflexive/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/3-reflexive/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/3-reflexive/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Reflexive | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var friend = schema.create('user');
    var user = schema.create('user', {
      userId: friend.id
    });

    friend.reload();

    assert.equal(user.userId, friend.id);
    assert.deepEqual(user.user.attrs, friend.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', userId: '2' });
    assert.deepEqual(schema.db.users[1], { id: '2', userId: '1' });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the association itself', function (assert) {
    var schema = this.helper.schema;

    var friend = schema.create('user');
    var user = schema.create('user', {
      user: friend
    });

    assert.equal(user.userId, friend.id);
    assert.deepEqual(user.user.attrs, friend.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', userId: '2' });
    assert.deepEqual(schema.db.users[1], { id: '2', userId: '1' });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('user', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/3-reflexive/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/3-reflexive/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/delete-test', ['exports', 'dummy/tests/integration/orm/belongs-to/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Reflexive | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting the parent updates the child\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var targetUser = _helper$state2[1];

      if (targetUser) {
        targetUser.destroy();
        user.reload();
      }

      assert.equal(user.userId, null);
      assert.deepEqual(user.user, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/3-reflexive/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/3-reflexive/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/instantiating-test', ['exports', 'dummy/tests/integration/orm/belongs-to/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Reflexive | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo3Reflexive_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the child accepts a saved parent id', function (assert) {
    var friend = this.helper.savedParent();
    var user = this.schema.users['new']({ userId: friend.id });

    assert.equal(user.userId, friend.id);
    assert.deepEqual(user.user.attrs, friend.attrs);
    assert.deepEqual(user.attrs, { userId: friend.id });
  });

  (0, _qunit.test)('the child errors if the parent id doesnt exist', function (assert) {
    assert.throws(function () {
      this.schema.users['new']({ userId: 2 });
    }, /You're instantiating a user that has a userId of 2, but that record doesn't exist in the database/);
  });

  (0, _qunit.test)('the child accepts a null parent id', function (assert) {
    var user = this.schema.users['new']({ userId: null });

    assert.equal(user.userId, null);
    assert.equal(user.user, null);
    assert.deepEqual(user.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts a saved parent model', function (assert) {
    var friend = this.helper.savedParent();
    var user = this.schema.users['new']({ user: friend });

    assert.equal(user.userId, 1);
    assert.deepEqual(user.user.attrs, friend.attrs);
    assert.deepEqual(user.attrs, { userId: null }); // this would update when saved
  });

  (0, _qunit.test)('the child accepts a new parent model', function (assert) {
    var zelda = this.schema.users['new']({ name: 'Zelda' });
    var user = this.schema.users['new']({ user: zelda });

    assert.equal(user.userId, null);
    assert.deepEqual(user.user, zelda);
    assert.deepEqual(user.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts a null parent model', function (assert) {
    var user = this.schema.users['new']({ user: null });

    assert.equal(user.userId, null);
    assert.deepEqual(user.user, null);
    assert.deepEqual(user.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts a parent model and id', function (assert) {
    var friend = this.helper.savedParent();
    var user = this.schema.users['new']({ user: friend, userId: friend.id });

    assert.equal(user.userId, '1');
    assert.deepEqual(user.user, friend);
    assert.deepEqual(user.attrs, { userId: friend.id });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model as empty obj', function (assert) {
    var user = this.schema.users['new']({});

    assert.equal(user.userId, null);
    assert.deepEqual(user.user, null);
    assert.deepEqual(user.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model', function (assert) {
    var user = this.schema.users['new']();

    assert.equal(user.userId, null);
    assert.deepEqual(user.user, null);
    assert.deepEqual(user.attrs, { userId: null });
  });
});
define('dummy/tests/integration/orm/belongs-to/3-reflexive/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/3-reflexive/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/3-reflexive/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a belongsTo association can be in six states
    with respect to its association. This helper class
    returns a child (and its association) in these various states.
  
    The return value is an array of the form
  
      [ child, parent ]
  
    where the parent may be undefined.
  */

  var BelongsToHelper = (function () {
    function BelongsToHelper() {
      _classCallCheck(this, BelongsToHelper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          bestFriend: (0, _emberCliMirage.belongsTo)('user') // implicit inverse
        })
      });
    }

    _createClass(BelongsToHelper, [{
      key: 'savedChildNoParent',
      value: function savedChildNoParent() {
        var insertedUser = this.db.users.insert({ name: 'Link' });

        return [this.schema.users.find(insertedUser.id), undefined];
      }
    }, {
      key: 'savedChildNewParent',
      value: function savedChildNewParent() {
        var user = this.schema.users.create({ name: 'Link' });
        var friend = this.schema.users['new']({ name: 'Bob' });

        user.bestFriend = friend;

        return [user, friend];
      }
    }, {
      key: 'savedChildSavedParent',
      value: function savedChildSavedParent() {
        var insertedFriend = this.db.users.insert({ name: 'Bob' });
        var insertedUser = this.db.users.insert({ name: 'Link', bestFriendId: insertedFriend.id });
        this.db.users.update(insertedFriend.id, { bestFriendId: insertedUser.id });
        var user = this.schema.users.find(insertedUser.id);
        var friend = this.schema.users.find(insertedFriend.id);

        return [user, friend];
      }
    }, {
      key: 'newChildNoParent',
      value: function newChildNoParent() {
        return [this.schema.users['new']({ name: 'Link' }), undefined];
      }
    }, {
      key: 'newChildNewParent',
      value: function newChildNewParent() {
        var friend = this.schema.users['new']({ name: 'Link' });
        var user = this.schema.users['new']({ name: 'Bob' });
        user.bestFriend = friend;

        return [user, friend];
      }
    }, {
      key: 'newChildSavedParent',
      value: function newChildSavedParent() {
        var insertedFriend = this.db.users.insert({ name: 'Bob' });
        var user = this.schema.users['new']({ name: 'Link' });
        var savedFriend = this.schema.users.find(insertedFriend.id);

        user.bestFriend = savedFriend;

        return [user, savedFriend];
      }

      // Just a saved unassociated parent.
    }, {
      key: 'savedParent',
      value: function savedParent() {
        var insertedParent = this.db.users.insert({ name: 'Bob' });

        return this.schema.users.find(insertedParent.id);
      }
    }, {
      key: 'newParent',
      value: function newParent() {
        return this.schema.users['new']({ name: 'Bob' });
      }
    }]);

    return BelongsToHelper;
  })();

  exports['default'] = BelongsToHelper;
  var states = ['savedChildNoParent', 'savedChildNewParent', 'savedChildSavedParent', 'newChildNoParent', 'newChildNewParent', 'newChildSavedParent'];
  exports.states = states;
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/4-named-reflexive/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/4-named-reflexive/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/accessor-test', ['exports', 'dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var friend = _helper$state2[1];

      // We use .attrs here because otherwise deepEqual goes on infinite recursive comparison
      if (friend) {
        assert.deepEqual(user.bestFriend.attrs, friend.attrs, 'the model reference is correct');
        assert.equal(user.bestFriendId, friend.id, 'the modelId reference is correct');
      } else {
        assert.deepEqual(user.bestFriend, null, 'the model reference is correct');
        assert.equal(user.bestFriendId, null, 'the modelId reference is correct');
      }

      // If there's a friend in this state, make sure the inverse association is correct
      if (friend) {
        assert.deepEqual(friend.bestFriend.attrs, user.attrs, 'the inverse model reference is correct');
        assert.equal(friend.bestFriendId, user.id, 'the inverse modelId reference is correct');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/4-named-reflexive/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/4-named-reflexive/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/association-create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper['default']();
    }
  });

  /*
    The model can create a belongs-to association, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var ganon = user.createBestFriend({ name: 'Ganon' });

      assert.ok(ganon.id, 'the parent was persisted');
      assert.deepEqual(user.bestFriend.attrs, ganon.attrs);
      assert.equal(user.bestFriendId, ganon.id);
      assert.equal(this.helper.schema.users.find(user.id).bestFriendId, ganon.id, 'the user was persisted');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/4-named-reflexive/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/4-named-reflexive/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/association-new-test', ['exports', 'dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var ganon = user.newBestFriend({ name: 'Ganon' });

      assert.ok(!ganon.id, 'the parent was not persisted');
      assert.deepEqual(user.bestFriend, ganon);
      assert.equal(user.bestFriendId, null);

      user.save();

      assert.ok(ganon.id, 'saving the child persists the parent');
      assert.equal(user.bestFriendId, ganon.id, 'the childs fk was updated');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/4-named-reflexive/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/4-named-reflexive/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/association-set-id-test', ['exports', 'dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive | association #setId', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var friend = this.helper.savedParent();

      user.bestFriendId = friend.id;

      assert.equal(user.bestFriendId, friend.id);
      assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    });
  });

  ['savedChildSavedParent', 'newChildSavedParent'].forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var user = _helper$state32[0];

      user.bestFriendId = null;

      assert.equal(user.bestFriendId, null);
      assert.equal(user.bestFriend, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/association-set-id-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/4-named-reflexive/association-set-id-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/4-named-reflexive/association-set-id-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/association-set-test', ['exports', 'dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var friend = this.helper.savedParent();

      user.bestFriend = friend;

      assert.equal(user.bestFriendId, friend.id);
      assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var user = _helper$state32[0];

      var friend = this.helper.newParent();

      user.bestFriend = friend;

      assert.equal(user.bestFriendId, null);
      assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a null parent', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var user = _helper$state42[0];

      user.bestFriend = null;

      assert.equal(user.bestFriendId, null);
      assert.deepEqual(user.bestFriend, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/4-named-reflexive/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/4-named-reflexive/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var friend = schema.create('user');
    var user = schema.create('user', {
      bestFriendId: friend.id
    });

    friend.reload();

    assert.equal(user.bestFriendId, friend.id);
    assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', bestFriendId: '2' });
    assert.deepEqual(schema.db.users[1], { id: '2', bestFriendId: '1' });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the association itself', function (assert) {
    var schema = this.helper.schema;

    var friend = schema.create('user');
    var user = schema.create('user', {
      bestFriend: friend
    });

    assert.equal(user.bestFriendId, friend.id);
    assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', bestFriendId: '2' });
    assert.deepEqual(schema.db.users[1], { id: '2', bestFriendId: '1' });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('user', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/4-named-reflexive/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/4-named-reflexive/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/delete-test', ['exports', 'dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting the parent updates the child\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var bestFriend = _helper$state2[1];

      if (bestFriend) {
        bestFriend.destroy();
        user.reload();
      }

      assert.equal(user.bestFriendId, null);
      assert.deepEqual(user.bestFriend, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/4-named-reflexive/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/4-named-reflexive/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/instantiating-test', ['exports', 'dummy/tests/integration/orm/belongs-to/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo4NamedReflexive_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the child accepts a saved parent id', function (assert) {
    var friend = this.helper.savedParent();
    var user = this.schema.users['new']({ bestFriendId: friend.id });

    assert.equal(user.bestFriendId, friend.id);
    assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    assert.deepEqual(user.attrs, { bestFriendId: friend.id });
  });

  (0, _qunit.test)('the child errors if the parent id doesnt exist', function (assert) {
    assert.throws(function () {
      this.schema.users['new']({ bestFriendId: 2 });
    }, /You're instantiating a user that has a bestFriendId of 2, but that record doesn't exist in the database/);
  });

  (0, _qunit.test)('the child accepts a null parent id', function (assert) {
    var user = this.schema.users['new']({ bestFriendId: null });

    assert.equal(user.bestFriendId, null);
    assert.equal(user.bestFriend, null);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });

  (0, _qunit.test)('the child accepts a saved parent model', function (assert) {
    var friend = this.helper.savedParent();
    var user = this.schema.users['new']({ bestFriend: friend });

    assert.equal(user.bestFriendId, 1);
    assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    assert.deepEqual(user.attrs, { bestFriendId: null }); // this would update when saved
  });

  (0, _qunit.test)('the child accepts a new parent model', function (assert) {
    var zelda = this.schema.users['new']({ name: 'Zelda' });
    var user = this.schema.users['new']({ bestFriend: zelda });

    assert.equal(user.bestFriendId, null);
    assert.deepEqual(user.bestFriend, zelda);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });

  (0, _qunit.test)('the child accepts a null parent model', function (assert) {
    var user = this.schema.users['new']({ bestFriend: null });

    assert.equal(user.bestFriendId, null);
    assert.deepEqual(user.bestFriend, null);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });

  (0, _qunit.test)('the child accepts a parent model and id', function (assert) {
    var friend = this.helper.savedParent();
    var user = this.schema.users['new']({ bestFriend: friend, bestFriendId: friend.id });

    assert.equal(user.bestFriendId, '1');
    assert.deepEqual(user.bestFriend, friend);
    assert.deepEqual(user.attrs, { bestFriendId: friend.id });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model as empty obj', function (assert) {
    var user = this.schema.users['new']({});

    assert.equal(user.bestFriendId, null);
    assert.deepEqual(user.bestFriend, null);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model', function (assert) {
    var user = this.schema.users['new']();

    assert.equal(user.bestFriendId, null);
    assert.deepEqual(user.bestFriend, null);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });
});
define('dummy/tests/integration/orm/belongs-to/4-named-reflexive/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/4-named-reflexive/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/4-named-reflexive/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a belongsTo association can be in six states
    with respect to its association. This helper class
    returns a child (and its association) in these various states.
  
    The return value is an array of the form
  
      [ child, parent ]
  
    where the parent may be undefined.
  */

  var BelongsToHelper = (function () {
    function BelongsToHelper() {
      _classCallCheck(this, BelongsToHelper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          bestFriend: (0, _emberCliMirage.belongsTo)('user', { inverse: 'bestFriend' })
        })
      });
    }

    _createClass(BelongsToHelper, [{
      key: 'savedChildNoParent',
      value: function savedChildNoParent() {
        var insertedUser = this.db.users.insert({ name: 'Link' });

        return [this.schema.users.find(insertedUser.id), undefined];
      }
    }, {
      key: 'savedChildNewParent',
      value: function savedChildNewParent() {
        var user = this.schema.users.create({ name: 'Link' });
        var friend = this.schema.users['new']({ name: 'Bob' });

        user.bestFriend = friend;

        return [user, friend];
      }
    }, {
      key: 'savedChildSavedParent',
      value: function savedChildSavedParent() {
        var insertedFriend = this.db.users.insert({ name: 'Bob' });
        var insertedUser = this.db.users.insert({ name: 'Link', bestFriendId: insertedFriend.id });
        this.db.users.update(insertedFriend.id, { bestFriendId: insertedUser.id });
        var user = this.schema.users.find(insertedUser.id);
        var friend = this.schema.users.find(insertedFriend.id);

        return [user, friend];
      }
    }, {
      key: 'newChildNoParent',
      value: function newChildNoParent() {
        return [this.schema.users['new']({ name: 'Link' }), undefined];
      }
    }, {
      key: 'newChildNewParent',
      value: function newChildNewParent() {
        var friend = this.schema.users['new']({ name: 'Link' });
        var user = this.schema.users['new']({ name: 'Bob' });
        user.bestFriend = friend;

        return [user, friend];
      }
    }, {
      key: 'newChildSavedParent',
      value: function newChildSavedParent() {
        var insertedFriend = this.db.users.insert({ name: 'Bob' });
        var user = this.schema.users['new']({ name: 'Link' });
        var savedFriend = this.schema.users.find(insertedFriend.id);

        user.bestFriend = savedFriend;

        return [user, savedFriend];
      }

      // Just a saved unassociated parent.
    }, {
      key: 'savedParent',
      value: function savedParent() {
        var insertedParent = this.db.users.insert({ name: 'Bob' });

        return this.schema.users.find(insertedParent.id);
      }
    }, {
      key: 'newParent',
      value: function newParent() {
        return this.schema.users['new']({ name: 'Bob' });
      }
    }]);

    return BelongsToHelper;
  })();

  exports['default'] = BelongsToHelper;
  var states = ['savedChildNoParent', 'savedChildNewParent', 'savedChildSavedParent', 'newChildNoParent', 'newChildNewParent', 'newChildSavedParent'];
  exports.states = states;
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/accessor-test', ['exports', 'dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive Explicit Inverse | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var friend = _helper$state2[1];

      // We use .attrs here because otherwise deepEqual goes on infinite recursive comparison
      if (friend) {
        assert.deepEqual(user.bestFriend.attrs, friend.attrs, 'the model reference is correct');
        assert.equal(user.bestFriendId, friend.id, 'the modelId reference is correct');
      } else {
        assert.deepEqual(user.bestFriend, null, 'the model reference is correct');
        assert.equal(user.bestFriendId, null, 'the modelId reference is correct');
      }

      // If there's a friend in this state, make sure the inverse association is correct
      if (friend) {
        assert.deepEqual(friend.bestFriend.attrs, user.attrs, 'the inverse model reference is correct');
        assert.equal(friend.bestFriendId, user.id, 'the inverse modelId reference is correct');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/5-named-reflexive-explicit-inverse/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/5-named-reflexive-explicit-inverse/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive Explicit Inverse | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  /*
    The model can create a belongs-to association, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var ganon = user.createBestFriend({ name: 'Ganon' });

      assert.ok(ganon.id, 'the parent was persisted');
      assert.deepEqual(user.bestFriend.attrs, ganon.attrs);
      assert.equal(user.bestFriendId, ganon.id);
      assert.equal(this.helper.schema.users.find(user.id).bestFriendId, ganon.id, 'the user was persisted');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-new-test', ['exports', 'dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive Explicit Inverse | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var ganon = user.newBestFriend({ name: 'Ganon' });

      assert.ok(!ganon.id, 'the parent was not persisted');
      assert.deepEqual(user.bestFriend, ganon);
      assert.equal(user.bestFriendId, null);

      user.save();

      assert.ok(ganon.id, 'saving the child persists the parent');
      assert.equal(user.bestFriendId, ganon.id, 'the childs fk was updated');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-set-id-test', ['exports', 'dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive Explicit Inverse | association #setId', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var friend = this.helper.savedParent();

      user.bestFriendId = friend.id;

      assert.equal(user.bestFriendId, friend.id);
      assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    });
  });

  ['savedChildSavedParent', 'newChildSavedParent'].forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var user = _helper$state32[0];

      user.bestFriendId = null;

      assert.equal(user.bestFriendId, null);
      assert.equal(user.bestFriend, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-set-id-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-set-id-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-set-id-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-set-test', ['exports', 'dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive Explicit Inverse | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var friend = this.helper.savedParent();

      user.bestFriend = friend;

      assert.equal(user.bestFriendId, friend.id);
      assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var user = _helper$state32[0];

      var friend = this.helper.newParent();

      user.bestFriend = friend;

      assert.equal(user.bestFriendId, null);
      assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a null parent', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var user = _helper$state42[0];

      user.bestFriend = null;

      assert.equal(user.bestFriendId, null);
      assert.deepEqual(user.bestFriend, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/5-named-reflexive-explicit-inverse/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive Explicit Inverse | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var friend = schema.create('user');
    var user = schema.create('user', {
      bestFriendId: friend.id
    });

    friend.reload();

    assert.equal(user.bestFriendId, friend.id);
    assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', bestFriendId: '2' });
    assert.deepEqual(schema.db.users[1], { id: '2', bestFriendId: '1' });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the association itself', function (assert) {
    var schema = this.helper.schema;

    var friend = schema.create('user');
    var user = schema.create('user', {
      bestFriend: friend
    });

    assert.equal(user.bestFriendId, friend.id);
    assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', bestFriendId: '2' });
    assert.deepEqual(schema.db.users[1], { id: '2', bestFriendId: '1' });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('user', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/5-named-reflexive-explicit-inverse/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/5-named-reflexive-explicit-inverse/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/delete-test', ['exports', 'dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive Explicit Inverse | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting the parent updates the child\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var bestFriend = _helper$state2[1];

      if (bestFriend) {
        bestFriend.destroy();
        user.reload();
      }

      assert.equal(user.bestFriendId, null);
      assert.deepEqual(user.bestFriend, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/5-named-reflexive-explicit-inverse/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/5-named-reflexive-explicit-inverse/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/instantiating-test', ['exports', 'dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Named Reflexive Explicit Inverse | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo5NamedReflexiveExplicitInverse_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the child accepts a saved parent id', function (assert) {
    var friend = this.helper.savedParent();
    var user = this.schema.users['new']({ bestFriendId: friend.id });

    assert.equal(user.bestFriendId, friend.id);
    assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    assert.deepEqual(user.attrs, { bestFriendId: friend.id });
  });

  (0, _qunit.test)('the child errors if the parent id doesnt exist', function (assert) {
    assert.throws(function () {
      this.schema.users['new']({ bestFriendId: 2 });
    }, /You're instantiating a user that has a bestFriendId of 2, but that record doesn't exist in the database/);
  });

  (0, _qunit.test)('the child accepts a null parent id', function (assert) {
    var user = this.schema.users['new']({ bestFriendId: null });

    assert.equal(user.bestFriendId, null);
    assert.equal(user.bestFriend, null);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });

  (0, _qunit.test)('the child accepts a saved parent model', function (assert) {
    var friend = this.helper.savedParent();
    var user = this.schema.users['new']({ bestFriend: friend });

    assert.equal(user.bestFriendId, 1);
    assert.deepEqual(user.bestFriend.attrs, friend.attrs);
    assert.deepEqual(user.attrs, { bestFriendId: null }); // this would update when saved
  });

  (0, _qunit.test)('the child accepts a new parent model', function (assert) {
    var zelda = this.schema.users['new']({ name: 'Zelda' });
    var user = this.schema.users['new']({ bestFriend: zelda });

    assert.equal(user.bestFriendId, null);
    assert.deepEqual(user.bestFriend, zelda);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });

  (0, _qunit.test)('the child accepts a null parent model', function (assert) {
    var user = this.schema.users['new']({ bestFriend: null });

    assert.equal(user.bestFriendId, null);
    assert.deepEqual(user.bestFriend, null);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });

  (0, _qunit.test)('the child accepts a parent model and id', function (assert) {
    var friend = this.helper.savedParent();
    var user = this.schema.users['new']({ bestFriend: friend, bestFriendId: friend.id });

    assert.equal(user.bestFriendId, '1');
    assert.deepEqual(user.bestFriend, friend);
    assert.deepEqual(user.attrs, { bestFriendId: friend.id });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model as empty obj', function (assert) {
    var user = this.schema.users['new']({});

    assert.equal(user.bestFriendId, null);
    assert.deepEqual(user.bestFriend, null);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model', function (assert) {
    var user = this.schema.users['new']();

    assert.equal(user.bestFriendId, null);
    assert.deepEqual(user.bestFriend, null);
    assert.deepEqual(user.attrs, { bestFriendId: null });
  });
});
define('dummy/tests/integration/orm/belongs-to/5-named-reflexive-explicit-inverse/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/5-named-reflexive-explicit-inverse/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/5-named-reflexive-explicit-inverse/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a belongsTo association can be in six states
    with respect to its association. This helper class
    returns a child (and its association) in these various states.
  
    The return value is an array of the form
  
      [ child, parent ]
  
    where the parent may be undefined.
  */

  var BelongsToHelper = (function () {
    function BelongsToHelper() {
      _classCallCheck(this, BelongsToHelper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          user: (0, _emberCliMirage.belongsTo)('user', { inverse: null })
        })
      });
    }

    _createClass(BelongsToHelper, [{
      key: 'savedChildNoParent',
      value: function savedChildNoParent() {
        var insertedUser = this.db.users.insert({ name: 'Link' });

        return [this.schema.users.find(insertedUser.id), undefined];
      }
    }, {
      key: 'savedChildNewParent',
      value: function savedChildNewParent() {
        var child = this.schema.users.create({ name: 'Link' });
        var parent = this.schema.users['new']({ name: 'Bob' });

        child.user = parent;

        return [child, parent];
      }
    }, {
      key: 'savedChildSavedParent',
      value: function savedChildSavedParent() {
        var insertedParent = this.db.users.insert({ name: 'Bob' });
        var insertedChild = this.db.users.insert({ name: 'Link', userId: insertedParent.id });
        var child = this.schema.users.find(insertedChild.id);
        var parent = this.schema.users.find(insertedParent.id);

        return [child, parent];
      }
    }, {
      key: 'newChildNoParent',
      value: function newChildNoParent() {
        return [this.schema.users['new']({ name: 'Link' }), undefined];
      }
    }, {
      key: 'newChildNewParent',
      value: function newChildNewParent() {
        var parent = this.schema.users['new']({ name: 'Link' });
        var child = this.schema.users['new']({ name: 'Bob' });
        child.user = parent;

        return [child, parent];
      }
    }, {
      key: 'newChildSavedParent',
      value: function newChildSavedParent() {
        var insertedParent = this.db.users.insert({ name: 'Bob' });
        var child = this.schema.users['new']({ name: 'Link' });
        var savedParent = this.schema.users.find(insertedParent.id);

        child.user = savedParent;

        return [child, savedParent];
      }

      // Just a saved unassociated parent.
    }, {
      key: 'savedParent',
      value: function savedParent() {
        var insertedParent = this.db.users.insert({ name: 'Bob' });

        return this.schema.users.find(insertedParent.id);
      }
    }, {
      key: 'newParent',
      value: function newParent() {
        return this.schema.users['new']({ name: 'Bob' });
      }
    }]);

    return BelongsToHelper;
  })();

  exports['default'] = BelongsToHelper;
  var states = ['savedChildNoParent', 'savedChildNewParent', 'savedChildSavedParent', 'newChildNoParent', 'newChildNewParent', 'newChildSavedParent'];
  exports.states = states;
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/6-one-way-reflexive/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/6-one-way-reflexive/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/accessor-test', ['exports', 'dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One-Way Reflexive | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var parent = _helper$state2[1];

      // We use .attrs here to avoid infinite recursion
      if (parent) {
        assert.deepEqual(user.user.attrs, parent.attrs, 'the model reference is correct');
        assert.equal(user.userId, parent.id, 'the modelId reference is correct');
      } else {
        assert.deepEqual(user.user, null, 'the model reference is correct');
        assert.equal(user.userId, null, 'the modelId reference is correct');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/6-one-way-reflexive/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/6-one-way-reflexive/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/association-create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One-Way Reflexive | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper['default']();
    }
  });

  /*
    The model can create a belongs-to association, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var child = _helper$state2[0];

      var ganon = child.createUser({ name: 'Ganon' });

      assert.ok(ganon.id, 'the parent was persisted');
      assert.deepEqual(child.user.attrs, ganon.attrs);
      assert.equal(child.userId, ganon.id);
      assert.equal(this.helper.schema.users.find(child.id).userId, ganon.id, 'the child was persisted');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/6-one-way-reflexive/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/6-one-way-reflexive/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/association-new-test', ['exports', 'dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One-Way Reflexive | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var child = _helper$state2[0];

      var ganon = child.newUser({ name: 'Ganon' });

      assert.ok(!ganon.id, 'the parent was not persisted');
      assert.deepEqual(child.user, ganon);
      assert.equal(child.userId, null);

      child.save();

      assert.ok(ganon.id, 'saving the child persists the parent');
      assert.equal(child.userId, ganon.id, 'the childs fk was updated');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/6-one-way-reflexive/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/6-one-way-reflexive/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/association-set-id-test', ['exports', 'dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One-Way Reflexive | association #setId', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var child = _helper$state2[0];

      var savedParent = this.helper.savedParent();

      child.userId = savedParent.id;

      assert.equal(child.userId, savedParent.id);
      assert.deepEqual(child.user.attrs, savedParent.attrs);
    });
  });

  ['savedChildSavedParent', 'newChildSavedParent'].forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var child = _helper$state32[0];

      child.userId = null;

      assert.equal(child.userId, null);
      assert.deepEqual(child.user, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/association-set-id-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/6-one-way-reflexive/association-set-id-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/6-one-way-reflexive/association-set-id-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/association-set-test', ['exports', 'dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One-Way Reflexive | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var child = _helper$state2[0];

      var savedParent = this.helper.savedParent();

      child.user = savedParent;

      assert.equal(child.userId, savedParent.id);
      assert.deepEqual(child.user.attrs, savedParent.attrs);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var child = _helper$state32[0];

      var newParent = this.helper.newParent();

      child.user = newParent;

      assert.equal(child.userId, null);
      assert.deepEqual(child.user, newParent);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a null parent', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var child = _helper$state42[0];

      child.user = null;

      assert.equal(child.userId, null);
      assert.deepEqual(child.user, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/6-one-way-reflexive/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/6-one-way-reflexive/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | One-Way Reflexive | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var parent = schema.create('user');
    var child = schema.create('user', {
      userId: parent.id
    });

    assert.equal(child.userId, parent.id);
    assert.deepEqual(child.user.attrs, parent.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', userId: null });
    assert.deepEqual(schema.db.users[1], { id: '2', userId: '1' });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the association itself', function (assert) {
    var schema = this.helper.schema;

    var parent = schema.create('user');
    var child = schema.create('user', {
      user: parent
    });

    assert.equal(child.userId, parent.id);
    assert.deepEqual(child.user.attrs, parent.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', userId: null });
    assert.deepEqual(schema.db.users[1], { id: '2', userId: '1' });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('user', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/6-one-way-reflexive/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/6-one-way-reflexive/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/delete-test', ['exports', 'dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One-Way Reflexive | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting the parent updates the child\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var targetUser = _helper$state2[1];

      if (targetUser) {
        targetUser.destroy();
        user.reload();
      }

      assert.equal(user.userId, null);
      assert.deepEqual(user.user, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/6-one-way-reflexive/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/6-one-way-reflexive/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/instantiating-test', ['exports', 'dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | One-Way Reflexive | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo6OneWayReflexive_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the child accepts a saved parent id', function (assert) {
    var parent = this.helper.savedParent();
    var child = this.schema.users['new']({ userId: parent.id });

    assert.equal(child.userId, parent.id);
    assert.deepEqual(child.user.attrs, parent.attrs);
    assert.deepEqual(child.attrs, { userId: parent.id });
  });

  (0, _qunit.test)('the child errors if the parent id doesnt exist', function (assert) {
    assert.throws(function () {
      this.schema.users['new']({ userId: 2 });
    }, /You're instantiating a user that has a userId of 2, but that record doesn't exist in the database/);
  });

  (0, _qunit.test)('the child accepts a null parent id', function (assert) {
    var child = this.schema.users['new']({ userId: null });

    assert.equal(child.userId, null);
    assert.deepEqual(child.user, null);
    assert.deepEqual(child.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts a saved parent model', function (assert) {
    var parent = this.helper.savedParent();
    var child = this.schema.users['new']({ user: parent });

    assert.equal(child.userId, 1);
    assert.deepEqual(child.user.attrs, parent.attrs);
  });

  (0, _qunit.test)('the child accepts a new parent model', function (assert) {
    var zelda = this.schema.users['new']({ name: 'Zelda' });
    var child = this.schema.users['new']({ user: zelda });

    assert.equal(child.userId, null);
    assert.deepEqual(child.user, zelda);
    assert.deepEqual(child.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts a null parent model', function (assert) {
    var child = this.schema.users['new']({ user: null });

    assert.equal(child.userId, null);
    assert.deepEqual(child.user, null);
    assert.deepEqual(child.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts a parent model and id', function (assert) {
    var parent = this.helper.savedParent();
    var child = this.schema.users['new']({ user: parent, userId: parent.id });

    assert.equal(child.userId, '1');
    assert.deepEqual(child.user.attrs, parent.attrs);
    assert.deepEqual(child.attrs, { userId: parent.id });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model as empty obj', function (assert) {
    var child = this.schema.users['new']({});

    assert.equal(child.userId, null);
    assert.deepEqual(child.user, null);
    assert.deepEqual(child.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model', function (assert) {
    var child = this.schema.users['new']();

    assert.equal(child.userId, null);
    assert.deepEqual(child.user, null);
    assert.deepEqual(child.attrs, { userId: null });
  });
});
define('dummy/tests/integration/orm/belongs-to/6-one-way-reflexive/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/6-one-way-reflexive/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/6-one-way-reflexive/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a belongsTo association can be in six states
    with respect to its association. This helper class
    returns a child (and its association) in these various states.
  
    The return value is an array of the form
  
      [ child, parent ]
  
    where the parent may be undefined.
  */

  var BelongsToHelper = (function () {
    function BelongsToHelper() {
      _classCallCheck(this, BelongsToHelper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          parent: (0, _emberCliMirage.belongsTo)('user', { inverse: null })
        })
      });
    }

    _createClass(BelongsToHelper, [{
      key: 'savedChildNoParent',
      value: function savedChildNoParent() {
        var insertedUser = this.db.users.insert({ name: 'Link' });

        return [this.schema.users.find(insertedUser.id), undefined];
      }
    }, {
      key: 'savedChildNewParent',
      value: function savedChildNewParent() {
        var child = this.schema.users.create({ name: 'Link' });
        var parent = this.schema.users['new']({ name: 'Bob' });

        child.parent = parent;

        return [child, parent];
      }
    }, {
      key: 'savedChildSavedParent',
      value: function savedChildSavedParent() {
        var insertedParent = this.db.users.insert({ name: 'Bob' });
        var insertedChild = this.db.users.insert({ name: 'Link', parentId: insertedParent.id });
        var child = this.schema.users.find(insertedChild.id);
        var parent = this.schema.users.find(insertedParent.id);

        return [child, parent];
      }
    }, {
      key: 'newChildNoParent',
      value: function newChildNoParent() {
        return [this.schema.users['new']({ name: 'Link' }), undefined];
      }
    }, {
      key: 'newChildNewParent',
      value: function newChildNewParent() {
        var parent = this.schema.users['new']({ name: 'Link' });
        var child = this.schema.users['new']({ name: 'Bob' });
        child.parent = parent;

        return [child, parent];
      }
    }, {
      key: 'newChildSavedParent',
      value: function newChildSavedParent() {
        var insertedParent = this.db.users.insert({ name: 'Bob' });
        var child = this.schema.users['new']({ name: 'Link' });
        var savedParent = this.schema.users.find(insertedParent.id);

        child.parent = savedParent;

        return [child, savedParent];
      }

      // Just a saved unassociated parent.
    }, {
      key: 'savedParent',
      value: function savedParent() {
        var insertedParent = this.db.users.insert({ name: 'Bob' });

        return this.schema.users.find(insertedParent.id);
      }
    }, {
      key: 'newParent',
      value: function newParent() {
        return this.schema.users['new']({ name: 'Bob' });
      }
    }]);

    return BelongsToHelper;
  })();

  exports['default'] = BelongsToHelper;
  var states = ['savedChildNoParent', 'savedChildNewParent', 'savedChildSavedParent', 'newChildNoParent', 'newChildNewParent', 'newChildSavedParent'];
  exports.states = states;
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/7-named-one-way-reflexive/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/7-named-one-way-reflexive/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/accessor-test', ['exports', 'dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named One-Way Reflexive | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var parent = _helper$state2[1];

      // We use .attrs here to avoid infinite recursion
      if (parent) {
        assert.deepEqual(user.parent.attrs, parent.attrs, 'the model reference is correct');
        assert.equal(user.parentId, parent.id, 'the modelId reference is correct');
      } else {
        assert.deepEqual(user.parent, null, 'the model reference is correct');
        assert.equal(user.parentId, null, 'the modelId reference is correct');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/7-named-one-way-reflexive/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/7-named-one-way-reflexive/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/association-create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named One-Way Reflexive | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper['default']();
    }
  });

  /*
    The model can create a belongs-to association, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var child = _helper$state2[0];

      var ganon = child.createParent({ name: 'Ganon' });

      assert.ok(ganon.id, 'the parent was persisted');
      assert.deepEqual(child.parent.attrs, ganon.attrs);
      assert.equal(child.parentId, ganon.id);
      assert.equal(this.helper.schema.users.find(child.id).parentId, ganon.id, 'the child was persisted');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/7-named-one-way-reflexive/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/7-named-one-way-reflexive/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/association-new-test', ['exports', 'dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named One-Way Reflexive | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var child = _helper$state2[0];

      var ganon = child.newParent({ name: 'Ganon' });

      assert.ok(!ganon.id, 'the parent was not persisted');
      assert.deepEqual(child.parent, ganon);
      assert.equal(child.parentId, null);

      child.save();

      assert.ok(ganon.id, 'saving the child persists the parent');
      assert.equal(child.parentId, ganon.id, 'the childs fk was updated');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/7-named-one-way-reflexive/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/7-named-one-way-reflexive/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/association-set-id-test', ['exports', 'dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named One-Way Reflexive | association #setId', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var child = _helper$state2[0];

      var savedParent = this.helper.savedParent();

      child.parentId = savedParent.id;

      assert.equal(child.parentId, savedParent.id);
      assert.deepEqual(child.parent.attrs, savedParent.attrs);
    });
  });

  ['savedChildSavedParent', 'newChildSavedParent'].forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var child = _helper$state32[0];

      child.parentId = null;

      assert.equal(child.parentId, null);
      assert.deepEqual(child.parent, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/association-set-id-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/7-named-one-way-reflexive/association-set-id-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/7-named-one-way-reflexive/association-set-id-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/association-set-test', ['exports', 'dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named One-Way Reflexive | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var child = _helper$state2[0];

      var savedParent = this.helper.savedParent();

      child.parent = savedParent;

      assert.equal(child.parentId, savedParent.id);
      assert.deepEqual(child.parent.attrs, savedParent.attrs);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var child = _helper$state32[0];

      var newParent = this.helper.newParent();

      child.parent = newParent;

      assert.equal(child.parentId, null);
      assert.deepEqual(child.parent, newParent);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a null parent', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var child = _helper$state42[0];

      child.parent = null;

      assert.equal(child.parentId, null);
      assert.deepEqual(child.parent, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/7-named-one-way-reflexive/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/7-named-one-way-reflexive/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Named One-Way Reflexive | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var parent = schema.create('user');
    var child = schema.create('user', {
      parentId: parent.id
    });

    assert.equal(child.parentId, parent.id);
    assert.deepEqual(child.parent.attrs, parent.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', parentId: null });
    assert.deepEqual(schema.db.users[1], { id: '2', parentId: '1' });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the association itself', function (assert) {
    var schema = this.helper.schema;

    var parent = schema.create('user');
    var child = schema.create('user', {
      parent: parent
    });

    assert.equal(child.parentId, parent.id);
    assert.deepEqual(child.parent.attrs, parent.attrs);
    assert.equal(schema.db.users.length, 2);
    assert.deepEqual(schema.db.users[0], { id: '1', parentId: null });
    assert.deepEqual(schema.db.users[1], { id: '2', parentId: '1' });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('user', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/7-named-one-way-reflexive/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/7-named-one-way-reflexive/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/delete-test', ['exports', 'dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | Named One-Way Reflexive | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting the parent updates the child\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var parent = _helper$state2[1];

      if (parent) {
        parent.destroy();
        user.reload();
      }

      assert.equal(user.parentId, null);
      assert.deepEqual(user.parent, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/7-named-one-way-reflexive/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/7-named-one-way-reflexive/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/instantiating-test', ['exports', 'dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Named One-Way Reflexive | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo7NamedOneWayReflexive_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the child accepts a saved parent id', function (assert) {
    var parent = this.helper.savedParent();
    var child = this.schema.users['new']({ parentId: parent.id });

    assert.equal(child.parentId, parent.id);
    assert.deepEqual(child.parent.attrs, parent.attrs);
    assert.deepEqual(child.attrs, { parentId: parent.id });
  });

  (0, _qunit.test)('the child errors if the parent id doesnt exist', function (assert) {
    assert.throws(function () {
      this.schema.users['new']({ parentId: 2 });
    }, /You're instantiating a user that has a parentId of 2, but that record doesn't exist in the database/);
  });

  (0, _qunit.test)('the child accepts a null parent id', function (assert) {
    var child = this.schema.users['new']({ parentId: null });

    assert.equal(child.parentId, null);
    assert.deepEqual(child.parent, null);
    assert.deepEqual(child.attrs, { parentId: null });
  });

  (0, _qunit.test)('the child accepts a saved parent model', function (assert) {
    var parent = this.helper.savedParent();
    var child = this.schema.users['new']({ parent: parent });

    assert.equal(child.parentId, 1);
    assert.deepEqual(child.parent.attrs, parent.attrs);
  });

  (0, _qunit.test)('the child accepts a new parent model', function (assert) {
    var zelda = this.schema.users['new']({ name: 'Zelda' });
    var child = this.schema.users['new']({ parent: zelda });

    assert.equal(child.parentId, null);
    assert.deepEqual(child.parent, zelda);
    assert.deepEqual(child.attrs, { parentId: null });
  });

  (0, _qunit.test)('the child accepts a null parent model', function (assert) {
    var child = this.schema.users['new']({ parent: null });

    assert.equal(child.parentId, null);
    assert.deepEqual(child.parent, null);
    assert.deepEqual(child.attrs, { parentId: null });
  });

  (0, _qunit.test)('the child accepts a parent model and id', function (assert) {
    var parent = this.helper.savedParent();
    var child = this.schema.users['new']({ parent: parent, parentId: parent.id });

    assert.equal(child.parentId, '1');
    assert.deepEqual(child.parent.attrs, parent.attrs);
    assert.deepEqual(child.attrs, { parentId: parent.id });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model as empty obj', function (assert) {
    var child = this.schema.users['new']({});

    assert.equal(child.parentId, null);
    assert.deepEqual(child.parent, null);
    assert.deepEqual(child.attrs, { parentId: null });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model', function (assert) {
    var child = this.schema.users['new']();

    assert.equal(child.parentId, null);
    assert.deepEqual(child.parent, null);
    assert.deepEqual(child.attrs, { parentId: null });
  });
});
define('dummy/tests/integration/orm/belongs-to/7-named-one-way-reflexive/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/7-named-one-way-reflexive/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/7-named-one-way-reflexive/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a belongsTo association can be in six states
    with respect to its association. This helper class
    returns a child (and its association) in these various states.
  
    The return value is an array of the form
  
      [ child, parent ]
  
    where the parent may be undefined.
  */

  var BelongsToHelper = (function () {
    function BelongsToHelper() {
      _classCallCheck(this, BelongsToHelper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          profile: (0, _emberCliMirage.belongsTo)()
        }),
        profile: _emberCliMirage.Model.extend({
          user: (0, _emberCliMirage.belongsTo)()
        })
      });
    }

    _createClass(BelongsToHelper, [{
      key: 'savedChildNoParent',
      value: function savedChildNoParent() {
        var insertedUser = this.db.users.insert({ name: 'Link' });

        return [this.schema.users.find(insertedUser.id), undefined];
      }
    }, {
      key: 'savedChildNewParent',
      value: function savedChildNewParent() {
        var user = this.schema.users.create({ name: 'Link' });
        var profile = this.schema.profiles['new']({ age: 300 });

        user.profile = profile;

        return [user, profile];
      }
    }, {
      key: 'savedChildSavedParent',
      value: function savedChildSavedParent() {
        var insertedProfile = this.db.profiles.insert({ age: 300 });
        var insertedUser = this.db.users.insert({ name: 'Link', profileId: insertedProfile.id });
        this.db.profiles.update(insertedProfile.id, { userId: insertedUser.id });
        var user = this.schema.users.find(insertedUser.id);
        var profile = this.schema.profiles.find(insertedProfile.id);

        return [user, profile];
      }
    }, {
      key: 'newChildNoParent',
      value: function newChildNoParent() {
        return [this.schema.users['new']({ name: 'Link' }), undefined];
      }
    }, {
      key: 'newChildNewParent',
      value: function newChildNewParent() {
        var profile = this.schema.profiles['new']({ age: 300 });
        var user = this.schema.users['new']({ name: 'Link' });
        user.profile = profile;

        return [user, profile];
      }
    }, {
      key: 'newChildSavedParent',
      value: function newChildSavedParent() {
        var insertedProfile = this.db.profiles.insert({ age: 300 });
        var user = this.schema.users['new']({ name: 'Link' });
        var savedProfile = this.schema.profiles.find(insertedProfile.id);

        user.profile = savedProfile;

        return [user, savedProfile];
      }

      // Just a saved unassociated parent.
    }, {
      key: 'savedParent',
      value: function savedParent() {
        var insertedProfile = this.db.profiles.insert({ age: 300 });

        return this.schema.profiles.find(insertedProfile.id);
      }
    }, {
      key: 'newParent',
      value: function newParent() {
        return this.schema.profiles['new']({ age: 300 });
      }
    }]);

    return BelongsToHelper;
  })();

  exports['default'] = BelongsToHelper;
  var states = ['savedChildNoParent', 'savedChildNewParent', 'savedChildSavedParent', 'newChildNoParent', 'newChildNewParent', 'newChildSavedParent'];
  exports.states = states;
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/8-one-to-one/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/8-one-to-one/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/accessor-test', ['exports', 'dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One To One | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var profile = _helper$state2[1];

      // We use .attrs here because otherwise deepEqual goes on infinite recursive comparison
      if (profile) {
        assert.deepEqual(user.profile.attrs, profile.attrs, 'the model reference is correct');
        assert.equal(user.profileId, profile.id, 'the modelId reference is correct');
      } else {
        assert.deepEqual(user.profile, null, 'the model reference is correct');
        assert.equal(user.profileId, null, 'the modelId reference is correct');
      }

      // If there's a profile in this state, make sure the inverse association is correct
      if (profile) {
        assert.deepEqual(profile.user.attrs, user.attrs, 'the inverse model reference is correct');
        assert.equal(profile.userId, user.id, 'the inverse modelId reference is correct');
      }
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/8-one-to-one/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/8-one-to-one/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/association-create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One To One | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper['default']();
    }
  });

  /*
    The model can create a belongs-to association, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var profile = user.createProfile({ age: 300 });

      assert.ok(profile.id, 'the parent was persisted');
      assert.deepEqual(user.profile.attrs, profile.attrs);
      assert.deepEqual(profile.user.attrs, user.attrs, 'the inverse was set');
      assert.equal(user.profileId, profile.id);
      assert.equal(this.helper.schema.users.find(user.id).profileId, profile.id, 'the user was persisted');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/8-one-to-one/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/8-one-to-one/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/association-new-test', ['exports', 'dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One To One | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var profile = user.newProfile({ age: 300 });

      assert.ok(!profile.id, 'the parent was not persisted');
      assert.deepEqual(user.profile, profile);
      assert.equal(user.profileId, null);
      assert.deepEqual(profile.user, user, 'the inverse was set');
      assert.equal(profile.userId, user.id);

      user.save();

      assert.ok(profile.id, 'saving the child persists the parent');
      assert.equal(user.profileId, profile.id, 'the childs fk was updated');
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/8-one-to-one/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/8-one-to-one/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/association-set-id-test', ['exports', 'dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One To One | association #setId', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var profile = this.helper.savedParent();

      user.profileId = profile.id;

      assert.equal(user.profileId, profile.id);
      assert.deepEqual(user.profile.attrs, profile.attrs);

      user.save();
      profile.reload();

      assert.equal(profile.userId, user.id, 'the inverse was set');
      assert.deepEqual(profile.user.attrs, user.attrs);
    });
  });

  // [
  //   'savedChildSavedParent',
  //   'newChildSavedParent'
  // ].forEach((state) => {
  //
  //   test(`a ${state} can clear its association via a null parentId`, function(assert) {
  //     let [ user ] = this.helper[state]();
  //
  //     user.userId = null;
  //
  //     assert.equal(user.userId, null);
  //     assert.equal(user.user, null);
  //   });
  //
  // });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/association-set-id-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/8-one-to-one/association-set-id-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/8-one-to-one/association-set-id-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/association-set-test', ['exports', 'dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One To One | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var profile = this.helper.savedParent();

      user.profile = profile;

      assert.equal(user.profileId, profile.id);
      assert.deepEqual(user.profile.attrs, profile.attrs);
      assert.equal(profile.userId, user.id, 'the inverse was set');
      assert.deepEqual(profile.user.attrs, user.attrs);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var user = _helper$state32[0];

      var profile = this.helper.newParent();

      user.profile = profile;

      assert.equal(user.profileId, null);
      assert.deepEqual(user.profile.attrs, profile.attrs);

      assert.equal(profile.userId, user.id, 'the inverse was set');
      assert.deepEqual(profile.user.attrs, user.attrs);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a null parent', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var user = _helper$state42[0];

      user.profile = null;

      assert.equal(user.profileId, null);
      assert.deepEqual(user.profile, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/8-one-to-one/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/8-one-to-one/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/create-test', ['exports', 'dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | One To One | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var profile = schema.create('profile');
    var user = schema.create('user', {
      profileId: profile.id
    });
    profile.reload();

    assert.equal(user.profileId, profile.id);
    assert.deepEqual(user.profile.attrs, profile.attrs);
    assert.deepEqual(profile.user.attrs, user.attrs);
    assert.equal(schema.db.users.length, 1);
    assert.equal(schema.db.profiles.length, 1);
    assert.deepEqual(schema.db.users[0], { id: '1', profileId: '1' });
    assert.deepEqual(schema.db.profiles[0], { id: '1', userId: '1' });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the association itself', function (assert) {
    var schema = this.helper.schema;

    var profile = schema.create('profile');
    var user = schema.create('user', {
      profile: profile
    });

    assert.equal(user.profileId, profile.id);
    assert.deepEqual(user.profile.attrs, profile.attrs);
    assert.deepEqual(profile.user.attrs, user.attrs);
    assert.equal(schema.db.users.length, 1);
    assert.equal(schema.db.profiles.length, 1);
    assert.deepEqual(schema.db.users[0], { id: '1', profileId: '1' });
    assert.deepEqual(schema.db.profiles[0], { id: '1', userId: '1' });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('user', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/8-one-to-one/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/8-one-to-one/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/delete-test', ['exports', 'dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Belongs To | One To One | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting the parent updates the child\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var profile = _helper$state2[1];

      if (profile) {
        profile.destroy();
        user.reload();
      }

      assert.equal(user.profileId, null);
      assert.deepEqual(user.profile, null);
    });
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/8-one-to-one/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/8-one-to-one/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/instantiating-test', ['exports', 'dummy/tests/integration/orm/belongs-to/8-one-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | One To One | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmBelongsTo8OneToOne_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the child accepts a saved parent id', function (assert) {
    var profile = this.helper.savedParent();
    var user = this.schema.users['new']({ profileId: profile.id });

    assert.equal(user.profileId, profile.id);
    assert.deepEqual(user.profile.attrs, profile.attrs);
    assert.deepEqual(user.attrs, { profileId: profile.id });
  });

  (0, _qunit.test)('the child errors if the parent id doesnt exist', function (assert) {
    assert.throws(function () {
      this.schema.users['new']({ profileId: 2 });
    }, /You're instantiating a user that has a profileId of 2, but that record doesn't exist in the database/);
  });

  (0, _qunit.test)('the child accepts a null parent id', function (assert) {
    var user = this.schema.users['new']({ profileId: null });

    assert.equal(user.profileId, null);
    assert.equal(user.profile, null);
    assert.deepEqual(user.attrs, { profileId: null });
  });

  (0, _qunit.test)('the child accepts a saved parent model', function (assert) {
    var profile = this.helper.savedParent();
    var user = this.schema.users['new']({ profile: profile });

    assert.equal(user.profileId, 1);
    assert.deepEqual(user.profile.attrs, profile.attrs);
    assert.deepEqual(user.attrs, { profileId: null }); // this would update when saved
  });

  (0, _qunit.test)('the child accepts a new parent model', function (assert) {
    var profile = this.schema.profiles['new']({ age: 300 });
    var user = this.schema.users['new']({ profile: profile });

    assert.equal(user.profileId, null);
    assert.deepEqual(user.profile, profile);
    assert.deepEqual(user.attrs, { profileId: null });
  });

  (0, _qunit.test)('the child accepts a null parent model', function (assert) {
    var user = this.schema.users['new']({ profile: null });

    assert.equal(user.profileId, null);
    assert.deepEqual(user.profile, null);
    assert.deepEqual(user.attrs, { profileId: null });
  });

  (0, _qunit.test)('the child accepts a parent model and id', function (assert) {
    var profile = this.helper.savedParent();
    var user = this.schema.users['new']({ profile: profile, profileId: profile.id });

    assert.equal(user.profileId, '1');
    assert.deepEqual(user.profile, profile);
    assert.deepEqual(user.attrs, { profileId: profile.id });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model as empty obj', function (assert) {
    var user = this.schema.users['new']({});

    assert.equal(user.profileId, null);
    assert.deepEqual(user.profile, null);
    assert.deepEqual(user.attrs, { profileId: null });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model', function (assert) {
    var user = this.schema.users['new']();

    assert.equal(user.profileId, null);
    assert.deepEqual(user.profile, null);
    assert.deepEqual(user.attrs, { profileId: null });
  });
});
define('dummy/tests/integration/orm/belongs-to/8-one-to-one/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/8-one-to-one/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(false, 'integration/orm/belongs-to/8-one-to-one/instantiating-test.js should pass ESLint.\n62:46  - There should be no space before \',\'. (comma-spacing)');
  });
});
define('dummy/tests/integration/orm/belongs-to/9-misc/misc-test', ['exports', 'qunit'], function (exports, _qunit) {

  (0, _qunit.module)('Integration | ORM | Belongs To | Misc');

  (0, _qunit.test)('an ambiguous schema throws an error', function (assert) {
    assert.ok(true);
    // assert.throws(function() {
    //   new Schema(new Db(), {
    //     user: Model.extend({
    //       foo: belongsTo('user'),
    //       bar: belongsTo('user')
    //     })
    //   });
    // }, /You defined the 'foo' relationship on user, but multiple possible inverse relationships of type user exist. Please refer to the models documentation to learn how to explicitly specify inverses./);
  });
});
// import { Model, belongsTo } from 'ember-cli-mirage';
// import Schema from 'ember-cli-mirage/orm/schema';
// import Db from 'ember-cli-mirage/db';
define('dummy/tests/integration/orm/belongs-to/9-misc/misc-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/belongs-to/9-misc/misc-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/belongs-to/9-misc/misc-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/collection-inflector-test', ['exports', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-inflector', 'qunit'], function (exports, _emberCliMirageOrmModel, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberInflector, _qunit) {

  var db, schema, HeadOfState;
  (0, _qunit.module)('Integration | ORM | inflector-collectionName integration', {
    beforeEach: function beforeEach() {
      _emberInflector['default'].inflector.irregular('head-of-state', 'heads-of-state');

      HeadOfState = _emberCliMirageOrmModel['default'].extend();
      db = new _emberCliMirageDb['default']({});
      schema = new _emberCliMirageOrmSchema['default'](db);
      schema.registerModel('headOfState', HeadOfState);
    }
  });

  (0, _qunit.test)(' [regression] collection creation respects irregular plural rules', function (assert) {
    assert.equal(schema.db._collections.length, 1);
    assert.equal(schema.db._collections[0].name, 'headsOfState');
  });
});
define('dummy/tests/integration/orm/collection-inflector-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/collection-inflector-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/collection-inflector-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/collection-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'ember-cli-mirage/orm/collection', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _emberCliMirageOrmCollection, _qunit) {

  (0, _qunit.module)('Integration | ORM | collection', {
    beforeEach: function beforeEach() {
      this.User = _emberCliMirageOrmModel['default'].extend();
      this.db = new _emberCliMirageDb['default']({ users: [{ id: 1, name: 'Link', good: true }, { id: 2, name: 'Zelda', good: true }, { id: 3, name: 'Ganon', good: false }] });

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: this.User
      });
    }
  });

  (0, _qunit.test)('a collection can save its models', function (assert) {
    var collection = this.schema.users.all();
    collection.models[0].name = 'Sam';
    collection.save();

    assert.deepEqual(this.db.users[0], { id: '1', name: 'Sam', good: true });
  });

  (0, _qunit.test)('a collection can reload its models', function (assert) {
    var collection = this.schema.users.all();
    assert.equal(collection.models[0].name, 'Link');

    collection.models[0].name = 'Sam';
    assert.equal(collection.models[0].name, 'Sam');

    collection.reload();
    assert.equal(collection.models[0].name, 'Link');
  });

  (0, _qunit.test)('a collection can filter its models', function (assert) {
    var collection = this.schema.users.all();
    assert.equal(collection.models.length, 3);

    var newCollection = collection.filter(function (author) {
      return author.good;
    });

    assert.ok(newCollection instanceof _emberCliMirageOrmCollection['default']);
    assert.equal(newCollection.modelName, 'user', 'the filtered collection has the right type');
    assert.equal(newCollection.models.length, 2);
  });

  (0, _qunit.test)('a collection can sort its models', function (assert) {
    var collection = this.schema.users.all();
    assert.deepEqual(collection.models.map(function (m) {
      return m.name;
    }), ['Link', 'Zelda', 'Ganon']);

    var newCollection = collection.sort(function (a, b) {
      return a.name.localeCompare(b.name);
    });

    assert.ok(newCollection instanceof _emberCliMirageOrmCollection['default']);
    assert.equal(newCollection.modelName, 'user', 'the sorted collection has the right type');
    assert.deepEqual(newCollection.models.map(function (m) {
      return m.name;
    }), ['Ganon', 'Link', 'Zelda']);
  });

  (0, _qunit.test)('a collection can slice its models', function (assert) {
    var collection = this.schema.users.all();
    assert.deepEqual(collection.models.map(function (m) {
      return m.name;
    }), ['Link', 'Zelda', 'Ganon'], 'Starts with 3');

    var newCollection = collection.slice(-2);

    assert.ok(newCollection instanceof _emberCliMirageOrmCollection['default']);
    assert.equal(newCollection.modelName, 'user', 'the sliced collection has the right type');
    assert.deepEqual(newCollection.models.map(function (m) {
      return m.name;
    }), ['Zelda', 'Ganon']);
  });

  (0, _qunit.test)('a collection can merge with another collection', function (assert) {
    var goodGuys = this.schema.users.where(function (user) {
      return user.good;
    });
    var badGuys = this.schema.users.where(function (user) {
      return !user.good;
    });

    assert.equal(goodGuys.models.length, 2);
    assert.equal(badGuys.models.length, 1);

    goodGuys.mergeCollection(badGuys);

    assert.equal(goodGuys.models.length, 3);
  });
});
define('dummy/tests/integration/orm/collection-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/collection-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/collection-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/create-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _qunit) {

  var db, schema, User;
  (0, _qunit.module)('Integration | ORM | create', {
    beforeEach: function beforeEach() {
      User = _emberCliMirageOrmModel['default'].extend();
      db = new _emberCliMirageDb['default']();
      schema = new _emberCliMirageOrmSchema['default'](db, {
        user: User
      });
    }
  });

  (0, _qunit.test)('it cannot make new models that havent been registered', function (assert) {
    assert.throws(function () {
      schema.authors['new']({ name: 'Link' });
    });
  });

  (0, _qunit.test)('it cannot create models that havent been registered', function (assert) {
    assert.throws(function () {
      schema.authors.create({ name: 'Link' });
    });
  });

  (0, _qunit.test)('it can make new models and then save them', function (assert) {
    var user = schema.users['new']({ name: 'Link' });

    assert.ok(user instanceof User);
    assert.deepEqual(user.attrs, { name: 'Link' });
    assert.deepEqual(db.users, []);

    user.save();

    assert.ok(user.id, 'user has an id getter');
    assert.deepEqual(user.attrs, { id: '1', name: 'Link' });
    assert.deepEqual(db.users, [{ id: '1', name: 'Link' }]);
  });

  (0, _qunit.test)('it can create new models, saved directly to the db', function (assert) {
    var user = schema.users.create({ name: 'Link' });

    assert.ok(user instanceof _emberCliMirageOrmModel['default']);
    assert.ok(user instanceof User);
    assert.deepEqual(user.attrs, { id: '1', name: 'Link' });
    assert.deepEqual(db.users, [{ id: '1', name: 'Link' }]);
  });
});
define('dummy/tests/integration/orm/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/destroy-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _qunit) {

  var db = undefined;
  (0, _qunit.module)('Integration | ORM | destroy', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']({
        users: [{ id: 1, name: 'Link', evil: false }, { id: 2, name: 'Link', location: 'Hyrule', evil: false }, { id: 3, name: 'Zelda', location: 'Hyrule', evil: false }]
      });

      this.schema = new _emberCliMirageOrmSchema['default'](db, {
        user: _emberCliMirageOrmModel['default']
      });
    }
  });

  (0, _qunit.test)('destroying a model removes the associated record from the db', function (assert) {
    assert.deepEqual(db.users.length, 3);

    var link = this.schema.users.find(1);
    link.destroy();

    assert.deepEqual(db.users.find(1), null);
    assert.deepEqual(db.users.length, 2);
  });

  (0, _qunit.test)('destroying a collection removes the associated records from the db', function (assert) {
    assert.deepEqual(db.users.length, 3);

    var users = this.schema.users.all();
    users.destroy();

    assert.deepEqual(db.users, []);
  });
});
define('dummy/tests/integration/orm/destroy-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/destroy-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/destroy-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/find-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'ember-cli-mirage/orm/collection', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _emberCliMirageOrmCollection, _qunit) {

  var schema;
  var User = _emberCliMirageOrmModel['default'].extend();
  (0, _qunit.module)('Integration | ORM | #find', {
    beforeEach: function beforeEach() {
      var db = new _emberCliMirageDb['default']({ users: [{ id: 1, name: 'Link' }, { id: 2, name: 'Zelda' }] });

      schema = new _emberCliMirageOrmSchema['default'](db, {
        user: User
      });
    }
  });

  (0, _qunit.test)('it can find a model by id', function (assert) {
    var zelda = schema.users.find(2);

    assert.ok(zelda instanceof User);
    assert.deepEqual(zelda.attrs, { id: '2', name: 'Zelda' });
  });

  (0, _qunit.test)('it returns null if no model is found for an id', function (assert) {
    var user = schema.users.find(4);

    assert.equal(user, null);
  });

  (0, _qunit.test)('it can find multiple models by ids', function (assert) {
    var users = schema.users.find([1, 2]);

    assert.ok(users instanceof _emberCliMirageOrmCollection['default'], 'it returns a collection');
    assert.ok(users.models[0] instanceof User);
    assert.equal(users.models.length, 2);
    assert.deepEqual(users.models[1].attrs, { id: '2', name: 'Zelda' });
  });

  (0, _qunit.test)('it errors if incorrect number of models are found for an array of ids', function (assert) {
    assert.throws(function () {
      schema.users.find([1, 6]);
    }, /Couldn't find all users/);
  });
});
define('dummy/tests/integration/orm/find-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/find-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/find-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/first-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _qunit) {

  var schema = undefined;
  var User = _emberCliMirageOrmModel['default'].extend();
  (0, _qunit.module)('Integration | ORM | #first', {
    beforeEach: function beforeEach() {
      var db = new _emberCliMirageDb['default']();
      db.createCollection('users');
      db.users.insert([{ id: 1, name: 'Link' }, { id: 2, name: 'Zelda' }]);
      schema = new _emberCliMirageOrmSchema['default'](db);

      schema.registerModel('user', User);
    }
  });

  (0, _qunit.test)('it can find the first model', function (assert) {
    var user = schema.users.first();

    assert.ok(user instanceof User);
    assert.deepEqual(user.attrs, { id: '1', name: 'Link' });
  });
});
define('dummy/tests/integration/orm/first-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/first-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/first-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          posts: (0, _emberCliMirage.hasMany)()
        }),
        post: _emberCliMirage.Model
      });
    }

    _createClass(Helper, [{
      key: 'savedParentNoChildren',
      value: function savedParentNoChildren() {
        var user = this.db.users.insert({ name: 'Link' });

        return [this.schema.users.find(user.id), []];
      }
    }, {
      key: 'savedParentNewChildren',
      value: function savedParentNewChildren() {
        var user = this.schema.users.create({ name: 'Link' });
        var post1 = this.schema.posts['new']({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'savedParentSavedChildren',
      value: function savedParentSavedChildren() {
        var user = this.schema.users.create({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts.create({ title: 'Ipsum' });

        user.posts = [post1, post2];
        user.save();

        return [user, [post1, post2]];
      }
    }, {
      key: 'savedParentMixedChildren',
      value: function savedParentMixedChildren() {
        var user = this.schema.users.create({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'newParentNoChildren',
      value: function newParentNoChildren() {
        var user = this.schema.users['new']({ name: 'Link' });

        return [user, []];
      }
    }, {
      key: 'newParentNewChildren',
      value: function newParentNewChildren() {
        var user = this.schema.users['new']({ name: 'Link' });
        var post1 = this.schema.posts['new']({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'newParentSavedChildren',
      value: function newParentSavedChildren() {
        var user = this.schema.users['new']({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts.create({ title: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'newParentMixedChildren',
      value: function newParentMixedChildren() {
        var user = this.schema.users['new']({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }

      // Unassociated child models, used for setting tests
    }, {
      key: 'savedChild',
      value: function savedChild() {
        var insertedPost = this.db.posts.insert({ title: 'Lorem' });

        return this.schema.posts.find(insertedPost.id);
      }
    }, {
      key: 'newChild',
      value: function newChild() {
        return this.schema.posts['new']({ title: 'Lorem' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedParentNoChildren', 'savedParentNewChildren', 'savedParentSavedChildren', 'savedParentMixedChildren', 'newParentNoChildren', 'newParentNewChildren', 'newParentSavedChildren', 'newParentMixedChildren'];
  exports.states = states;
});
define('dummy/tests/integration/orm/has-many/1-basic/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/1-basic/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/1-basic/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/accessor-test', ['exports', 'dummy/tests/integration/orm/has-many/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Basic | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany1Basic_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmHasMany1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var posts = _helper$state2[1];

      assert.equal(user.posts.models.length, posts.length, 'the parent has the correct number of children');
      assert.equal(user.postIds.length, posts.length, 'the parent has the correct number of children ids');

      posts.forEach(function (post, i) {
        assert.deepEqual(user.posts.models[i], posts[i], 'each child is in parent.children array');

        if (post.isSaved()) {
          assert.ok(user.postIds.indexOf(post.id) > -1, 'each saved child id is in parent.childrenIds array');
        }
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/1-basic/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/1-basic/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/association-create-test', ['exports', 'dummy/tests/integration/orm/has-many/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Basic | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany1Basic_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmHasMany1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var initialCount = user.posts.models.length;

      var post = user.createPost({ title: 'Lorem ipsum' });

      assert.ok(post.id, 'the child was persisted');
      assert.equal(user.posts.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(user.posts.includes(post), 'the model was added to user.posts');
      assert.ok(user.postIds.indexOf(post.id) > -1, 'the id was added to the fks array');
      assert.ok(user.attrs.postIds.indexOf(post.id) > -1, 'fks were persisted');
    });
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/1-basic/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/1-basic/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/association-new-test', ['exports', 'dummy/tests/integration/orm/has-many/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Basic | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany1Basic_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmHasMany1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var initialCount = user.posts.models.length;

      var post = user.newPost({ title: 'Lorem ipsum' });

      assert.ok(!post.id, 'the child was not persisted');
      assert.equal(user.posts.models.length, initialCount + 1);

      post.save();

      assert.deepEqual(post.attrs, { id: post.id, title: 'Lorem ipsum' }, 'the child was persisted');
      assert.equal(user.posts.models.length, initialCount + 1, 'the collection size was increased');
      assert.deepEqual(user.posts.models.filter(function (a) {
        return a.id === post.id;
      })[0], post, 'the model was added to user.posts');
      assert.ok(user.postIds.indexOf(post.id) > -1, 'the id was added to the fks array');
    });
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/1-basic/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/1-basic/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/has-many/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Basic | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany1Basic_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmHasMany1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var savedPost = this.helper.savedChild();

      user.postIds = [savedPost.id];

      assert.deepEqual(user.posts.models[0].attrs, savedPost.attrs);
      assert.deepEqual(user.postIds, [savedPost.id]);
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var user = _helper$state32[0];

      user.postIds = null;

      assert.deepEqual(user.posts.models, []);
      assert.deepEqual(user.postIds, []);
    });
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/1-basic/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/1-basic/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/association-set-test', ['exports', 'dummy/tests/integration/orm/has-many/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Basic | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany1Basic_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmHasMany1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a list of saved children', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var savedPost = this.helper.savedChild();

      user.posts = [savedPost];

      assert.ok(user.posts.models.indexOf(savedPost) > -1);
      assert.ok(user.postIds.indexOf(savedPost.id) > -1);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var user = _helper$state32[0];

      var newPost = this.helper.newChild();

      user.posts = [newPost];

      assert.deepEqual(user.postIds, [undefined]);
      assert.deepEqual(user.posts.models[0], newPost);
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var user = _helper$state42[0];

      user.posts = [];

      assert.deepEqual(user.postIds, []);
      assert.equal(user.posts.models.length, 0);
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state5 = this.helper[state]();

      var _helper$state52 = _slicedToArray(_helper$state5, 1);

      var user = _helper$state52[0];

      user.posts = null;

      assert.deepEqual(user.postIds, []);
      assert.equal(user.posts.models.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/1-basic/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/1-basic/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/create-test', ['exports', 'dummy/tests/integration/orm/has-many/1-basic/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany1Basic_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Basic | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany1Basic_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var post = this.helper.schema.create('post');
    var user = this.helper.schema.create('user', {
      postIds: [post.id]
    });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.attrs.postIds, [post.id], 'the ids were persisted');
    assert.deepEqual(user.posts.models[0].attrs, post.attrs);
    assert.equal(this.helper.db.posts.length, 1);
    assert.deepEqual(this.helper.db.posts[0], { id: '1' });
    assert.equal(this.helper.db.users.length, 1);
    assert.deepEqual(this.helper.db.users[0], { id: '1', postIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in an array of models', function (assert) {
    var post = this.helper.schema.create('post');
    var user = this.helper.schema.create('user', {
      posts: [post]
    });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.attrs.postIds, [post.id], 'the ids were persisted');
    assert.deepEqual(user.posts.models[0].attrs, post.attrs);
    assert.equal(this.helper.db.posts.length, 1);
    assert.deepEqual(this.helper.db.posts[0], { id: '1' });
    assert.equal(this.helper.db.users.length, 1);
    assert.deepEqual(this.helper.db.users[0], { id: '1', postIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in a collection', function (assert) {
    var post = this.helper.schema.create('post');
    var user = this.helper.schema.create('user', {
      posts: this.helper.schema.posts.all()
    });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.attrs.postIds, [post.id], 'the ids were persisted');
    assert.deepEqual(user.posts.models[0].attrs, post.attrs);
    assert.equal(this.helper.db.posts.length, 1);
    assert.deepEqual(this.helper.db.posts[0], { id: '1' });
    assert.equal(this.helper.db.users.length, 1);
    assert.deepEqual(this.helper.db.users[0], { id: '1', postIds: ['1'] });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if an array of models is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foos: [schema.create('foo')]
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('post', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/1-basic/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/1-basic/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/delete-test', ['exports', 'dummy/tests/integration/orm/has-many/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany1Basic_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Basic | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany1Basic_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany1Basic_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting children updates the parent\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var posts = _helper$state2[1];

      if (posts && posts.length) {
        posts.forEach(function (p) {
          return p.destroy();
        });
        user.reload();
      }

      assert.equal(user.posts.length, 0);
      assert.equal(user.postIds.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/1-basic/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/1-basic/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/instantiating-test', ['exports', 'dummy/tests/integration/orm/has-many/1-basic/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany1Basic_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Basic | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany1Basic_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the parent accepts a saved child id', function (assert) {
    var post = this.helper.savedChild();
    var user = this.schema.users['new']({
      postIds: [post.id]
    });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.posts.models[0], post);
  });

  (0, _qunit.test)('the parent errors if the children ids don\'t exist', function (assert) {
    assert.throws(function () {
      this.schema.users['new']({ postIds: [2] });
    }, /You're instantiating a user that has a postIds of 2, but some of those records don't exist in the database/);
  });

  (0, _qunit.test)('the parent accepts null children foreign key', function (assert) {
    var user = this.schema.users['new']({ postIds: null });

    assert.equal(user.posts.models.length, 0);
    assert.deepEqual(user.postIds, []);
    assert.deepEqual(user.attrs, { postIds: null });
  });

  (0, _qunit.test)('the parent accepts saved children', function (assert) {
    var post = this.helper.savedChild();
    var user = this.schema.users['new']({ posts: [post] });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.posts.models[0], post);
  });

  (0, _qunit.test)('the parent accepts new children', function (assert) {
    var post = this.schema.posts['new']({ title: 'Lorem' });
    var user = this.schema.users['new']({ posts: [post] });

    assert.deepEqual(user.postIds, [undefined]);
    assert.deepEqual(user.posts.models[0], post);
  });

  (0, _qunit.test)('the parent accepts null children', function (assert) {
    var user = this.schema.users['new']({ posts: null });

    assert.equal(user.posts.models.length, 0);
    assert.deepEqual(user.postIds, []);
    assert.deepEqual(user.attrs, { postIds: null });
  });

  (0, _qunit.test)('the parent accepts children and child ids', function (assert) {
    var post = this.helper.savedChild();
    var user = this.schema.users['new']({ posts: [post], postIds: [post.id] });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.posts.models[0], post);
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids as empty obj', function (assert) {
    var user = this.schema.users['new']({});

    assert.deepEqual(user.postIds, []);
    assert.deepEqual(user.posts.models, []);
    assert.deepEqual(user.attrs, { postIds: null });
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids', function (assert) {
    var user = this.schema.users['new']();

    assert.deepEqual(user.postIds, []);
    assert.deepEqual(user.posts.models, []);
    assert.deepEqual(user.attrs, { postIds: null });
  });
});
define('dummy/tests/integration/orm/has-many/1-basic/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/1-basic/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/1-basic/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/2-named/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          blogPosts: (0, _emberCliMirage.hasMany)('post')
        }),
        post: _emberCliMirage.Model
      });
    }

    _createClass(Helper, [{
      key: 'savedParentNoChildren',
      value: function savedParentNoChildren() {
        var user = this.db.users.insert({ name: 'Link' });

        return [this.schema.users.find(user.id), []];
      }
    }, {
      key: 'savedParentNewChildren',
      value: function savedParentNewChildren() {
        var user = this.schema.users.create({ name: 'Link' });
        var post1 = this.schema.posts['new']({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.blogPosts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'savedParentSavedChildren',
      value: function savedParentSavedChildren() {
        var user = this.schema.users.create({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts.create({ title: 'Ipsum' });

        user.blogPosts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'savedParentMixedChildren',
      value: function savedParentMixedChildren() {
        var user = this.schema.users.create({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.blogPosts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'newParentNoChildren',
      value: function newParentNoChildren() {
        var user = this.schema.users['new']({ name: 'Link' });

        return [user, []];
      }
    }, {
      key: 'newParentNewChildren',
      value: function newParentNewChildren() {
        var user = this.schema.users['new']({ name: 'Link' });
        var post1 = this.schema.posts['new']({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.blogPosts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'newParentSavedChildren',
      value: function newParentSavedChildren() {
        var user = this.schema.users['new']({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts.create({ title: 'Ipsum' });

        user.blogPosts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'newParentMixedChildren',
      value: function newParentMixedChildren() {
        var user = this.schema.users['new']({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.blogPosts = [post1, post2];

        return [user, [post1, post2]];
      }

      // Unassociated child models, used for setting tests
    }, {
      key: 'savedChild',
      value: function savedChild() {
        var insertedPost = this.db.posts.insert({ title: 'Lorem' });

        return this.schema.posts.find(insertedPost.id);
      }
    }, {
      key: 'newChild',
      value: function newChild() {
        return this.schema.posts['new']({ title: 'Lorem' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedParentNoChildren', 'savedParentNewChildren', 'savedParentSavedChildren', 'savedParentMixedChildren', 'newParentNoChildren', 'newParentNewChildren', 'newParentSavedChildren', 'newParentMixedChildren'];
  exports.states = states;
});
define('dummy/tests/integration/orm/has-many/2-named/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/2-named/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/2-named/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/2-named/accessor-test', ['exports', 'dummy/tests/integration/orm/has-many/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany2Named_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmHasMany2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var posts = _helper$state2[1];

      assert.equal(user.blogPosts.models.length, posts.length, 'the parent has the correct number of children');
      assert.equal(user.blogPostIds.length, posts.length, 'the parent has the correct number of children ids');

      posts.forEach(function (post, i) {
        assert.deepEqual(user.blogPosts.models[i], posts[i], 'each child is in parent.children array');

        if (post.isSaved()) {
          assert.ok(user.blogPostIds.indexOf(post.id) > -1, 'each saved child id is in parent.childrenIds array');
        }
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/2-named/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/2-named/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/2-named/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/2-named/association-create-test', ['exports', 'dummy/tests/integration/orm/has-many/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany2Named_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmHasMany2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var initialCount = user.blogPosts.models.length;

      var post = user.createBlogPost({ title: 'Lorem ipsum' });

      assert.ok(post.id, 'the child was persisted');
      assert.equal(user.blogPosts.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(user.blogPosts.includes(post), 'the model was added to user.blogPosts');
      assert.ok(user.blogPostIds.indexOf(post.id) > -1, 'the id was added to the fks array');
      assert.ok(user.attrs.blogPostIds.indexOf(post.id) > -1, 'fks were persisted');
    });
  });
});
define('dummy/tests/integration/orm/has-many/2-named/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/2-named/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/2-named/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/2-named/association-new-test', ['exports', 'dummy/tests/integration/orm/has-many/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany2Named_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmHasMany2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var initialCount = user.blogPosts.models.length;

      var post = user.newBlogPost({ title: 'Lorem ipsum' });

      assert.ok(!post.id, 'the child was not persisted');
      assert.equal(user.blogPosts.models.length, initialCount + 1);

      post.save();

      assert.deepEqual(post.attrs, { id: post.id, title: 'Lorem ipsum' }, 'the child was persisted');
      assert.equal(user.blogPosts.models.length, initialCount + 1, 'the collection size was increased');
      assert.deepEqual(user.blogPosts.models.filter(function (a) {
        return a.id === post.id;
      })[0], post, 'the model was added to user.blogPosts');
      assert.ok(user.blogPostIds.indexOf(post.id) > -1, 'the id was added to the fks array');
    });
  });
});
define('dummy/tests/integration/orm/has-many/2-named/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/2-named/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/2-named/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/2-named/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/has-many/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany2Named_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmHasMany2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var savedPost = this.helper.savedChild();

      user.blogPostIds = [savedPost.id];

      assert.deepEqual(user.blogPosts.models[0].attrs, savedPost.attrs);
      assert.deepEqual(user.blogPostIds, [savedPost.id]);
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var user = _helper$state32[0];

      user.blogPostIds = null;

      assert.deepEqual(user.blogPosts.models, []);
      assert.deepEqual(user.blogPostIds, []);
    });
  });
});
define('dummy/tests/integration/orm/has-many/2-named/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/2-named/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/2-named/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/2-named/association-set-test', ['exports', 'dummy/tests/integration/orm/has-many/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany2Named_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmHasMany2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a list of saved children', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var savedPost = this.helper.savedChild();

      user.blogPosts = [savedPost];

      assert.ok(user.blogPosts.models.indexOf(savedPost) > -1);
      assert.ok(user.blogPostIds.indexOf(savedPost.id) > -1);
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var user = _helper$state32[0];

      var newPost = this.helper.newChild();

      user.blogPosts = [newPost];

      assert.deepEqual(user.blogPostIds, [undefined]);
      assert.deepEqual(user.blogPosts.models[0], newPost);
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var user = _helper$state42[0];

      user.blogPosts = [];

      assert.deepEqual(user.blogPostIds, []);
      assert.equal(user.blogPosts.models.length, 0);
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state5 = this.helper[state]();

      var _helper$state52 = _slicedToArray(_helper$state5, 1);

      var user = _helper$state52[0];

      user.blogPosts = null;

      assert.deepEqual(user.blogPostIds, []);
      assert.equal(user.blogPosts.models.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/2-named/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/2-named/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/2-named/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/2-named/create-test', ['exports', 'dummy/tests/integration/orm/has-many/2-named/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany2Named_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Named | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany2Named_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var post = this.helper.schema.create('post');
    var user = this.helper.schema.create('user', {
      blogPostIds: [post.id]
    });

    assert.deepEqual(user.blogPostIds, [post.id]);
    assert.deepEqual(user.attrs.blogPostIds, [post.id], 'the ids were persisted');
    assert.deepEqual(user.blogPosts.models[0].attrs, post.attrs);
    assert.equal(this.helper.db.posts.length, 1);
    assert.deepEqual(this.helper.db.posts[0], { id: '1' });
    assert.equal(this.helper.db.users.length, 1);
    assert.deepEqual(this.helper.db.users[0], { id: '1', blogPostIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in an array of models', function (assert) {
    var post = this.helper.schema.create('post');
    var user = this.helper.schema.create('user', {
      blogPosts: [post]
    });

    assert.deepEqual(user.blogPostIds, [post.id]);
    assert.deepEqual(user.attrs.blogPostIds, [post.id], 'the ids were persisted');
    assert.deepEqual(user.blogPosts.models[0].attrs, post.attrs);
    assert.equal(this.helper.db.posts.length, 1);
    assert.deepEqual(this.helper.db.posts[0], { id: '1' });
    assert.equal(this.helper.db.users.length, 1);
    assert.deepEqual(this.helper.db.users[0], { id: '1', blogPostIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in a collection', function (assert) {
    var post = this.helper.schema.create('post');
    var user = this.helper.schema.create('user', {
      blogPosts: this.helper.schema.posts.all()
    });

    assert.deepEqual(user.blogPostIds, [post.id]);
    assert.deepEqual(user.attrs.blogPostIds, [post.id], 'the ids were persisted');
    assert.deepEqual(user.blogPosts.models[0].attrs, post.attrs);
    assert.equal(this.helper.db.posts.length, 1);
    assert.deepEqual(this.helper.db.posts[0], { id: '1' });
    assert.equal(this.helper.db.users.length, 1);
    assert.deepEqual(this.helper.db.users[0], { id: '1', blogPostIds: ['1'] });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if an array of models is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foos: [schema.create('foo')]
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('post', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/has-many/2-named/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/2-named/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/2-named/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/2-named/delete-test', ['exports', 'dummy/tests/integration/orm/has-many/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany2Named_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany2Named_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany2Named_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting children updates the parent\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var blogPosts = _helper$state2[1];

      if (blogPosts && blogPosts.length) {
        blogPosts.forEach(function (p) {
          return p.destroy();
        });
        user.reload();
      }

      assert.equal(user.blogPosts.length, 0);
      assert.equal(user.blogPostIds.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/2-named/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/2-named/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/2-named/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/2-named/instantiating-test', ['exports', 'dummy/tests/integration/orm/has-many/2-named/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany2Named_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Named | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany2Named_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the parent accepts a saved child id', function (assert) {
    var post = this.helper.savedChild();
    var user = this.schema.users['new']({
      blogPostIds: [post.id]
    });

    assert.deepEqual(user.blogPostIds, [post.id]);
    assert.deepEqual(user.blogPosts.models[0], post);
  });

  (0, _qunit.test)('the parent errors if the children ids don\'t exist', function (assert) {
    assert.throws(function () {
      this.schema.users['new']({ blogPostIds: [2] });
    }, /You're instantiating a user that has a blogPostIds of 2, but some of those records don't exist in the database/);
  });

  (0, _qunit.test)('the parent accepts null children foreign key', function (assert) {
    var user = this.schema.users['new']({ blogPostIds: null });

    assert.equal(user.blogPosts.models.length, 0);
    assert.deepEqual(user.blogPostIds, []);
    assert.deepEqual(user.attrs, { blogPostIds: null });
  });

  (0, _qunit.test)('the parent accepts saved children', function (assert) {
    var post = this.helper.savedChild();
    var user = this.schema.users['new']({ blogPosts: [post] });

    assert.deepEqual(user.blogPostIds, [post.id]);
    assert.deepEqual(user.blogPosts.models[0], post);
  });

  (0, _qunit.test)('the parent accepts new children', function (assert) {
    var post = this.schema.posts['new']({ title: 'Lorem' });
    var user = this.schema.users['new']({ blogPosts: [post] });

    assert.deepEqual(user.blogPostIds, [undefined]);
    assert.deepEqual(user.blogPosts.models[0], post);
  });

  (0, _qunit.test)('the parent accepts null children', function (assert) {
    var user = this.schema.users['new']({ blogPosts: null });

    assert.equal(user.blogPosts.models.length, 0);
    assert.deepEqual(user.blogPostIds, []);
    assert.deepEqual(user.attrs, { blogPostIds: null });
  });

  (0, _qunit.test)('the parent accepts children and child ids', function (assert) {
    var post = this.helper.savedChild();
    var user = this.schema.users['new']({ blogPosts: [post], blogPostIds: [post.id] });

    assert.deepEqual(user.blogPostIds, [post.id]);
    assert.deepEqual(user.blogPosts.models[0], post);
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids as empty obj', function (assert) {
    var user = this.schema.users['new']({});

    assert.deepEqual(user.blogPostIds, []);
    assert.deepEqual(user.blogPosts.models, []);
    assert.deepEqual(user.attrs, { blogPostIds: null });
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids', function (assert) {
    var user = this.schema.users['new']();

    assert.deepEqual(user.blogPostIds, []);
    assert.deepEqual(user.blogPosts.models, []);
    assert.deepEqual(user.attrs, { blogPostIds: null });
  });
});
define('dummy/tests/integration/orm/has-many/2-named/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/2-named/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/2-named/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        tag: _emberCliMirage.Model.extend({
          tags: (0, _emberCliMirage.hasMany)() // implicit inverse
        })
      });
    }

    _createClass(Helper, [{
      key: 'savedParentNoChildren',
      value: function savedParentNoChildren() {
        var tag = this.db.tags.insert({ name: 'Red' });

        return [this.schema.tags.find(tag.id), []];
      }
    }, {
      key: 'savedParentNewChildren',
      value: function savedParentNewChildren() {
        var tag = this.schema.tags.create({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.tags = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'savedParentSavedChildren',
      value: function savedParentSavedChildren() {
        var schema = this.schema;

        schema.db.tags.insert([{ id: '1', name: 'Red', tagIds: ['2', '3'] }, { id: '2', name: 'Blue', tagIds: ['1'] }, { id: '3', name: 'Green', tagIds: ['1'] }]);

        return [schema.tags.find(1), [schema.tags.find(2), schema.tags.find(3)]];
      }
    }, {
      key: 'savedParentMixedChildren',
      value: function savedParentMixedChildren() {
        this.schema.db.tags.insert([{ id: '1', name: 'Red', tagIds: ['2'] }, { id: '2', name: 'Blue', tagIds: ['1'] }]);
        var tag = this.schema.tags.find(1);
        var blueTag = this.schema.tags.find(2);
        var greenTag = this.schema.tags['new']({ name: 'Green' });

        tag.tags = [blueTag, greenTag];

        return [tag, [blueTag, greenTag]];
      }
    }, {
      key: 'newParentNoChildren',
      value: function newParentNoChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });

        return [tag, []];
      }
    }, {
      key: 'newParentNewChildren',
      value: function newParentNewChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.tags = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentSavedChildren',
      value: function newParentSavedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags.create({ name: 'Green' });

        tag.tags = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentMixedChildren',
      value: function newParentMixedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.tags = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }

      // Unassociated child models, used for setting tests
    }, {
      key: 'savedChild',
      value: function savedChild() {
        var insertedTag = this.db.tags.insert({ name: 'Blue' });

        return this.schema.tags.find(insertedTag.id);
      }
    }, {
      key: 'newChild',
      value: function newChild() {
        return this.schema.tags['new']({ name: 'Blue' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedParentNoChildren', 'savedParentNewChildren', 'savedParentMixedChildren', 'savedParentSavedChildren', 'newParentNoChildren', 'newParentNewChildren', 'newParentSavedChildren', 'newParentMixedChildren'];
  exports.states = states;
});
define('dummy/tests/integration/orm/has-many/3-reflexive/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/3-reflexive/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/3-reflexive/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/accessor-test', ['exports', 'dummy/tests/integration/orm/has-many/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Reflexive | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany3Reflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var tags = _helper$state2[1];

      assert.equal(tag.tags.models.length, tags.length, 'the parent has the correct number of children');
      assert.equal(tag.tagIds.length, tags.length, 'the parent has the correct number of children ids');

      tags.forEach(function (t, i) {
        assert.deepEqual(tag.tags.models[i], t, 'each child is in parent.children array');

        if (t.isSaved()) {
          assert.ok(tag.tagIds.indexOf(t.id) > -1, 'each saved child id is in parent.childrenIds array');
        }

        // Check the inverse
        assert.ok(t.tags.includes(tag));
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/3-reflexive/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/3-reflexive/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/association-create-test', ['exports', 'dummy/tests/integration/orm/has-many/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Reflexive | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany3Reflexive_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmHasMany3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.tags.models.length;

      var orangeTag = tag.createTag({ name: 'Orange' });

      assert.ok(orangeTag.id, 'the child was persisted');
      assert.equal(tag.tags.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.tags.includes(orangeTag), 'the model was added to tag.tags');
      assert.ok(tag.tagIds.indexOf(orangeTag.id) > -1, 'the id was added to the fks array');
      assert.ok(tag.attrs.tagIds.indexOf(orangeTag.id) > -1, 'fks were persisted');
      assert.ok(orangeTag.tags.includes(tag), 'the inverse was set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/3-reflexive/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/3-reflexive/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/association-new-test', ['exports', 'dummy/tests/integration/orm/has-many/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Reflexive | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany3Reflexive_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmHasMany3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.tags.models.length;

      var blueTag = tag.newTag({ name: 'Blue' });

      assert.ok(!blueTag.id, 'the child was not persisted');
      assert.equal(tag.tags.models.length, initialCount + 1);
      assert.equal(blueTag.tags.models.length, 1, 'the inverse was set');

      blueTag.save();

      assert.deepEqual(blueTag.attrs, { id: blueTag.id, name: 'Blue', tagIds: [tag.id] }, 'the child was persisted');
      assert.equal(tag.tags.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.tags.includes(blueTag), 'the model was added to tag.tags');
      assert.ok(tag.tagIds.indexOf(blueTag.id) > -1, 'the id was added to the fks array');
      assert.ok(blueTag.tags.includes(tag), 'the inverse was set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/3-reflexive/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/3-reflexive/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/has-many/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Reflexive | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany3Reflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to include a saved child via childIds', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var originalTags = _helper$state2[1];

      var savedTag = this.helper.savedChild();

      tag.tagIds = [savedTag.id];

      assert.deepEqual(tag.tags.models[0].attrs, savedTag.attrs);
      assert.deepEqual(tag.tagIds, [savedTag.id]);

      tag.save();
      savedTag.reload();

      assert.deepEqual(savedTag.tags.models[0].attrs, tag.attrs, 'the inverse was set');
      originalTags.forEach(function (originalTag) {
        if (originalTag.isSaved()) {
          originalTag.reload();
          assert.notOk(originalTag.tags.includes(tag), 'old inverses were cleared');
        }
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null childIds', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var tag = _helper$state32[0];
      var originalTags = _helper$state32[1];

      tag.tagIds = null;

      assert.deepEqual(tag.tags.models, []);
      assert.deepEqual(tag.tagIds, []);

      tag.save();
      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.tags.includes(tag), 'old inverses were cleared');
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/3-reflexive/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/3-reflexive/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/association-set-test', ['exports', 'dummy/tests/integration/orm/has-many/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Reflexive | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany3Reflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmHasMany3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a list of saved children', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var originalTags = _helper$state2[1];

      var savedTag = this.helper.savedChild();

      tag.tags = [savedTag];

      assert.ok(tag.tags.includes(savedTag));
      assert.equal(tag.tagIds[0], savedTag.id);
      assert.ok(savedTag.tags.includes(tag), 'the inverse was set');

      tag.save();

      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.tags.includes(tag), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var tag = _helper$state32[0];
      var originalTags = _helper$state32[1];

      var newTag = this.helper.newChild();

      tag.tags = [newTag];

      assert.ok(tag.tags.includes(newTag));
      assert.equal(tag.tagIds[0], undefined);
      assert.ok(newTag.tags.includes(tag), 'the inverse was set');

      tag.save();

      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.tags.includes(tag), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 2);

      var tag = _helper$state42[0];
      var originalTags = _helper$state42[1];

      tag.tags = [];

      assert.deepEqual(tag.tagIds, []);
      assert.equal(tag.tags.models.length, 0);

      tag.save();
      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.tags.includes(tag), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state5 = this.helper[state]();

      var _helper$state52 = _slicedToArray(_helper$state5, 2);

      var tag = _helper$state52[0];
      var originalTags = _helper$state52[1];

      tag.tags = null;

      assert.deepEqual(tag.tagIds, []);
      assert.equal(tag.tags.models.length, 0);

      tag.save();
      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.tags.includes(tag), 'old inverses were cleared');
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/3-reflexive/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/3-reflexive/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/create-test', ['exports', 'dummy/tests/integration/orm/has-many/3-reflexive/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany3Reflexive_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Reflexive | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany3Reflexive_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      tagIds: [tagA.id]
    });

    tagA.reload();

    assert.deepEqual(tagA.tagIds, [tagB.id]);
    assert.deepEqual(tagB.tagIds, [tagA.id], 'the inverse was set');
    assert.deepEqual(tagA.attrs.tagIds, [tagB.id], 'the ids were persisted');
    assert.deepEqual(tagB.attrs.tagIds, [tagA.id], 'the inverse ids were persisted');
    assert.deepEqual(tagA.tags.models[0].attrs, tagB.attrs);
    assert.deepEqual(tagB.tags.models[0].attrs, tagA.attrs, 'the inverse was set');
    assert.equal(this.helper.db.tags.length, 2);
    assert.deepEqual(this.helper.db.tags[0], { id: '1', tagIds: ['2'] });
    assert.deepEqual(this.helper.db.tags[1], { id: '2', tagIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in an array of models', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      tags: [tagA]
    });

    tagA.reload();

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagA.tagIds, [tagB.id], 'the inverse was set');
    assert.deepEqual(tagA.attrs.tagIds, [tagB.id], 'the ids were persisted');
    assert.deepEqual(tagB.attrs.tagIds, [tagA.id], 'the inverse was set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it sets up associations correctly when passing in a collection', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      tags: schema.tags.all()
    });

    tagA.reload();

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagA.tagIds, [tagB.id], 'the inverse was set');
    assert.deepEqual(tagB.attrs.tagIds, [tagA.id]);
    assert.deepEqual(tagA.attrs.tagIds, [tagB.id], 'the inverse was set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if an array of models is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foos: [schema.create('foo')]
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.foos.create();
    schema.foos.create();

    assert.throws(function () {
      schema.tags.create({
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/3-reflexive/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/3-reflexive/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/delete-test', ['exports', 'dummy/tests/integration/orm/has-many/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany3Reflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Reflexive | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany3Reflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany3Reflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting children updates the parent\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var tags = _helper$state2[1];

      if (tags && tags.length) {
        tags.forEach(function (t) {
          return t.destroy();
        });
        tag.reload();
      }

      assert.equal(tag.tags.length, 0);
      assert.equal(tag.tagIds.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/3-reflexive/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/3-reflexive/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/new-test', ['exports', 'dummy/tests/integration/orm/has-many/3-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany3Reflexive_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Reflexive | new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany3Reflexive_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the parent accepts a saved child id', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({
      tagIds: [tagA.id]
    });

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagB.tags.models[0], tagA);
  });

  (0, _qunit.test)('the parent errors if the children ids don\'t exist', function (assert) {
    assert.throws(function () {
      this.schema.tags['new']({ tagIds: [2] });
    }, /You're instantiating a tag that has a tagIds of 2, but some of those records don't exist in the database/);
  });

  (0, _qunit.test)('the parent accepts null children foreign key', function (assert) {
    var tag = this.schema.tags['new']({ tagIds: null });

    assert.equal(tag.tags.models.length, 0);
    assert.deepEqual(tag.tagIds, []);
    assert.deepEqual(tag.attrs, { tagIds: null });
  });

  (0, _qunit.test)('the parent accepts saved children', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ tags: [tagA] });

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagB.tags.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts new children', function (assert) {
    var tagA = this.schema.tags['new']({ color: 'Red' });
    var tagB = this.schema.tags['new']({ tags: [tagA] });

    assert.deepEqual(tagB.tagIds, [undefined]);
    assert.deepEqual(tagB.tags.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts null children', function (assert) {
    var tag = this.schema.tags['new']({ tags: null });

    assert.equal(tag.tags.models.length, 0);
    assert.deepEqual(tag.tagIds, []);
    assert.deepEqual(tag.attrs, { tagIds: null });
  });

  (0, _qunit.test)('the parent accepts children and child ids', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ tags: [tagA], tagIds: [tagA.id] });

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagB.tags.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids as empty obj', function (assert) {
    var tag = this.schema.tags['new']({});

    assert.deepEqual(tag.tagIds, []);
    assert.deepEqual(tag.tags.models, []);
    assert.deepEqual(tag.attrs, { tagIds: null });
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids', function (assert) {
    var tag = this.schema.tags['new']();

    assert.deepEqual(tag.tagIds, []);
    assert.deepEqual(tag.tags.models, []);
    assert.deepEqual(tag.attrs, { tagIds: null });
  });
});
define('dummy/tests/integration/orm/has-many/3-reflexive/new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/3-reflexive/new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/3-reflexive/new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        tag: _emberCliMirage.Model.extend({
          labels: (0, _emberCliMirage.hasMany)('tag') // implicit inverse
        })
      });
    }

    _createClass(Helper, [{
      key: 'savedParentNoChildren',
      value: function savedParentNoChildren() {
        var tag = this.db.tags.insert({ name: 'Red' });

        return [this.schema.tags.find(tag.id), []];
      }
    }, {
      key: 'savedParentNewChildren',
      value: function savedParentNewChildren() {
        var tag = this.schema.tags.create({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'savedParentSavedChildren',
      value: function savedParentSavedChildren() {
        var schema = this.schema;

        schema.db.tags.insert([{ id: '1', name: 'Red', labelIds: ['2', '3'] }, { id: '2', name: 'Blue', labelIds: ['1'] }, { id: '3', name: 'Green', labelIds: ['1'] }]);

        return [schema.tags.find(1), [schema.tags.find(2), schema.tags.find(3)]];
      }
    }, {
      key: 'savedParentMixedChildren',
      value: function savedParentMixedChildren() {
        this.schema.db.tags.insert([{ id: '1', name: 'Red', labelIds: ['2'] }, { id: '2', name: 'Blue', labelIds: ['1'] }]);
        var tag = this.schema.tags.find(1);
        var blueTag = this.schema.tags.find(2);
        var greenTag = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [blueTag, greenTag];

        return [tag, [blueTag, greenTag]];
      }
    }, {
      key: 'newParentNoChildren',
      value: function newParentNoChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });

        return [tag, []];
      }
    }, {
      key: 'newParentNewChildren',
      value: function newParentNewChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentSavedChildren',
      value: function newParentSavedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags.create({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentMixedChildren',
      value: function newParentMixedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }

      // Unassociated child models, used for setting tests
    }, {
      key: 'savedChild',
      value: function savedChild() {
        var insertedTag = this.db.tags.insert({ name: 'Blue' });

        return this.schema.tags.find(insertedTag.id);
      }
    }, {
      key: 'newChild',
      value: function newChild() {
        return this.schema.tags['new']({ name: 'Blue' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedParentNoChildren', 'savedParentNewChildren', 'savedParentMixedChildren', 'savedParentSavedChildren', 'newParentNoChildren', 'newParentNewChildren', 'newParentSavedChildren', 'newParentMixedChildren'];
  exports.states = states;
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/4-named-reflexive/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/4-named-reflexive/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/accessor-test', ['exports', 'dummy/tests/integration/orm/has-many/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var tags = _helper$state2[1];

      assert.equal(tag.labels.models.length, tags.length, 'the parent has the correct number of children');
      assert.equal(tag.labelIds.length, tags.length, 'the parent has the correct number of children ids');

      tags.forEach(function (t, i) {
        assert.deepEqual(tag.labels.models[i], t, 'each child is in parent.children array');

        if (t.isSaved()) {
          assert.ok(tag.labelIds.indexOf(t.id) > -1, 'each saved child id is in parent.childrenIds array');
        }

        // Check the inverse
        assert.ok(t.labels.includes(tag));
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/4-named-reflexive/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/4-named-reflexive/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/association-create-test', ['exports', 'dummy/tests/integration/orm/has-many/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.labels.models.length;

      var orangeTag = tag.createLabel({ name: 'Orange' });

      assert.ok(orangeTag.id, 'the child was persisted');
      assert.equal(tag.labels.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.labels.includes(orangeTag), 'the model was added to tag.labels');
      assert.ok(tag.labelIds.indexOf(orangeTag.id) > -1, 'the id was added to the fks array');
      assert.ok(tag.attrs.labelIds.indexOf(orangeTag.id) > -1, 'fks were persisted');
      assert.ok(orangeTag.labels.includes(tag), 'the inverse was set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/4-named-reflexive/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/4-named-reflexive/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/association-new-test', ['exports', 'dummy/tests/integration/orm/has-many/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.labels.models.length;

      var blueTag = tag.newLabel({ name: 'Blue' });

      assert.ok(!blueTag.id, 'the child was not persisted');
      assert.equal(tag.labels.models.length, initialCount + 1);
      assert.equal(blueTag.labels.models.length, 1, 'the inverse was set');

      blueTag.save();

      assert.deepEqual(blueTag.attrs, { id: blueTag.id, name: 'Blue', labelIds: [tag.id] }, 'the child was persisted');
      assert.equal(tag.labels.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.labels.includes(blueTag), 'the model was added to tag.labels');
      assert.ok(tag.labelIds.indexOf(blueTag.id) > -1, 'the id was added to the fks array');
      assert.ok(blueTag.labels.includes(tag), 'the inverse was set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/4-named-reflexive/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/4-named-reflexive/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/has-many/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to include a saved child via childIds', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var originalTags = _helper$state2[1];

      var savedTag = this.helper.savedChild();

      tag.labelIds = [savedTag.id];

      assert.deepEqual(tag.labels.models[0].attrs, savedTag.attrs);
      assert.deepEqual(tag.labelIds, [savedTag.id]);

      tag.save();
      savedTag.reload();

      assert.deepEqual(savedTag.labels.models[0].attrs, tag.attrs, 'the inverse was set');
      originalTags.forEach(function (originalTag) {
        if (originalTag.isSaved()) {
          originalTag.reload();
          assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
        }
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null childIds', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var tag = _helper$state32[0];
      var originalTags = _helper$state32[1];

      tag.labelIds = null;

      assert.deepEqual(tag.labels.models, []);
      assert.deepEqual(tag.labelIds, []);

      tag.save();
      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/4-named-reflexive/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/4-named-reflexive/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/association-set-test', ['exports', 'dummy/tests/integration/orm/has-many/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a list of saved children', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var originalTags = _helper$state2[1];

      var savedTag = this.helper.savedChild();

      tag.labels = [savedTag];

      assert.ok(tag.labels.includes(savedTag));
      assert.equal(tag.labelIds[0], savedTag.id);
      assert.ok(savedTag.labels.includes(tag), 'the inverse was set');

      tag.save();

      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var tag = _helper$state32[0];
      var originalTags = _helper$state32[1];

      var newTag = this.helper.newChild();

      tag.labels = [newTag];

      assert.ok(tag.labels.includes(newTag));
      assert.equal(tag.labelIds[0], undefined);
      assert.ok(newTag.labels.includes(tag), 'the inverse was set');

      tag.save();

      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 2);

      var tag = _helper$state42[0];
      var originalTags = _helper$state42[1];

      tag.labels = [];

      assert.deepEqual(tag.labelIds, []);
      assert.equal(tag.labels.models.length, 0);

      tag.save();
      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state5 = this.helper[state]();

      var _helper$state52 = _slicedToArray(_helper$state5, 2);

      var tag = _helper$state52[0];
      var originalTags = _helper$state52[1];

      tag.labels = null;

      assert.deepEqual(tag.labelIds, []);
      assert.equal(tag.labels.models.length, 0);

      tag.save();
      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/4-named-reflexive/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/4-named-reflexive/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/create-test', ['exports', 'dummy/tests/integration/orm/has-many/4-named-reflexive/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      labelIds: [tagA.id]
    });

    tagA.reload();

    assert.deepEqual(tagA.labelIds, [tagB.id]);
    assert.deepEqual(tagB.labelIds, [tagA.id], 'the inverse was set');
    assert.deepEqual(tagA.attrs.labelIds, [tagB.id], 'the ids were persisted');
    assert.deepEqual(tagB.attrs.labelIds, [tagA.id], 'the inverse ids were persisted');
    assert.deepEqual(tagA.labels.models[0].attrs, tagB.attrs);
    assert.deepEqual(tagB.labels.models[0].attrs, tagA.attrs, 'the inverse was set');
    assert.equal(this.helper.db.tags.length, 2);
    assert.deepEqual(this.helper.db.tags[0], { id: '1', labelIds: ['2'] });
    assert.deepEqual(this.helper.db.tags[1], { id: '2', labelIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in an array of models', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      labels: [tagA]
    });

    tagA.reload();

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagA.labelIds, [tagB.id], 'the inverse was set');
    assert.deepEqual(tagA.attrs.labelIds, [tagB.id], 'the ids were persisted');
    assert.deepEqual(tagB.attrs.labelIds, [tagA.id], 'the inverse was set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it sets up associations correctly when passing in a collection', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      labels: schema.tags.all()
    });

    tagA.reload();

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagA.labelIds, [tagB.id], 'the inverse was set');
    assert.deepEqual(tagB.attrs.labelIds, [tagA.id]);
    assert.deepEqual(tagA.attrs.labelIds, [tagB.id], 'the inverse was set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if an array of models is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foos: [schema.create('foo')]
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.foos.create();
    schema.foos.create();

    assert.throws(function () {
      schema.tags.create({
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/4-named-reflexive/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/4-named-reflexive/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/delete-test', ['exports', 'dummy/tests/integration/orm/has-many/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting children updates the parent\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var labels = _helper$state2[1];

      if (labels && labels.length) {
        labels.forEach(function (t) {
          return t.destroy();
        });
        tag.reload();
      }

      assert.equal(tag.labels.length, 0);
      assert.equal(tag.labelIds.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/4-named-reflexive/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/4-named-reflexive/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/new-test', ['exports', 'dummy/tests/integration/orm/has-many/4-named-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive | new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany4NamedReflexive_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the parent accepts a saved child id', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({
      labelIds: [tagA.id]
    });

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent errors if the children ids don\'t exist', function (assert) {
    assert.throws(function () {
      this.schema.tags['new']({ labelIds: [2] });
    }, /You're instantiating a tag that has a labelIds of 2, but some of those records don't exist in the database/);
  });

  (0, _qunit.test)('the parent accepts null children foreign key', function (assert) {
    var tag = this.schema.tags['new']({ labelIds: null });

    assert.equal(tag.labels.models.length, 0);
    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });

  (0, _qunit.test)('the parent accepts saved children', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ labels: [tagA] });

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts new children', function (assert) {
    var tagA = this.schema.tags['new']({ color: 'Red' });
    var tagB = this.schema.tags['new']({ labels: [tagA] });

    assert.deepEqual(tagB.labelIds, [undefined]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts null children', function (assert) {
    var tag = this.schema.tags['new']({ labels: null });

    assert.equal(tag.labels.models.length, 0);
    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });

  (0, _qunit.test)('the parent accepts children and child ids', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ labels: [tagA], labelIds: [tagA.id] });

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids as empty obj', function (assert) {
    var tag = this.schema.tags['new']({});

    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.labels.models, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids', function (assert) {
    var tag = this.schema.tags['new']();

    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.labels.models, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });
});
define('dummy/tests/integration/orm/has-many/4-named-reflexive/new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/4-named-reflexive/new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/4-named-reflexive/new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        tag: _emberCliMirage.Model.extend({
          labels: (0, _emberCliMirage.hasMany)('tag', { inverse: 'labels' }) // implicit inverse
        })
      });
    }

    _createClass(Helper, [{
      key: 'savedParentNoChildren',
      value: function savedParentNoChildren() {
        var tag = this.db.tags.insert({ name: 'Red' });

        return [this.schema.tags.find(tag.id), []];
      }
    }, {
      key: 'savedParentNewChildren',
      value: function savedParentNewChildren() {
        var tag = this.schema.tags.create({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'savedParentSavedChildren',
      value: function savedParentSavedChildren() {
        var schema = this.schema;

        schema.db.tags.insert([{ id: '1', name: 'Red', labelIds: ['2', '3'] }, { id: '2', name: 'Blue', labelIds: ['1'] }, { id: '3', name: 'Green', labelIds: ['1'] }]);

        return [schema.tags.find(1), [schema.tags.find(2), schema.tags.find(3)]];
      }
    }, {
      key: 'savedParentMixedChildren',
      value: function savedParentMixedChildren() {
        this.schema.db.tags.insert([{ id: '1', name: 'Red', labelIds: ['2'] }, { id: '2', name: 'Blue', labelIds: ['1'] }]);
        var tag = this.schema.tags.find(1);
        var blueTag = this.schema.tags.find(2);
        var greenTag = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [blueTag, greenTag];

        return [tag, [blueTag, greenTag]];
      }
    }, {
      key: 'newParentNoChildren',
      value: function newParentNoChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });

        return [tag, []];
      }
    }, {
      key: 'newParentNewChildren',
      value: function newParentNewChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentSavedChildren',
      value: function newParentSavedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags.create({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentMixedChildren',
      value: function newParentMixedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }

      // Unassociated child models, used for setting tests
    }, {
      key: 'savedChild',
      value: function savedChild() {
        var insertedTag = this.db.tags.insert({ name: 'Blue' });

        return this.schema.tags.find(insertedTag.id);
      }
    }, {
      key: 'newChild',
      value: function newChild() {
        return this.schema.tags['new']({ name: 'Blue' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedParentNoChildren', 'savedParentNewChildren', 'savedParentMixedChildren', 'savedParentSavedChildren', 'newParentNoChildren', 'newParentNewChildren', 'newParentSavedChildren', 'newParentMixedChildren'];
  exports.states = states;
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/accessor-test', ['exports', 'dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive Explicit Inverse | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var tags = _helper$state2[1];

      assert.equal(tag.labels.models.length, tags.length, 'the parent has the correct number of children');
      assert.equal(tag.labelIds.length, tags.length, 'the parent has the correct number of children ids');

      tags.forEach(function (t, i) {
        assert.deepEqual(tag.labels.models[i], t, 'each child is in parent.children array');

        if (t.isSaved()) {
          assert.ok(tag.labelIds.indexOf(t.id) > -1, 'each saved child id is in parent.childrenIds array');
        }

        // Check the inverse
        assert.ok(t.labels.includes(tag));
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/5-named-reflexive-explicit-inverse/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/5-named-reflexive-explicit-inverse/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/association-create-test', ['exports', 'dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive Explicit Inverse | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.labels.models.length;

      var orangeTag = tag.createLabel({ name: 'Orange' });

      assert.ok(orangeTag.id, 'the child was persisted');
      assert.equal(tag.labels.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.labels.includes(orangeTag), 'the model was added to tag.labels');
      assert.ok(tag.labelIds.indexOf(orangeTag.id) > -1, 'the id was added to the fks array');
      assert.ok(tag.attrs.labelIds.indexOf(orangeTag.id) > -1, 'fks were persisted');
      assert.ok(orangeTag.labels.includes(tag), 'the inverse was set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/5-named-reflexive-explicit-inverse/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/5-named-reflexive-explicit-inverse/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/association-new-test', ['exports', 'dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive Explicit Inverse | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.labels.models.length;

      var blueTag = tag.newLabel({ name: 'Blue' });

      assert.ok(!blueTag.id, 'the child was not persisted');
      assert.equal(tag.labels.models.length, initialCount + 1);
      assert.equal(blueTag.labels.models.length, 1, 'the inverse was set');

      blueTag.save();

      assert.deepEqual(blueTag.attrs, { id: blueTag.id, name: 'Blue', labelIds: [tag.id] }, 'the child was persisted');
      assert.equal(tag.labels.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.labels.includes(blueTag), 'the model was added to tag.labels');
      assert.ok(tag.labelIds.indexOf(blueTag.id) > -1, 'the id was added to the fks array');
      assert.ok(blueTag.labels.includes(tag), 'the inverse was set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/5-named-reflexive-explicit-inverse/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/5-named-reflexive-explicit-inverse/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive Explicit Inverse | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to include a saved child via childIds', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var originalTags = _helper$state2[1];

      var savedTag = this.helper.savedChild();

      tag.labelIds = [savedTag.id];

      assert.deepEqual(tag.labels.models[0].attrs, savedTag.attrs);
      assert.deepEqual(tag.labelIds, [savedTag.id]);

      tag.save();
      savedTag.reload();

      assert.deepEqual(savedTag.labels.models[0].attrs, tag.attrs, 'the inverse was set');
      originalTags.forEach(function (originalTag) {
        if (originalTag.isSaved()) {
          originalTag.reload();
          assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
        }
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null childIds', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var tag = _helper$state32[0];
      var originalTags = _helper$state32[1];

      tag.labelIds = null;

      assert.deepEqual(tag.labels.models, []);
      assert.deepEqual(tag.labelIds, []);

      tag.save();
      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/5-named-reflexive-explicit-inverse/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/5-named-reflexive-explicit-inverse/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/association-set-test', ['exports', 'dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive Explicit Inverse | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a list of saved children', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var originalTags = _helper$state2[1];

      var savedTag = this.helper.savedChild();

      tag.labels = [savedTag];

      assert.ok(tag.labels.includes(savedTag));
      assert.equal(tag.labelIds[0], savedTag.id);
      assert.ok(savedTag.labels.includes(tag), 'the inverse was set');

      tag.save();

      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var tag = _helper$state32[0];
      var originalTags = _helper$state32[1];

      var newTag = this.helper.newChild();

      tag.labels = [newTag];

      assert.ok(tag.labels.includes(newTag));
      assert.equal(tag.labelIds[0], undefined);
      assert.ok(newTag.labels.includes(tag), 'the inverse was set');

      tag.save();

      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 2);

      var tag = _helper$state42[0];
      var originalTags = _helper$state42[1];

      tag.labels = [];

      assert.deepEqual(tag.labelIds, []);
      assert.equal(tag.labels.models.length, 0);

      tag.save();
      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state5 = this.helper[state]();

      var _helper$state52 = _slicedToArray(_helper$state5, 2);

      var tag = _helper$state52[0];
      var originalTags = _helper$state52[1];

      tag.labels = null;

      assert.deepEqual(tag.labelIds, []);
      assert.equal(tag.labels.models.length, 0);

      tag.save();
      originalTags.forEach(function (originalTag) {
        originalTag.reload();
        assert.notOk(originalTag.labels.includes(tag), 'old inverses were cleared');
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/5-named-reflexive-explicit-inverse/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/5-named-reflexive-explicit-inverse/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/create-test', ['exports', 'dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive Explicit Inverse | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      labelIds: [tagA.id]
    });

    tagA.reload();

    assert.deepEqual(tagA.labelIds, [tagB.id]);
    assert.deepEqual(tagB.labelIds, [tagA.id], 'the inverse was set');
    assert.deepEqual(tagA.attrs.labelIds, [tagB.id], 'the ids were persisted');
    assert.deepEqual(tagB.attrs.labelIds, [tagA.id], 'the inverse ids were persisted');
    assert.deepEqual(tagA.labels.models[0].attrs, tagB.attrs);
    assert.deepEqual(tagB.labels.models[0].attrs, tagA.attrs, 'the inverse was set');
    assert.equal(this.helper.db.tags.length, 2);
    assert.deepEqual(this.helper.db.tags[0], { id: '1', labelIds: ['2'] });
    assert.deepEqual(this.helper.db.tags[1], { id: '2', labelIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in an array of models', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      labels: [tagA]
    });

    tagA.reload();

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagA.labelIds, [tagB.id], 'the inverse was set');
    assert.deepEqual(tagA.attrs.labelIds, [tagB.id], 'the ids were persisted');
    assert.deepEqual(tagB.attrs.labelIds, [tagA.id], 'the inverse was set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it sets up associations correctly when passing in a collection', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      labels: schema.tags.all()
    });

    tagA.reload();

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagA.labelIds, [tagB.id], 'the inverse was set');
    assert.deepEqual(tagB.attrs.labelIds, [tagA.id]);
    assert.deepEqual(tagA.attrs.labelIds, [tagB.id], 'the inverse was set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if an array of models is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foos: [schema.create('foo')]
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.foos.create();
    schema.foos.create();

    assert.throws(function () {
      schema.tags.create({
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/5-named-reflexive-explicit-inverse/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/5-named-reflexive-explicit-inverse/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/delete-test', ['exports', 'dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive Explicit Inverse | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting children updates the parent\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var labels = _helper$state2[1];

      if (labels && labels.length) {
        labels.forEach(function (t) {
          return t.destroy();
        });
        tag.reload();
      }

      assert.equal(tag.labels.length, 0);
      assert.equal(tag.labelIds.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/5-named-reflexive-explicit-inverse/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/5-named-reflexive-explicit-inverse/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/new-test', ['exports', 'dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Named Reflexive Explicit Inverse | new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany5NamedReflexiveExplicitInverse_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the parent accepts a saved child id', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({
      labelIds: [tagA.id]
    });

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent errors if the children ids don\'t exist', function (assert) {
    assert.throws(function () {
      this.schema.tags['new']({ labelIds: [2] });
    }, /You're instantiating a tag that has a labelIds of 2, but some of those records don't exist in the database/);
  });

  (0, _qunit.test)('the parent accepts null children foreign key', function (assert) {
    var tag = this.schema.tags['new']({ labelIds: null });

    assert.equal(tag.labels.models.length, 0);
    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });

  (0, _qunit.test)('the parent accepts saved children', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ labels: [tagA] });

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts new children', function (assert) {
    var tagA = this.schema.tags['new']({ color: 'Red' });
    var tagB = this.schema.tags['new']({ labels: [tagA] });

    assert.deepEqual(tagB.labelIds, [undefined]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts null children', function (assert) {
    var tag = this.schema.tags['new']({ labels: null });

    assert.equal(tag.labels.models.length, 0);
    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });

  (0, _qunit.test)('the parent accepts children and child ids', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ labels: [tagA], labelIds: [tagA.id] });

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids as empty obj', function (assert) {
    var tag = this.schema.tags['new']({});

    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.labels.models, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids', function (assert) {
    var tag = this.schema.tags['new']();

    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.labels.models, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });
});
define('dummy/tests/integration/orm/has-many/5-named-reflexive-explicit-inverse/new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/5-named-reflexive-explicit-inverse/new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/5-named-reflexive-explicit-inverse/new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        tag: _emberCliMirage.Model.extend({
          tags: (0, _emberCliMirage.hasMany)('tag', { inverse: null })
        })
      });
    }

    _createClass(Helper, [{
      key: 'savedParentNoChildren',
      value: function savedParentNoChildren() {
        var tag = this.db.tags.insert({ name: 'Red' });

        return [this.schema.tags.find(tag.id), []];
      }
    }, {
      key: 'savedParentNewChildren',
      value: function savedParentNewChildren() {
        var tag = this.schema.tags.create({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.tags = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'savedParentSavedChildren',
      value: function savedParentSavedChildren() {
        var schema = this.schema;

        schema.db.tags.insert([{ id: '1', name: 'Red', tagIds: ['2', '3'] }, { id: '2', name: 'Blue', tagIds: [] }, { id: '3', name: 'Green', tagIds: [] }]);

        return [schema.tags.find(1), [schema.tags.find(2), schema.tags.find(3)]];
      }
    }, {
      key: 'savedParentMixedChildren',
      value: function savedParentMixedChildren() {
        this.schema.db.tags.insert([{ id: '1', name: 'Red', tagIds: ['2'] }, { id: '2', name: 'Blue', tagIds: [] }]);
        var tag = this.schema.tags.find(1);
        var blueTag = this.schema.tags.find(2);
        var greenTag = this.schema.tags['new']({ name: 'Green' });

        tag.tags = [blueTag, greenTag];

        return [tag, [blueTag, greenTag]];
      }
    }, {
      key: 'newParentNoChildren',
      value: function newParentNoChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });

        return [tag, []];
      }
    }, {
      key: 'newParentNewChildren',
      value: function newParentNewChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.tags = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentSavedChildren',
      value: function newParentSavedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags.create({ name: 'Green' });

        tag.tags = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentMixedChildren',
      value: function newParentMixedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.tags = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }

      // Unassociated child models, used for setting tests
    }, {
      key: 'savedChild',
      value: function savedChild() {
        var insertedTag = this.db.tags.insert({ name: 'Blue' });

        return this.schema.tags.find(insertedTag.id);
      }
    }, {
      key: 'newChild',
      value: function newChild() {
        return this.schema.tags['new']({ name: 'Blue' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedParentNoChildren', 'savedParentNewChildren', 'savedParentMixedChildren', 'savedParentSavedChildren', 'newParentNoChildren', 'newParentNewChildren', 'newParentSavedChildren', 'newParentMixedChildren'];
  exports.states = states;
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/6-one-way-reflexive/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/6-one-way-reflexive/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/accessor-test', ['exports', 'dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | One-Way Reflexive | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var tags = _helper$state2[1];

      assert.equal(tag.tags.models.length, tags.length, 'the parent has the correct number of children');
      assert.equal(tag.tagIds.length, tags.length, 'the parent has the correct number of children ids');

      tags.forEach(function (t, i) {
        assert.deepEqual(tag.tags.models[i], t, 'each child is in parent.children array');

        if (t.isSaved()) {
          assert.ok(tag.tagIds.indexOf(t.id) > -1, 'each saved child id is in parent.childrenIds array');
        }
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/6-one-way-reflexive/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/6-one-way-reflexive/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/association-create-test', ['exports', 'dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | One-Way Reflexive | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.tags.models.length;

      var orangeTag = tag.createTag({ name: 'Orange' });

      assert.ok(orangeTag.id, 'the child was persisted');
      assert.equal(tag.tags.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.tags.includes(orangeTag), 'the model was added to tag.tags');
      assert.ok(tag.tagIds.indexOf(orangeTag.id) > -1, 'the id was added to the fks array');
      assert.ok(tag.attrs.tagIds.indexOf(orangeTag.id) > -1, 'fks were persisted');
      assert.notOk(orangeTag.tags.includes(tag), 'the inverse was not set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/6-one-way-reflexive/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/6-one-way-reflexive/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/association-new-test', ['exports', 'dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | One-Way Reflexive | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.tags.models.length;

      var blueTag = tag.newTag({ name: 'Blue' });

      assert.ok(!blueTag.id, 'the child was not persisted');
      assert.equal(tag.tags.models.length, initialCount + 1);
      assert.equal(blueTag.tags.models.length, 0, 'the inverse was not set');

      blueTag.save();

      assert.deepEqual(blueTag.attrs, { id: blueTag.id, name: 'Blue', tagIds: [] }, 'the child was persisted');
      assert.equal(tag.tags.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.tags.includes(blueTag), 'the model was added to tag.tags');
      assert.ok(tag.tagIds.indexOf(blueTag.id) > -1, 'the id was added to the fks array');
      assert.notOk(blueTag.tags.includes(tag), 'the inverse was not set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/6-one-way-reflexive/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/6-one-way-reflexive/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | One-Way Reflexive | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to include a saved child via childIds', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var savedTag = this.helper.savedChild();

      tag.tagIds = [savedTag.id];

      assert.deepEqual(tag.tags.models[0].attrs, savedTag.attrs);
      assert.deepEqual(tag.tagIds, [savedTag.id]);

      tag.save();
      savedTag.reload();

      assert.equal(savedTag.tags.models.length, 0, 'the inverse was not set');
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null childIds', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var tag = _helper$state32[0];

      tag.tagIds = null;

      assert.deepEqual(tag.tags.models, []);
      assert.deepEqual(tag.tagIds, []);

      tag.save();
    });
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/6-one-way-reflexive/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/6-one-way-reflexive/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/association-set-test', ['exports', 'dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | One-Way Reflexive | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a list of saved children', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var savedTag = this.helper.savedChild();

      tag.tags = [savedTag];

      assert.ok(tag.tags.includes(savedTag));
      assert.equal(tag.tagIds[0], savedTag.id);
      assert.notOk(savedTag.tags.includes(tag), 'the inverse was not set');

      tag.save();
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var tag = _helper$state32[0];

      var newTag = this.helper.newChild();

      tag.tags = [newTag];

      assert.ok(tag.tags.includes(newTag));
      assert.equal(tag.tagIds[0], undefined);
      assert.notOk(newTag.tags.includes(tag), 'the inverse was not set');

      tag.save();
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var tag = _helper$state42[0];

      tag.tags = [];

      assert.deepEqual(tag.tagIds, []);
      assert.equal(tag.tags.models.length, 0);

      tag.save();
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state5 = this.helper[state]();

      var _helper$state52 = _slicedToArray(_helper$state5, 1);

      var tag = _helper$state52[0];

      tag.tags = null;

      assert.deepEqual(tag.tagIds, []);
      assert.equal(tag.tags.models.length, 0);

      tag.save();
    });
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/6-one-way-reflexive/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/6-one-way-reflexive/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/create-test', ['exports', 'dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | One-Way Reflexive | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      tagIds: [tagA.id]
    });

    tagA.reload();

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagA.tagIds, [], 'the inverse was not set');
    assert.deepEqual(tagB.attrs.tagIds, [tagA.id], 'the ids were persisted');
    assert.deepEqual(tagB.tags.models[0].attrs, tagA.attrs);
    assert.equal(this.helper.db.tags.length, 2);
    assert.deepEqual(this.helper.db.tags[0], { id: '1', tagIds: null });
    assert.deepEqual(this.helper.db.tags[1], { id: '2', tagIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in an array of models', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      tags: [tagA]
    });

    tagA.reload();

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagA.tagIds, [], 'the inverse was not set');
    assert.deepEqual(tagB.attrs.tagIds, [tagA.id], 'the ids were persisted');
    assert.deepEqual(tagA.attrs.tagIds, null, 'the inverse was not set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it sets up associations correctly when passing in a collection', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      tags: schema.tags.all()
    });

    tagA.reload();

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagA.tagIds, [], 'the inverse was not set');
    assert.deepEqual(tagB.attrs.tagIds, [tagA.id]);
    assert.deepEqual(tagA.attrs.tagIds, null, 'the inverse was not set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if an array of models is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foos: [schema.create('foo')]
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.foos.create();
    schema.foos.create();

    assert.throws(function () {
      schema.tags.create({
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/6-one-way-reflexive/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/6-one-way-reflexive/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/delete-test', ['exports', 'dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | One-Way Reflexive | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting children updates the parent\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var tags = _helper$state2[1];

      if (tags && tags.length) {
        tags.forEach(function (t) {
          return t.destroy();
        });
        tag.reload();
      }

      assert.equal(tag.tags.length, 0);
      assert.equal(tag.tagIds.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/6-one-way-reflexive/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/6-one-way-reflexive/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/new-test', ['exports', 'dummy/tests/integration/orm/has-many/6-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | One-Way Reflexive | new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany6OneWayReflexive_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the parent accepts a saved child id', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({
      tagIds: [tagA.id]
    });

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagB.tags.models[0], tagA);
  });

  (0, _qunit.test)('the parent errors if the children ids don\'t exist', function (assert) {
    assert.throws(function () {
      this.schema.tags['new']({ tagIds: [2] });
    }, /You're instantiating a tag that has a tagIds of 2, but some of those records don't exist in the database/);
  });

  (0, _qunit.test)('the parent accepts null children foreign key', function (assert) {
    var tag = this.schema.tags['new']({ tagIds: null });

    assert.equal(tag.tags.models.length, 0);
    assert.deepEqual(tag.tagIds, []);
    assert.deepEqual(tag.attrs, { tagIds: null });
  });

  (0, _qunit.test)('the parent accepts saved children', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ tags: [tagA] });

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagB.tags.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts new children', function (assert) {
    var tagA = this.schema.tags['new']({ color: 'Red' });
    var tagB = this.schema.tags['new']({ tags: [tagA] });

    assert.deepEqual(tagB.tagIds, [undefined]);
    assert.deepEqual(tagB.tags.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts null children', function (assert) {
    var tag = this.schema.tags['new']({ tags: null });

    assert.equal(tag.tags.models.length, 0);
    assert.deepEqual(tag.tagIds, []);
    assert.deepEqual(tag.attrs, { tagIds: null });
  });

  (0, _qunit.test)('the parent accepts children and child ids', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ tags: [tagA], tagIds: [tagA.id] });

    assert.deepEqual(tagB.tagIds, [tagA.id]);
    assert.deepEqual(tagB.tags.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids as empty obj', function (assert) {
    var tag = this.schema.tags['new']({});

    assert.deepEqual(tag.tagIds, []);
    assert.deepEqual(tag.tags.models, []);
    assert.deepEqual(tag.attrs, { tagIds: null });
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids', function (assert) {
    var tag = this.schema.tags['new']();

    assert.deepEqual(tag.tagIds, []);
    assert.deepEqual(tag.tags.models, []);
    assert.deepEqual(tag.attrs, { tagIds: null });
  });
});
define('dummy/tests/integration/orm/has-many/6-one-way-reflexive/new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/6-one-way-reflexive/new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/6-one-way-reflexive/new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        tag: _emberCliMirage.Model.extend({
          labels: (0, _emberCliMirage.hasMany)('tag', { inverse: null })
        })
      });
    }

    _createClass(Helper, [{
      key: 'savedParentNoChildren',
      value: function savedParentNoChildren() {
        var tag = this.db.tags.insert({ name: 'Red' });

        return [this.schema.tags.find(tag.id), []];
      }
    }, {
      key: 'savedParentNewChildren',
      value: function savedParentNewChildren() {
        var tag = this.schema.tags.create({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'savedParentSavedChildren',
      value: function savedParentSavedChildren() {
        var schema = this.schema;

        schema.db.tags.insert([{ id: '1', name: 'Red', labelIds: ['2', '3'] }, { id: '2', name: 'Blue', labelIds: [] }, { id: '3', name: 'Green', labelIds: [] }]);

        return [schema.tags.find(1), [schema.tags.find(2), schema.tags.find(3)]];
      }
    }, {
      key: 'savedParentMixedChildren',
      value: function savedParentMixedChildren() {
        this.schema.db.tags.insert([{ id: '1', name: 'Red', labelIds: ['2'] }, { id: '2', name: 'Blue', labelIds: [] }]);
        var tag = this.schema.tags.find(1);
        var blueTag = this.schema.tags.find(2);
        var greenTag = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [blueTag, greenTag];

        return [tag, [blueTag, greenTag]];
      }
    }, {
      key: 'newParentNoChildren',
      value: function newParentNoChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });

        return [tag, []];
      }
    }, {
      key: 'newParentNewChildren',
      value: function newParentNewChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags['new']({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentSavedChildren',
      value: function newParentSavedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags.create({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }
    }, {
      key: 'newParentMixedChildren',
      value: function newParentMixedChildren() {
        var tag = this.schema.tags['new']({ name: 'Red' });
        var tag1 = this.schema.tags.create({ name: 'Blue' });
        var tag2 = this.schema.tags['new']({ name: 'Green' });

        tag.labels = [tag1, tag2];

        return [tag, [tag1, tag2]];
      }

      // Unassociated child models, used for setting tests
    }, {
      key: 'savedChild',
      value: function savedChild() {
        var insertedTag = this.db.tags.insert({ name: 'Blue' });

        return this.schema.tags.find(insertedTag.id);
      }
    }, {
      key: 'newChild',
      value: function newChild() {
        return this.schema.tags['new']({ name: 'Blue' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedParentNoChildren', 'savedParentNewChildren', 'savedParentMixedChildren', 'savedParentSavedChildren', 'newParentNoChildren', 'newParentNewChildren', 'newParentSavedChildren', 'newParentMixedChildren'];
  exports.states = states;
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/7-named-one-way-reflexive/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/7-named-one-way-reflexive/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/accessor-test', ['exports', 'dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named One-Way Reflexive | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var tags = _helper$state2[1];

      assert.equal(tag.labels.models.length, tags.length, 'the parent has the correct number of children');
      assert.equal(tag.labelIds.length, tags.length, 'the parent has the correct number of children ids');

      tags.forEach(function (t, i) {
        assert.deepEqual(tag.labels.models[i], t, 'each child is in parent.children array');

        if (t.isSaved()) {
          assert.ok(tag.labelIds.indexOf(t.id) > -1, 'each saved child id is in parent.childrenIds array');
        }
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/7-named-one-way-reflexive/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/7-named-one-way-reflexive/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/association-create-test', ['exports', 'dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named One-Way Reflexive | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.labels.models.length;

      var orangeTag = tag.createLabel({ name: 'Orange' });

      assert.ok(orangeTag.id, 'the child was persisted');
      assert.equal(tag.labels.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.labels.includes(orangeTag), 'the model was added to tag.labels');
      assert.ok(tag.labelIds.indexOf(orangeTag.id) > -1, 'the id was added to the fks array');
      assert.ok(tag.attrs.labelIds.indexOf(orangeTag.id) > -1, 'fks were persisted');
      assert.notOk(orangeTag.labels.includes(tag), 'the inverse was not set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/7-named-one-way-reflexive/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/7-named-one-way-reflexive/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/association-new-test', ['exports', 'dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named One-Way Reflexive | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var initialCount = tag.labels.models.length;

      var blueTag = tag.newLabel({ name: 'Blue' });

      assert.ok(!blueTag.id, 'the child was not persisted');
      assert.equal(tag.labels.models.length, initialCount + 1);
      assert.equal(blueTag.labels.models.length, 0, 'the inverse was not set');

      blueTag.save();

      assert.deepEqual(blueTag.attrs, { id: blueTag.id, name: 'Blue', labelIds: [] }, 'the child was persisted');
      assert.equal(tag.labels.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(tag.labels.includes(blueTag), 'the model was added to tag.labels');
      assert.ok(tag.labelIds.indexOf(blueTag.id) > -1, 'the id was added to the fks array');
      assert.notOk(blueTag.labels.includes(tag), 'the inverse was not set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/7-named-one-way-reflexive/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/7-named-one-way-reflexive/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named One-Way Reflexive | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to include a saved child via childIds', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var savedTag = this.helper.savedChild();

      tag.labelIds = [savedTag.id];

      assert.deepEqual(tag.labels.models[0].attrs, savedTag.attrs);
      assert.deepEqual(tag.labelIds, [savedTag.id]);

      tag.save();
      savedTag.reload();

      assert.equal(savedTag.labels.models.length, 0, 'the inverse was not set');
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null childIds', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var tag = _helper$state32[0];

      tag.labelIds = null;

      assert.deepEqual(tag.labels.models, []);
      assert.deepEqual(tag.labelIds, []);

      tag.save();
    });
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/7-named-one-way-reflexive/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/7-named-one-way-reflexive/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/association-set-test', ['exports', 'dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named One-Way Reflexive | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a list of saved children', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var tag = _helper$state2[0];

      var savedTag = this.helper.savedChild();

      tag.labels = [savedTag];

      assert.ok(tag.labels.includes(savedTag));
      assert.equal(tag.labelIds[0], savedTag.id);
      assert.notOk(savedTag.labels.includes(tag), 'the inverse was not set');

      tag.save();
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 1);

      var tag = _helper$state32[0];

      var newTag = this.helper.newChild();

      tag.labels = [newTag];

      assert.ok(tag.labels.includes(newTag));
      assert.equal(tag.labelIds[0], undefined);
      assert.notOk(newTag.labels.includes(tag), 'the inverse was not set');

      tag.save();
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 1);

      var tag = _helper$state42[0];

      tag.labels = [];

      assert.deepEqual(tag.labelIds, []);
      assert.equal(tag.labels.models.length, 0);

      tag.save();
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state5 = this.helper[state]();

      var _helper$state52 = _slicedToArray(_helper$state5, 1);

      var tag = _helper$state52[0];

      tag.labels = null;

      assert.deepEqual(tag.labelIds, []);
      assert.equal(tag.labels.models.length, 0);

      tag.save();
    });
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/7-named-one-way-reflexive/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/7-named-one-way-reflexive/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/create-test', ['exports', 'dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Named One-Way Reflexive | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      labelIds: [tagA.id]
    });

    tagA.reload();

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagA.labelIds, [], 'the inverse was not set');
    assert.deepEqual(tagB.attrs.labelIds, [tagA.id], 'the ids were persisted');
    assert.deepEqual(tagB.labels.models[0].attrs, tagA.attrs);
    assert.equal(this.helper.db.tags.length, 2);
    assert.deepEqual(this.helper.db.tags[0], { id: '1', labelIds: null });
    assert.deepEqual(this.helper.db.tags[1], { id: '2', labelIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in an array of models', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      labels: [tagA]
    });

    tagA.reload();

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagA.labelIds, [], 'the inverse was not set');
    assert.deepEqual(tagB.attrs.labelIds, [tagA.id], 'the ids were persisted');
    assert.deepEqual(tagA.attrs.labelIds, null, 'the inverse was not set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it sets up associations correctly when passing in a collection', function (assert) {
    var schema = this.helper.schema;

    var tagA = schema.tags.create();
    var tagB = schema.tags.create({
      labels: schema.tags.all()
    });

    tagA.reload();

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagA.labelIds, [], 'the inverse was not set');
    assert.deepEqual(tagB.attrs.labelIds, [tagA.id]);
    assert.deepEqual(tagA.attrs.labelIds, null, 'the inverse was not set');
    assert.equal(this.helper.db.tags.length, 2);
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if an array of models is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.tags.create({
        foos: [schema.create('foo')]
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.foos.create();
    schema.foos.create();

    assert.throws(function () {
      schema.tags.create({
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/7-named-one-way-reflexive/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/7-named-one-way-reflexive/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/delete-test', ['exports', 'dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Named One-Way Reflexive | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting children updates the parent\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var tag = _helper$state2[0];
      var labels = _helper$state2[1];

      if (labels && labels.length) {
        labels.forEach(function (t) {
          return t.destroy();
        });
        tag.reload();
      }

      assert.equal(tag.labels.length, 0);
      assert.equal(tag.labelIds.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/7-named-one-way-reflexive/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/7-named-one-way-reflexive/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/new-test', ['exports', 'dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Named One-Way Reflexive | new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany7NamedOneWayReflexive_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the parent accepts a saved child id', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({
      labelIds: [tagA.id]
    });

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent errors if the children ids don\'t exist', function (assert) {
    assert.throws(function () {
      this.schema.tags['new']({ labelIds: [2] });
    }, /You're instantiating a tag that has a labelIds of 2, but some of those records don't exist in the database/);
  });

  (0, _qunit.test)('the parent accepts null children foreign key', function (assert) {
    var tag = this.schema.tags['new']({ labelIds: null });

    assert.equal(tag.labels.models.length, 0);
    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });

  (0, _qunit.test)('the parent accepts saved children', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ labels: [tagA] });

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts new children', function (assert) {
    var tagA = this.schema.tags['new']({ color: 'Red' });
    var tagB = this.schema.tags['new']({ labels: [tagA] });

    assert.deepEqual(tagB.labelIds, [undefined]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts null children', function (assert) {
    var tag = this.schema.tags['new']({ labels: null });

    assert.equal(tag.labels.models.length, 0);
    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });

  (0, _qunit.test)('the parent accepts children and child ids', function (assert) {
    var tagA = this.helper.savedChild();
    var tagB = this.schema.tags['new']({ labels: [tagA], labelIds: [tagA.id] });

    assert.deepEqual(tagB.labelIds, [tagA.id]);
    assert.deepEqual(tagB.labels.models[0], tagA);
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids as empty obj', function (assert) {
    var tag = this.schema.tags['new']({});

    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.labels.models, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids', function (assert) {
    var tag = this.schema.tags['new']();

    assert.deepEqual(tag.labelIds, []);
    assert.deepEqual(tag.labels.models, []);
    assert.deepEqual(tag.attrs, { labelIds: null });
  });
});
define('dummy/tests/integration/orm/has-many/7-named-one-way-reflexive/new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/7-named-one-way-reflexive/new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/7-named-one-way-reflexive/new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      // implicit inverse
      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        order: _emberCliMirage.Model.extend({
          products: (0, _emberCliMirage.hasMany)()
        }),
        product: _emberCliMirage.Model.extend({
          orders: (0, _emberCliMirage.hasMany)()
        })
      });
    }

    _createClass(Helper, [{
      key: 'savedParentNoChildren',
      value: function savedParentNoChildren() {
        var order = this.db.orders.insert({ name: 'Red' });

        return [this.schema.orders.find(order.id), []];
      }
    }, {
      key: 'savedParentNewChildren',
      value: function savedParentNewChildren() {
        var order = this.schema.orders.create({ name: 'Red' });
        var product1 = this.schema.products['new']({ name: 'Blue' });
        var product2 = this.schema.products['new']({ name: 'Green' });

        order.products = [product1, product2];

        return [order, [product1, product2]];
      }
    }, {
      key: 'savedParentSavedChildren',
      value: function savedParentSavedChildren() {
        var schema = this.schema;

        schema.db.orders.insert([{ id: '1', name: 'Red', productIds: ['2', '3'] }]);
        schema.db.products.insert([{ id: '2', name: 'Blue', orderIds: ['1'] }, { id: '3', name: 'Green', orderIds: ['1'] }]);

        return [schema.orders.find(1), [schema.products.find(2), schema.products.find(3)]];
      }
    }, {
      key: 'savedParentMixedChildren',
      value: function savedParentMixedChildren() {
        this.schema.db.orders.insert([{ id: '1', name: 'Red', productIds: ['2'] }]);
        this.schema.db.products.insert([{ id: '2', name: 'Blue', orderIds: ['1'] }]);
        var order = this.schema.orders.find(1);
        var product1 = this.schema.products.find(2);
        var product2 = this.schema.products['new']({ name: 'Green' });

        order.products = [product1, product2];

        return [order, [product1, product2]];
      }
    }, {
      key: 'newParentNoChildren',
      value: function newParentNoChildren() {
        var order = this.schema.orders['new']({ name: 'Red' });

        return [order, []];
      }
    }, {
      key: 'newParentNewChildren',
      value: function newParentNewChildren() {
        var order = this.schema.orders['new']({ name: 'Red' });
        var product1 = this.schema.products['new']({ name: 'Blue' });
        var product2 = this.schema.products['new']({ name: 'Green' });

        order.products = [product1, product2];

        return [order, [product1, product2]];
      }
    }, {
      key: 'newParentSavedChildren',
      value: function newParentSavedChildren() {
        var order = this.schema.orders['new']({ name: 'Red' });
        var product1 = this.schema.products.create({ name: 'Blue' });
        var product2 = this.schema.products.create({ name: 'Green' });

        order.products = [product1, product2];

        return [order, [product1, product2]];
      }
    }, {
      key: 'newParentMixedChildren',
      value: function newParentMixedChildren() {
        var order = this.schema.orders['new']({ name: 'Red' });
        var product1 = this.schema.products.create({ name: 'Blue' });
        var product2 = this.schema.products['new']({ name: 'Green' });

        order.products = [product1, product2];

        return [order, [product1, product2]];
      }

      // Unassociated child models, used for setting tests
    }, {
      key: 'savedChild',
      value: function savedChild() {
        var insertedProduct = this.db.products.insert({ name: 'Blue' });

        return this.schema.products.find(insertedProduct.id);
      }
    }, {
      key: 'newChild',
      value: function newChild() {
        return this.schema.products['new']({ name: 'Blue' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedParentNoChildren', 'savedParentNewChildren', 'savedParentMixedChildren', 'savedParentSavedChildren', 'newParentNoChildren', 'newParentNewChildren', 'newParentSavedChildren', 'newParentMixedChildren'];
  exports.states = states;
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/8-many-to-many/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/8-many-to-many/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/accessor-test', ['exports', 'dummy/tests/integration/orm/has-many/8-many-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany8ManyToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Many to Many | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany8ManyToMany_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany8ManyToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var order = _helper$state2[0];
      var products = _helper$state2[1];

      assert.equal(order.products.models.length, products.length, 'the parent has the correct number of children');
      assert.equal(order.productIds.length, products.length, 'the parent has the correct number of children ids');

      products.forEach(function (p, i) {
        assert.deepEqual(order.products.models[i], p, 'each child is in parent.children array');

        if (p.isSaved()) {
          assert.ok(order.productIds.indexOf(p.id) > -1, 'each saved child id is in parent.childrenIds array');
        }

        // Check the inverse
        assert.ok(p.orders.includes(order));
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/8-many-to-many/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/8-many-to-many/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/association-create-test', ['exports', 'dummy/tests/integration/orm/has-many/8-many-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany8ManyToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Many to Many | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany8ManyToMany_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmHasMany8ManyToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var order = _helper$state2[0];

      var initialCount = order.products.models.length;

      var orangeProduct = order.createProduct({ name: 'Orange' });

      assert.ok(orangeProduct.id, 'the child was persisted');
      assert.equal(order.products.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(order.products.includes(orangeProduct), 'the model was added to order.products');
      assert.ok(order.productIds.indexOf(orangeProduct.id) > -1, 'the id was added to the fks array');
      assert.ok(order.attrs.productIds.indexOf(orangeProduct.id) > -1, 'fks were persisted');
      assert.ok(orangeProduct.orders.includes(order), 'the inverse was set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/8-many-to-many/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/8-many-to-many/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/association-new-test', ['exports', 'dummy/tests/integration/orm/has-many/8-many-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany8ManyToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Many to Many | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany8ManyToMany_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmHasMany8ManyToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated child', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var order = _helper$state2[0];

      var initialCount = order.products.models.length;

      var blueProduct = order.newProduct({ name: 'Blue' });

      assert.ok(!blueProduct.id, 'the child was not persisted');
      assert.equal(order.products.models.length, initialCount + 1);
      assert.equal(blueProduct.orders.models.length, 1, 'the inverse was set');

      blueProduct.save();

      assert.deepEqual(blueProduct.attrs, { id: blueProduct.id, name: 'Blue', orderIds: [order.id] }, 'the child was persisted');
      assert.equal(order.products.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(order.products.includes(blueProduct), 'the model was added to order.products');
      assert.ok(order.productIds.indexOf(blueProduct.id) > -1, 'the id was added to the fks array');
      assert.ok(blueProduct.orders.includes(order), 'the inverse was set');
    });
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/8-many-to-many/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/8-many-to-many/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/has-many/8-many-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany8ManyToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Many to Many | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany8ManyToMany_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany8ManyToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to include a saved child via childIds', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var order = _helper$state2[0];
      var originalProducts = _helper$state2[1];

      var savedProduct = this.helper.savedChild();

      order.productIds = [savedProduct.id];

      assert.deepEqual(order.products.models[0].attrs, savedProduct.attrs);
      assert.deepEqual(order.productIds, [savedProduct.id]);

      order.save();
      savedProduct.reload();

      assert.deepEqual(savedProduct.orders.models[0].attrs, order.attrs, 'the inverse was set');
      originalProducts.forEach(function (p) {
        if (p.isSaved()) {
          p.reload();
          assert.notOk(p.orders.includes(order), 'old inverses were cleared');
        }
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null childIds', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var order = _helper$state32[0];
      var originalProducts = _helper$state32[1];

      order.productIds = null;

      assert.deepEqual(order.products.models, []);
      assert.deepEqual(order.productIds, []);

      order.save();

      originalProducts.forEach(function (p) {
        p.reload();
        assert.notOk(p.orders.includes(order), 'old inverses were cleared');
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/8-many-to-many/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/8-many-to-many/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/association-set-test', ['exports', 'dummy/tests/integration/orm/has-many/8-many-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany8ManyToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Many to Many | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany8ManyToMany_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmHasMany8ManyToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a list of saved children', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var order = _helper$state2[0];
      var originalProducts = _helper$state2[1];

      var savedProduct = this.helper.savedChild();

      order.products = [savedProduct];

      assert.ok(order.products.includes(savedProduct));
      assert.equal(order.productIds[0], savedProduct.id);
      assert.ok(savedProduct.orders.includes(order), 'the inverse was set');

      order.save();

      originalProducts.forEach(function (p) {
        p.reload();
        assert.notOk(p.orders.includes(order), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var order = _helper$state32[0];
      var originalProducts = _helper$state32[1];

      var newProduct = this.helper.newChild();

      order.products = [newProduct];

      assert.ok(order.products.includes(newProduct));
      assert.equal(order.productIds[0], undefined);
      assert.ok(newProduct.orders.includes(order), 'the inverse was set');

      order.save();

      originalProducts.forEach(function (p) {
        p.reload();
        assert.notOk(p.orders.includes(order), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 2);

      var order = _helper$state42[0];
      var originalProducts = _helper$state42[1];

      order.products = [];

      assert.deepEqual(order.productIds, []);
      assert.equal(order.products.models.length, 0);

      order.save();
      originalProducts.forEach(function (p) {
        p.reload();
        assert.notOk(p.orders.includes(order), 'old inverses were cleared');
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state5 = this.helper[state]();

      var _helper$state52 = _slicedToArray(_helper$state5, 2);

      var order = _helper$state52[0];
      var originalProducts = _helper$state52[1];

      order.products = null;

      assert.deepEqual(order.productIds, []);
      assert.equal(order.products.models.length, 0);

      order.save();

      originalProducts.forEach(function (p) {
        p.reload();
        assert.notOk(p.orders.includes(order), 'old inverses were cleared');
      });
    });
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/8-many-to-many/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/8-many-to-many/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/create-test', ['exports', 'dummy/tests/integration/orm/has-many/8-many-to-many/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany8ManyToMany_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Many to Many | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany8ManyToMany_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var product = schema.products.create();
    var order = schema.orders.create({
      productIds: [product.id]
    });

    product.reload();

    assert.deepEqual(order.productIds, [product.id]);
    assert.deepEqual(product.orderIds, [order.id], 'the inverse was set');
    assert.deepEqual(order.attrs.productIds, [product.id], 'the ids were persisted');
    assert.deepEqual(product.attrs.orderIds, [order.id], 'the inverse ids were persisted');
    assert.deepEqual(order.products.models[0].attrs, product.attrs);
    assert.deepEqual(product.orders.models[0].attrs, order.attrs, 'the inverse was set');
    assert.equal(this.helper.db.orders.length, 1);
    assert.equal(this.helper.db.products.length, 1);
    assert.deepEqual(this.helper.db.orders[0], { id: '1', productIds: ['1'] });
    assert.deepEqual(this.helper.db.products[0], { id: '1', orderIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in an array of models', function (assert) {
    var schema = this.helper.schema;

    var product = schema.products.create();
    var order = schema.orders.create({
      products: [product]
    });

    product.reload();

    assert.deepEqual(order.productIds, [product.id]);
    assert.deepEqual(product.orderIds, [order.id], 'the inverse was set');
    assert.deepEqual(order.attrs.productIds, [product.id], 'the ids were persisted');
    assert.deepEqual(product.attrs.orderIds, [order.id], 'the inverse was set');
    assert.equal(this.helper.db.orders.length, 1);
    assert.equal(this.helper.db.products.length, 1);
  });

  (0, _qunit.test)('it sets up associations correctly when passing in a collection', function (assert) {
    var schema = this.helper.schema;

    var product = schema.products.create();
    var order = schema.orders.create({
      products: schema.products.all()
    });

    product.reload();

    assert.deepEqual(order.productIds, [product.id]);
    assert.deepEqual(product.orderIds, [order.id], 'the inverse was set');
    assert.deepEqual(order.attrs.productIds, [product.id]);
    assert.deepEqual(product.attrs.orderIds, [order.id], 'the inverse was set');
    assert.equal(this.helper.db.orders.length, 1);
    assert.equal(this.helper.db.products.length, 1);
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.orders.create({
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if an array of models is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.orders.create({
        foos: [schema.create('foo')]
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.foos.create();
    schema.foos.create();

    assert.throws(function () {
      schema.orders.create({
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/8-many-to-many/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/8-many-to-many/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/delete-test', ['exports', 'dummy/tests/integration/orm/has-many/8-many-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany8ManyToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Has Many | Many to Many | delete', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany8ManyToMany_helper['default']();
    }
  });

  _dummyTestsIntegrationOrmHasMany8ManyToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('deleting children updates the parent\'s foreign key for a ' + state, function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var order = _helper$state2[0];
      var products = _helper$state2[1];

      if (products && products.length) {
        products.forEach(function (t) {
          return t.destroy();
        });
        order.reload();
      }

      assert.equal(order.products.length, 0);
      assert.equal(order.productIds.length, 0);
    });
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/delete-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/8-many-to-many/delete-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/8-many-to-many/delete-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/new-test', ['exports', 'dummy/tests/integration/orm/has-many/8-many-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmHasMany8ManyToMany_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Has Many | Many to Many | new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmHasMany8ManyToMany_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the parent accepts a saved child id', function (assert) {
    var product = this.helper.savedChild();
    var order = this.schema.orders['new']({
      productIds: [product.id]
    });

    assert.deepEqual(order.productIds, [product.id]);
    assert.deepEqual(order.products.models[0], product);
  });

  (0, _qunit.test)('the parent errors if the children ids don\'t exist', function (assert) {
    assert.throws(function () {
      this.schema.orders['new']({ productIds: [2] });
    }, /You're instantiating a order that has a productIds of 2, but some of those records don't exist in the database/);
  });

  (0, _qunit.test)('the parent accepts null children foreign key', function (assert) {
    var order = this.schema.orders['new']({ productIds: null });

    assert.equal(order.products.models.length, 0);
    assert.deepEqual(order.productIds, []);
    assert.deepEqual(order.attrs, { productIds: null });
  });

  (0, _qunit.test)('the parent accepts saved children', function (assert) {
    var product = this.helper.savedChild();
    var order = this.schema.orders['new']({ products: [product] });

    assert.deepEqual(order.productIds, [product.id]);
    assert.deepEqual(order.products.models[0], product);
  });

  (0, _qunit.test)('the parent accepts new children', function (assert) {
    var product = this.schema.products['new']({ color: 'Red' });
    var order = this.schema.orders['new']({ products: [product] });

    assert.deepEqual(order.productIds, [undefined]);
    assert.deepEqual(order.products.models[0], product);
  });

  (0, _qunit.test)('the parent accepts null children', function (assert) {
    var order = this.schema.orders['new']({ products: null });

    assert.equal(order.products.models.length, 0);
    assert.deepEqual(order.productIds, []);
    assert.deepEqual(order.attrs, { productIds: null });
  });

  (0, _qunit.test)('the parent accepts children and child ids', function (assert) {
    var product = this.helper.savedChild();
    var order = this.schema.orders['new']({ products: [product], productIds: [product.id] });

    assert.deepEqual(order.productIds, [product.id]);
    assert.deepEqual(order.products.models[0], product);
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids as empty obj', function (assert) {
    var order = this.schema.orders['new']({});

    assert.deepEqual(order.productIds, []);
    assert.deepEqual(order.products.models, []);
    assert.deepEqual(order.attrs, { productIds: null });
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids', function (assert) {
    var order = this.schema.orders['new']();

    assert.deepEqual(order.productIds, []);
    assert.deepEqual(order.products.models, []);
    assert.deepEqual(order.attrs, { productIds: null });
  });
});
define('dummy/tests/integration/orm/has-many/8-many-to-many/new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/has-many/8-many-to-many/new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/has-many/8-many-to-many/new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          posts: (0, _emberCliMirage.hasMany)()
        }),
        post: _emberCliMirage.Model.extend({
          user: (0, _emberCliMirage.belongsTo)()
        })
      });
    }

    _createClass(Helper, [{
      key: 'savedParentNoChildren',
      value: function savedParentNoChildren() {
        var user = this.db.users.insert({ name: 'Link' });

        return [this.schema.users.find(user.id), []];
      }
    }, {
      key: 'savedParentNewChildren',
      value: function savedParentNewChildren() {
        var user = this.schema.users.create({ name: 'Link' });
        var post1 = this.schema.posts['new']({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'savedParentSavedChildren',
      value: function savedParentSavedChildren() {
        var schema = this.schema;

        schema.db.loadData({
          users: [{ id: '1', name: 'Link', postIds: ['1', '2'] }],
          posts: [{ id: '1', title: 'Lorem', userId: '1' }, { id: '2', title: 'Ipsum', userId: '1' }]
        });

        return [schema.users.find(1), [schema.posts.find(1), schema.posts.find(2)]];
      }
    }, {
      key: 'savedParentMixedChildren',
      value: function savedParentMixedChildren() {
        this.schema.db.loadData({
          users: [{ id: '1', name: 'Link', postIds: ['1'] }],
          posts: [{ id: '1', title: 'Lorem', userId: '1' }]
        });
        var user = this.schema.users.find(1);
        var post1 = this.schema.posts.find(1);
        var post2 = this.schema.posts['new']({ name: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'newParentNoChildren',
      value: function newParentNoChildren() {
        var user = this.schema.users['new']({ name: 'Link' });

        return [user, []];
      }
    }, {
      key: 'newParentNewChildren',
      value: function newParentNewChildren() {
        var user = this.schema.users['new']({ name: 'Link' });
        var post1 = this.schema.posts['new']({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'newParentSavedChildren',
      value: function newParentSavedChildren() {
        var user = this.schema.users['new']({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts.create({ title: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }
    }, {
      key: 'newParentMixedChildren',
      value: function newParentMixedChildren() {
        var user = this.schema.users['new']({ name: 'Link' });
        var post1 = this.schema.posts.create({ title: 'Lorem' });
        var post2 = this.schema.posts['new']({ title: 'Ipsum' });

        user.posts = [post1, post2];

        return [user, [post1, post2]];
      }

      // Unassociated child models, used for setting tests
    }, {
      key: 'savedChild',
      value: function savedChild() {
        var insertedPost = this.db.posts.insert({ title: 'Lorem' });

        return this.schema.posts.find(insertedPost.id);
      }
    }, {
      key: 'newChild',
      value: function newChild() {
        return this.schema.posts['new']({ title: 'Lorem' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedParentNoChildren', 'savedParentNewChildren', 'savedParentSavedChildren', 'savedParentMixedChildren', 'newParentNoChildren', 'newParentNewChildren', 'newParentSavedChildren', 'newParentMixedChildren'];
  exports.states = states;
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/1-one-to-many/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/1-one-to-many/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/accessor-test', ['exports', 'dummy/tests/integration/orm/mixed/1-one-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed1OneToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | One To Many | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed1OneToMany_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmMixed1OneToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var posts = _helper$state2[1];

      assert.equal(user.posts.models.length, posts.length, 'the parent has the correct number of children');
      assert.equal(user.postIds.length, posts.length, 'the parent has the correct number of children ids');

      posts.forEach(function (post, i) {
        assert.deepEqual(user.posts.models[i], posts[i], 'each child is in parent.children array');

        if (post.isSaved()) {
          assert.ok(user.postIds.indexOf(post.id) > -1, 'each saved child id is in parent.childrenIds array');
        }

        // Check the inverse
        assert.deepEqual(post.user.attrs, user.attrs);
        assert.deepEqual(post.userId, user.id);
      });
    });
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/1-one-to-many/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/1-one-to-many/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/association-create-test', ['exports', 'dummy/tests/integration/orm/mixed/1-one-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed1OneToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | One To Many | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed1OneToMany_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmMixed1OneToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var initialCount = user.posts.models.length;

      var post = user.createPost({ title: 'Lorem ipsum' });

      assert.ok(post.id, 'the child was persisted');
      assert.equal(user.posts.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(user.posts.includes(post), 'the model was added to user.posts');
      assert.ok(user.postIds.indexOf(post.id) > -1, 'the id was added to the fks array');
      assert.ok(user.attrs.postIds.indexOf(post.id) > -1, 'fks were persisted');

      // Check the inverse
      assert.deepEqual(post.user.attrs, user.attrs);
      assert.deepEqual(post.userId, user.id);
    });
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/1-one-to-many/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/1-one-to-many/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/association-new-test', ['exports', 'dummy/tests/integration/orm/mixed/1-one-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed1OneToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | One To Many | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed1OneToMany_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmMixed1OneToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 1);

      var user = _helper$state2[0];

      var initialCount = user.posts.models.length;

      var post = user.newPost({ title: 'Lorem ipsum' });

      assert.ok(!post.id, 'the child was not persisted');
      assert.equal(user.posts.models.length, initialCount + 1);

      post.save();

      assert.deepEqual(post.attrs, { id: post.id, title: 'Lorem ipsum', userId: user.id }, 'the child was persisted');
      assert.equal(user.posts.models.length, initialCount + 1, 'the collection size was increased');
      assert.ok(user.posts.includes(post), 'the model was added to user.posts');
      assert.ok(user.postIds.indexOf(post.id) > -1, 'the id was added to the fks array');
    });
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/1-one-to-many/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/1-one-to-many/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/mixed/1-one-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed1OneToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | One To Many | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed1OneToMany_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmMixed1OneToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var originalPosts = _helper$state2[1];

      var savedPost = this.helper.savedChild();

      user.postIds = [savedPost.id];

      assert.ok(user.posts.includes(savedPost));
      assert.deepEqual(user.postIds, [savedPost.id]);

      user.save();
      savedPost.reload();

      // Check the inverse
      assert.deepEqual(savedPost.user.attrs, user.attrs);
      assert.equal(savedPost.userId, user.id);

      // Check old associates
      originalPosts.forEach(function (post) {
        if (post.isSaved()) {
          post.reload();
          assert.equal(post.user, null);
        }
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var user = _helper$state32[0];
      var originalPosts = _helper$state32[1];

      user.postIds = null;

      assert.deepEqual(user.posts.models, []);
      assert.deepEqual(user.postIds, []);

      user.save();

      // Check old associates
      originalPosts.forEach(function (post) {
        if (post.isSaved()) {
          post.reload();
          assert.equal(post.user, null);
        }
      });
    });
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/1-one-to-many/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/1-one-to-many/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/association-set-test', ['exports', 'dummy/tests/integration/orm/mixed/1-one-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed1OneToMany_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | One To Many | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed1OneToMany_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmMixed1OneToMany_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a list of saved children', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var user = _helper$state2[0];
      var originalPosts = _helper$state2[1];

      var savedPost = this.helper.savedChild();

      user.posts = [savedPost];

      assert.ok(user.posts.includes(savedPost));
      assert.ok(user.postIds.indexOf(savedPost.id) > -1);

      user.save();

      originalPosts.forEach(function (post) {
        if (post.isSaved()) {
          post.reload();
          assert.equal(post.user, null);
        }
      });
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var user = _helper$state32[0];
      var originalPosts = _helper$state32[1];

      var newPost = this.helper.newChild();

      user.posts = [newPost];

      assert.deepEqual(user.postIds, [undefined]);
      assert.ok(user.posts.includes(newPost));

      user.save();

      originalPosts.forEach(function (post) {
        if (post.isSaved()) {
          post.reload();
          assert.equal(post.user, null);
        }
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 2);

      var user = _helper$state42[0];
      var originalPosts = _helper$state42[1];

      user.posts = [];

      assert.deepEqual(user.postIds, []);
      assert.equal(user.posts.models.length, 0);

      user.save();

      originalPosts.forEach(function (post) {
        if (post.isSaved()) {
          post.reload();
          assert.equal(post.user, null);
        }
      });
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via an empty list', function (assert) {
      var _helper$state5 = this.helper[state]();

      var _helper$state52 = _slicedToArray(_helper$state5, 2);

      var user = _helper$state52[0];
      var originalPosts = _helper$state52[1];

      user.posts = null;

      assert.deepEqual(user.postIds, []);
      assert.equal(user.posts.models.length, 0);

      user.save();

      originalPosts.forEach(function (post) {
        if (post.isSaved()) {
          post.reload();
          assert.equal(post.user, null);
        }
      });
    });
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/1-one-to-many/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/1-one-to-many/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/create-test', ['exports', 'dummy/tests/integration/orm/mixed/1-one-to-many/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed1OneToMany_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Mixed | One To Many | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed1OneToMany_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var post = this.helper.schema.create('post');
    var user = this.helper.schema.create('user', {
      postIds: [post.id]
    });
    post.reload();

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.attrs.postIds, [post.id], 'the ids were persisted');
    assert.ok(user.posts.includes(post));
    assert.deepEqual(post.user.attrs, user.attrs);

    var db = this.helper.db;

    assert.equal(db.posts.length, 1);
    assert.deepEqual(db.posts[0], { id: '1', userId: '1' });
    assert.equal(db.users.length, 1);
    assert.deepEqual(db.users[0], { id: '1', postIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in an array of models', function (assert) {
    var post = this.helper.schema.create('post');
    var user = this.helper.schema.create('user', {
      posts: [post]
    });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.attrs.postIds, [post.id], 'the ids were persisted');
    assert.ok(user.posts.includes(post));
    assert.deepEqual(post.user.attrs, user.attrs);

    var db = this.helper.db;

    assert.equal(db.posts.length, 1);
    assert.deepEqual(db.posts[0], { id: '1', userId: '1' });
    assert.equal(db.users.length, 1);
    assert.deepEqual(db.users[0], { id: '1', postIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in a collection', function (assert) {
    var post = this.helper.schema.create('post');
    var user = this.helper.schema.create('user', {
      posts: this.helper.schema.posts.all()
    });
    post.reload();

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.attrs.postIds, [post.id], 'the ids were persisted');
    assert.ok(user.posts.includes(post));

    var db = this.helper.db;

    assert.equal(db.posts.length, 1);
    assert.deepEqual(db.posts[0], { id: '1', userId: '1' });
    assert.equal(db.users.length, 1);
    assert.deepEqual(db.users[0], { id: '1', postIds: ['1'] });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if an array of models is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('user', {
        foos: [schema.create('foo')]
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('post', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/1-one-to-many/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/1-one-to-many/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/instantiating-test', ['exports', 'dummy/tests/integration/orm/mixed/1-one-to-many/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed1OneToMany_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Mixed | One To Many | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed1OneToMany_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the parent accepts a saved child id', function (assert) {
    var post = this.helper.savedChild();
    var user = this.schema.users['new']({
      postIds: [post.id]
    });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.posts.models[0], post);
  });

  (0, _qunit.test)('the parent errors if the children ids don\'t exist', function (assert) {
    assert.throws(function () {
      this.schema.users['new']({ postIds: [2] });
    }, /You're instantiating a user that has a postIds of 2, but some of those records don't exist in the database/);
  });

  (0, _qunit.test)('the parent accepts null children foreign key', function (assert) {
    var user = this.schema.users['new']({ postIds: null });

    assert.equal(user.posts.models.length, 0);
    assert.deepEqual(user.postIds, []);
    assert.deepEqual(user.attrs, { postIds: null });
  });

  (0, _qunit.test)('the parent accepts saved children', function (assert) {
    var post = this.helper.savedChild();
    var user = this.schema.users['new']({ posts: [post] });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.posts.models[0], post);
  });

  (0, _qunit.test)('the parent accepts new children', function (assert) {
    var post = this.schema.posts['new']({ title: 'Lorem' });
    var user = this.schema.users['new']({ posts: [post] });

    assert.deepEqual(user.postIds, [undefined]);
    assert.deepEqual(user.posts.models[0], post);
  });

  (0, _qunit.test)('the parent accepts null children', function (assert) {
    var user = this.schema.users['new']({ posts: null });

    assert.equal(user.posts.models.length, 0);
    assert.deepEqual(user.postIds, []);
    assert.deepEqual(user.attrs, { postIds: null });
  });

  (0, _qunit.test)('the parent accepts children and child ids', function (assert) {
    var post = this.helper.savedChild();
    var user = this.schema.users['new']({ posts: [post], postIds: [post.id] });

    assert.deepEqual(user.postIds, [post.id]);
    assert.deepEqual(user.posts.models[0], post);
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids as empty obj', function (assert) {
    var user = this.schema.users['new']({});

    assert.deepEqual(user.postIds, []);
    assert.deepEqual(user.posts.models, []);
    assert.deepEqual(user.attrs, { postIds: null });
  });

  (0, _qunit.test)('the parent accepts no reference to children or child ids', function (assert) {
    var user = this.schema.users['new']();

    assert.deepEqual(user.postIds, []);
    assert.deepEqual(user.posts.models, []);
    assert.deepEqual(user.attrs, { postIds: null });
  });
});
define('dummy/tests/integration/orm/mixed/1-one-to-many/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/1-one-to-many/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/1-one-to-many/instantiating-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/_helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb) {
  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  /*
    A model with a hasMany association can be in eight states
    with respect to its association. This helper class
    returns a parent (and its children) in these various states.
  
    The return value is an array of the form
  
      [ parent, [child1, child2...] ]
  
    where the children array may be empty.
  */

  var Helper = (function () {
    function Helper() {
      _classCallCheck(this, Helper);

      this.db = new _emberCliMirageDb['default']();

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirage.Model.extend({
          posts: (0, _emberCliMirage.hasMany)()
        }),
        post: _emberCliMirage.Model.extend({
          user: (0, _emberCliMirage.belongsTo)()
        })
      });
    }

    _createClass(Helper, [{
      key: 'savedChildNoParent',
      value: function savedChildNoParent() {
        var post = this.db.posts.insert({ title: 'Lorem' });

        return [this.schema.posts.find(post.id), null];
      }
    }, {
      key: 'savedChildNewParent',
      value: function savedChildNewParent() {
        var post = this.schema.posts.create({ title: 'Lorem' });
        var user = this.schema.users['new']({ name: 'Link' });

        post.user = user;

        return [post, user];
      }
    }, {
      key: 'savedChildSavedParent',
      value: function savedChildSavedParent() {
        var schema = this.schema;

        schema.db.loadData({
          posts: [{ id: '1', title: 'Lorem', userId: '1' }],
          users: [{ id: '1', name: 'Link', postIds: ['1'] }]
        });

        return [schema.posts.find(1), schema.users.find(1)];
      }
    }, {
      key: 'newChildNoParent',
      value: function newChildNoParent() {
        var post = this.schema.posts['new']({ title: 'Lorem' });

        return [post, null];
      }
    }, {
      key: 'newChildNewParent',
      value: function newChildNewParent() {
        var post = this.schema.posts['new']({ title: 'Lorem' });
        var user = this.schema.users['new']({ name: 'Link' });

        post.user = user;

        return [post, user];
      }
    }, {
      key: 'newChildSavedParent',
      value: function newChildSavedParent() {
        var post = this.schema.posts.create({ title: 'Lorem' });
        var user = this.schema.users['new']({ name: 'Link' });

        post.user = user;

        return [post, user];
      }

      // Unassociated models
    }, {
      key: 'savedParent',
      value: function savedParent() {
        var insertedUser = this.db.users.insert({ name: 'Link' });

        return this.schema.users.find(insertedUser.id);
      }
    }, {
      key: 'newParent',
      value: function newParent() {
        return this.schema.users['new']({ name: 'Link' });
      }
    }]);

    return Helper;
  })();

  exports['default'] = Helper;
  var states = ['savedChildNoParent', 'savedChildNewParent', 'savedChildSavedParent', 'newChildNoParent', 'newChildNewParent', 'newChildSavedParent'];
  exports.states = states;
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/_helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/2-many-to-one/_helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/2-many-to-one/_helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/accessor-test', ['exports', 'dummy/tests/integration/orm/mixed/2-many-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed2ManyToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | Many To One | accessor', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed2ManyToOne_helper['default']();
    }
  });

  /*
    The reference to a belongs-to association is correct, for all states
  */
  _dummyTestsIntegrationOrmMixed2ManyToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('the references of a ' + state + ' are correct', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var post = _helper$state2[0];
      var user = _helper$state2[1];

      assert.deepEqual(post.user, user);
      assert.equal(post.userId, user ? user.id : null);

      post.save();

      // Check the inverse
      if (user && user.isSaved()) {
        user.reload();
        assert.ok(user.posts.includes(post));
      }
    });
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/accessor-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/2-many-to-one/accessor-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/2-many-to-one/accessor-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/association-create-test', ['exports', 'dummy/tests/integration/orm/mixed/2-many-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed2ManyToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | Many To One | association #create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed2ManyToOne_helper['default']();
    }
  });

  /*
    The model can create a has-many association, for all states
  */
  _dummyTestsIntegrationOrmMixed2ManyToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can create an associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var post = _helper$state2[0];
      var originalUser = _helper$state2[1];

      var user = post.createUser({ name: 'Zelda' });

      assert.ok(user.id, 'the parent was persisted');
      assert.deepEqual(post.user.attrs, user.attrs);
      assert.equal(post.userId, user.id);

      // Check the inverse
      assert.ok(user.posts.includes(post), 'the inverse was set');

      // Ensure old inverse was cleared
      if (originalUser && originalUser.isSaved()) {
        originalUser.reload();
        assert.notOk(originalUser.posts.includes(post));
      }
    });
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/association-create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/2-many-to-one/association-create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/2-many-to-one/association-create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/association-new-test', ['exports', 'dummy/tests/integration/orm/mixed/2-many-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed2ManyToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | Many To One | association #new', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed2ManyToOne_helper['default']();
    }
  });

  /*
    The model can make a new unsaved belongs-to association, for all states
  */

  _dummyTestsIntegrationOrmMixed2ManyToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can build a new associated parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var post = _helper$state2[0];
      var originalUser = _helper$state2[1];

      var user = post.newUser({ name: 'Zelda' });

      assert.ok(!user.id, 'the child was not persisted');
      assert.deepEqual(post.user, user, 'the relationship was set');
      assert.ok(user.posts.includes(post), 'the inverse was set');

      user.save();
      post.reload();

      assert.ok(user.id, 'the parent was persisted');
      assert.deepEqual(post.user.attrs, user.attrs);
      assert.equal(post.userId, user.id);

      // Check the inverse
      assert.ok(user.posts.includes(post), 'the inverse was set');

      // Ensure old inverse was cleared
      if (originalUser && originalUser.isSaved()) {
        originalUser.reload();
        assert.notOk(originalUser.posts.includes(post));
      }
    });
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/association-new-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/2-many-to-one/association-new-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/2-many-to-one/association-new-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/association-set-ids-test', ['exports', 'dummy/tests/integration/orm/mixed/2-many-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed2ManyToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | Many To One | association #setIds', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed2ManyToOne_helper['default']();
    }
  });

  /*
    The model can update its association via parentId, for all states
  */
  _dummyTestsIntegrationOrmMixed2ManyToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent via parentId', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var post = _helper$state2[0];
      var originalUser = _helper$state2[1];

      var user = this.helper.savedParent();

      post.userId = user.id;

      assert.equal(post.userId, user.id);
      assert.deepEqual(post.user.attrs, user.attrs);

      assert.ok(post.user.posts.includes(post), 'the inverse was set');

      post.save();
      user.reload();

      assert.ok(user.posts.includes(post));

      // Old inverses were cleared
      if (originalUser && originalUser.isSaved()) {
        originalUser.reload();
        assert.notOk(originalUser.posts.includes(post));
      }
    });

    (0, _qunit.test)('a ' + state + ' can clear its association via a null parentId', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var post = _helper$state32[0];
      var originalUser = _helper$state32[1];

      post.userId = null;

      assert.deepEqual(post.user, null);
      assert.deepEqual(post.userId, null);

      post.save();

      if (originalUser && originalUser.isSaved()) {
        originalUser.reload();
        assert.notOk(originalUser.posts.includes(post));
      }
    });
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/association-set-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/2-many-to-one/association-set-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/2-many-to-one/association-set-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/association-set-test', ['exports', 'dummy/tests/integration/orm/mixed/2-many-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed2ManyToOne_helper, _qunit) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _qunit.module)('Integration | ORM | Mixed | Many To One | association #set', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed2ManyToOne_helper['default']();
    }
  });

  /*
    The model can update its association via parent, for all states
  */
  _dummyTestsIntegrationOrmMixed2ManyToOne_helper.states.forEach(function (state) {

    (0, _qunit.test)('a ' + state + ' can update its association to a saved parent', function (assert) {
      var _helper$state = this.helper[state]();

      var _helper$state2 = _slicedToArray(_helper$state, 2);

      var post = _helper$state2[0];
      var originalUser = _helper$state2[1];

      var savedUser = this.helper.savedParent();

      post.user = savedUser;

      assert.deepEqual(post.user, savedUser);
      assert.ok(savedUser.posts.includes(post), 'the inverse was set');

      post.save();

      // Old inverse was cleared
      if (originalUser && originalUser.isSaved()) {
        originalUser.reload();
        assert.notOk(originalUser.posts.includes(post));
      }
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a new parent', function (assert) {
      var _helper$state3 = this.helper[state]();

      var _helper$state32 = _slicedToArray(_helper$state3, 2);

      var post = _helper$state32[0];
      var originalUser = _helper$state32[1];

      var newUser = this.helper.newParent();

      post.user = newUser;

      assert.deepEqual(post.user, newUser);
      assert.ok(newUser.posts.includes(post), 'the inverse was set');

      post.save();

      // Old inverse was cleared
      if (originalUser && originalUser.isSaved()) {
        originalUser.reload();
        assert.notOk(originalUser.posts.includes(post));
      }
    });

    (0, _qunit.test)('a ' + state + ' can update its association to a null parent', function (assert) {
      var _helper$state4 = this.helper[state]();

      var _helper$state42 = _slicedToArray(_helper$state4, 2);

      var post = _helper$state42[0];
      var originalUser = _helper$state42[1];

      post.user = null;

      assert.deepEqual(post.user, null);

      post.save();

      // Old inverse was cleared
      if (originalUser && originalUser.isSaved()) {
        originalUser.reload();
        assert.notOk(originalUser.posts.includes(post));
      }
    });
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/association-set-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/2-many-to-one/association-set-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/2-many-to-one/association-set-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/create-test', ['exports', 'dummy/tests/integration/orm/mixed/2-many-to-one/_helper', 'ember-cli-mirage', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed2ManyToOne_helper, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | ORM | Mixed | Many To One | create', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed2ManyToOne_helper['default']();
      this.helper.schema.registerModel('foo', _emberCliMirage.Model);
    }
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the foreign key', function (assert) {
    var schema = this.helper.schema;

    var user = schema.create('user');
    var post = schema.create('post', {
      userId: user.id
    });
    user.reload();

    assert.deepEqual(post.user.attrs, user.attrs);
    assert.equal(post.userId, user.id);
    assert.ok(user.posts.includes(post), 'inverse was set');
    assert.deepEqual(user.postIds, [post.id]);

    var db = this.helper.db;

    assert.equal(db.posts.length, 1);
    assert.deepEqual(db.posts[0], { id: '1', userId: '1' });
    assert.equal(db.users.length, 1);
    assert.deepEqual(db.users[0], { id: '1', postIds: ['1'] });
  });

  (0, _qunit.test)('it sets up associations correctly when passing in the association itself', function (assert) {
    var schema = this.helper.schema;

    var user = schema.create('user');
    var post = schema.create('post', {
      user: user
    });

    assert.deepEqual(post.user.attrs, user.attrs);
    assert.equal(post.userId, user.id);
    assert.ok(user.posts.includes(post), 'inverse was set');
    assert.deepEqual(user.postIds, [post.id]);

    var db = this.helper.db;

    assert.equal(db.posts.length, 1);
    assert.deepEqual(db.posts[0], { id: '1', userId: '1' });
    assert.equal(db.users.length, 1);
    assert.deepEqual(db.users[0], { id: '1', postIds: ['1'] });
  });

  (0, _qunit.test)('it throws an error if a model is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    assert.throws(function () {
      schema.create('post', {
        foo: schema.create('foo')
      });
    }, /you haven't defined that key as an association on your model/);
  });

  (0, _qunit.test)('it throws an error if a collection is passed in without a defined relationship', function (assert) {
    var schema = this.helper.schema;

    schema.create('foo');
    schema.create('foo');

    assert.throws(function () {
      schema.create('post', {
        foos: schema.foos.all()
      });
    }, /you haven't defined that key as an association on your model/);
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/create-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/2-many-to-one/create-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/mixed/2-many-to-one/create-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/instantiating-test', ['exports', 'dummy/tests/integration/orm/mixed/2-many-to-one/_helper', 'qunit'], function (exports, _dummyTestsIntegrationOrmMixed2ManyToOne_helper, _qunit) {

  (0, _qunit.module)('Integration | ORM | Mixed | One To Many | instantiating', {
    beforeEach: function beforeEach() {
      this.helper = new _dummyTestsIntegrationOrmMixed2ManyToOne_helper['default']();
      this.schema = this.helper.schema;
    }
  });

  (0, _qunit.test)('the child accepts a saved parent id', function (assert) {
    var user = this.helper.savedParent();
    var post = this.schema.posts['new']({ userId: user.id });

    assert.equal(post.userId, user.id);
    assert.deepEqual(post.user.attrs, user.attrs);
    assert.deepEqual(post.attrs, { userId: user.id });

    post.save();
    user.reload();

    assert.ok(user.posts.includes(post), 'the inverse was set');
  });

  (0, _qunit.test)('the child errors if the parent id doesnt exist', function (assert) {
    assert.throws(function () {
      this.schema.posts['new']({ userId: 2 });
    }, /You're instantiating a post that has a userId of 2, but that record doesn't exist in the database/);
  });

  (0, _qunit.test)('the child accepts a null parent id', function (assert) {
    var post = this.schema.posts['new']({ userId: null });

    assert.equal(post.userId, null);
    assert.equal(post.user, null);
    assert.deepEqual(post.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts a saved parent model', function (assert) {
    var user = this.helper.savedParent();
    var post = this.schema.posts['new']({ user: user });

    assert.equal(post.userId, 1);
    assert.deepEqual(post.user.attrs, user.attrs);
    assert.deepEqual(post.attrs, { userId: null });

    post.save();
    user.reload();

    assert.ok(user.posts.includes(post), 'the inverse was set');
  });

  (0, _qunit.test)('the child accepts a new parent model', function (assert) {
    var user = this.schema.users['new']({ age: 300 });
    var post = this.schema.posts['new']({ user: user });

    assert.equal(post.userId, null);
    assert.deepEqual(post.user, user);
    assert.deepEqual(post.attrs, { userId: null });
    assert.ok(user.posts.includes(post), 'the inverse was set');
  });

  (0, _qunit.test)('the child accepts a null parent model', function (assert) {
    var post = this.schema.posts['new']({ user: null });

    assert.equal(post.userId, null);
    assert.deepEqual(post.user, null);
    assert.deepEqual(post.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts a parent model and id', function (assert) {
    var user = this.helper.savedParent();
    var post = this.schema.posts['new']({ user: user, userId: user.id });

    assert.equal(post.userId, '1');
    assert.deepEqual(post.user, user);
    assert.deepEqual(post.attrs, { userId: user.id });

    assert.ok(user.posts.includes(post), 'the inverse was set');
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model as empty obj', function (assert) {
    var post = this.schema.posts['new']({});

    assert.equal(post.userId, null);
    assert.deepEqual(post.user, null);
    assert.deepEqual(post.attrs, { userId: null });
  });

  (0, _qunit.test)('the child accepts no reference to a parent id or model', function (assert) {
    var post = this.schema.posts['new']();

    assert.equal(post.userId, null);
    assert.deepEqual(post.user, null);
    assert.deepEqual(post.attrs, { userId: null });
  });
});
define('dummy/tests/integration/orm/mixed/2-many-to-one/instantiating-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/mixed/2-many-to-one/instantiating-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(false, 'integration/orm/mixed/2-many-to-one/instantiating-test.js should pass ESLint.\n73:43  - There should be no space before \',\'. (comma-spacing)');
  });
});
define('dummy/tests/integration/orm/reinitialize-associations-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb, _qunit) {

  // Model classes are defined statically, just like in a typical app
  var User = _emberCliMirage.Model.extend({
    addresses: (0, _emberCliMirage.hasMany)()
  });
  var Address = _emberCliMirage.Model.extend();

  (0, _qunit.module)('Integration | ORM | reinitialize associations', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        address: Address,
        user: User
      });

      this.schema.addresses.create({ id: 1, country: 'Hyrule' });
      this.schema.users.create({ id: 1, name: 'Link', addressIds: [1] });
    }
  });

  // By running two tests, we force the statically-defined classes to be
  // registered twice.
  (0, _qunit.test)('safely initializes associations', function (assert) {
    assert.equal(this.schema.users.find(1).addresses.models[0].country, 'Hyrule');
  });
  (0, _qunit.test)('safely initializes associations again', function (assert) {
    assert.equal(this.schema.users.find(1).addresses.models[0].country, 'Hyrule');
  });
});
// jscs:disable disallowVar
define('dummy/tests/integration/orm/reinitialize-associations-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/reinitialize-associations-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/reinitialize-associations-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/schema-verification/belongs-to-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb, _qunit) {

  (0, _qunit.module)('Integration | ORM | Schema Verification | Belongs To');

  (0, _qunit.test)('a one-way belongsTo association is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      author: _emberCliMirage.Model.extend(),
      post: _emberCliMirage.Model.extend({
        author: (0, _emberCliMirage.belongsTo)()
      })
    });

    var association = schema.modelClassFor('post').associationFor('author');

    assert.equal(association.key, 'author');
    assert.equal(association.modelName, 'author');
    assert.equal(association.ownerModelName, 'post');
    assert.ok(association.inverse() === null, 'there is no inverse');
  });

  (0, _qunit.test)('a one-way named belongsTo association is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend(),
      post: _emberCliMirage.Model.extend({
        author: (0, _emberCliMirage.belongsTo)('user')
      })
    });

    var association = schema.modelClassFor('post').associationFor('author');

    assert.equal(association.key, 'author');
    assert.equal(association.modelName, 'user');
    assert.equal(association.ownerModelName, 'post');
    assert.ok(association.inverse() === null, 'there is no inverse');
  });

  (0, _qunit.test)('a reflexive belongsTo association is correct and has an implicit inverse', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend({
        user: (0, _emberCliMirage.belongsTo)()
      })
    });

    var association = schema.modelClassFor('user').associationFor('user');

    assert.equal(association.key, 'user');
    assert.equal(association.modelName, 'user');
    assert.equal(association.ownerModelName, 'user');
    assert.ok(association.inverse() === association, 'the implicit inverse was found');
  });

  (0, _qunit.test)('a named reflexive belongsTo association with an implicit inverse is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend({
        bestFriend: (0, _emberCliMirage.belongsTo)('user')
      })
    });

    var association = schema.modelClassFor('user').associationFor('bestFriend');

    assert.equal(association.key, 'bestFriend');
    assert.equal(association.modelName, 'user');
    assert.equal(association.ownerModelName, 'user');
    assert.ok(association.inverse() === association, 'the implicit inverse was found');
  });

  (0, _qunit.test)('a named reflexive belongsTo association with an explicit inverse is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend({
        bestFriend: (0, _emberCliMirage.belongsTo)('user', { inverse: 'bestFriend' })
      })
    });

    var association = schema.modelClassFor('user').associationFor('bestFriend');

    assert.equal(association.key, 'bestFriend');
    assert.equal(association.modelName, 'user');
    assert.equal(association.ownerModelName, 'user');
    assert.ok(association.inverse() === association, 'the implicit inverse was found');
  });

  (0, _qunit.test)('a one way reflexive belongsTo association with a null inverse is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend({
        user: (0, _emberCliMirage.belongsTo)('user', { inverse: null })
      })
    });

    var association = schema.modelClassFor('user').associationFor('user');

    assert.equal(association.key, 'user');
    assert.equal(association.modelName, 'user');
    assert.equal(association.ownerModelName, 'user');
    assert.ok(association.inverse() === null, 'there is no inverse');
  });

  (0, _qunit.test)('a named way reflexive belongsTo association with a null inverse is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend({
        parent: (0, _emberCliMirage.belongsTo)('user', { inverse: null })
      })
    });

    var association = schema.modelClassFor('user').associationFor('parent');

    assert.equal(association.key, 'parent');
    assert.equal(association.modelName, 'user');
    assert.equal(association.ownerModelName, 'user');
    assert.ok(association.inverse() === null, 'there is no inverse');
  });

  (0, _qunit.test)('a one to one belongsTo association with an implicit inverse is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend({
        profile: (0, _emberCliMirage.belongsTo)()
      }),
      profile: _emberCliMirage.Model.extend({
        user: (0, _emberCliMirage.belongsTo)()
      })
    });

    var association = schema.modelClassFor('profile').associationFor('user');

    assert.equal(association.key, 'user');
    assert.equal(association.modelName, 'user');
    assert.equal(association.ownerModelName, 'profile');

    var inverse = association.inverse();

    assert.equal(inverse.key, 'profile');
    assert.equal(inverse.modelName, 'profile');
    assert.equal(inverse.ownerModelName, 'user');
  });
});
define('dummy/tests/integration/orm/schema-verification/belongs-to-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/schema-verification/belongs-to-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/schema-verification/belongs-to-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/schema-verification/has-many-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb, _qunit) {

  (0, _qunit.module)('Integration | ORM | Schema Verification | Has Many');

  (0, _qunit.test)('a one-way has many association is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend({
        posts: (0, _emberCliMirage.hasMany)()
      }),
      post: _emberCliMirage.Model.extend()
    });

    var association = schema.modelClassFor('user').associationFor('posts');

    assert.equal(association.key, 'posts');
    assert.equal(association.modelName, 'post');
    assert.equal(association.ownerModelName, 'user');
    assert.ok(association.inverse() === null, 'there is no inverse');
  });

  (0, _qunit.test)('a named one-way has many association is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend({
        blogPosts: (0, _emberCliMirage.hasMany)('post')
      }),
      post: _emberCliMirage.Model.extend()
    });

    var association = schema.modelClassFor('user').associationFor('blogPosts');

    assert.equal(association.key, 'blogPosts');
    assert.equal(association.modelName, 'post');
    assert.equal(association.ownerModelName, 'user');
    assert.ok(association.inverse() === null, 'there is no inverse');
  });

  (0, _qunit.test)('a reflexive hasMany association with an implicit inverse is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      tag: _emberCliMirage.Model.extend({
        tags: (0, _emberCliMirage.hasMany)()
      })
    });

    var association = schema.modelClassFor('tag').associationFor('tags');

    assert.equal(association.key, 'tags');
    assert.equal(association.modelName, 'tag');
    assert.equal(association.ownerModelName, 'tag');
    assert.ok(association.inverse() === association, 'the implicit inverse was found');
  });
});
define('dummy/tests/integration/orm/schema-verification/has-many-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/schema-verification/has-many-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/schema-verification/has-many-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/schema-verification/mixed-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb, _qunit) {

  (0, _qunit.module)('Integration | ORM | Schema Verification | Mixed');

  (0, _qunit.test)('unnamed one-to-many associations are correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      wordSmith: _emberCliMirage.Model.extend({
        blogPosts: (0, _emberCliMirage.hasMany)()
      }),
      blogPost: _emberCliMirage.Model.extend({
        wordSmith: (0, _emberCliMirage.belongsTo)()
      })
    });

    var association = schema.associationsFor('word-smith').blogPosts;
    var inverse = schema.associationsFor('blog-post').wordSmith;

    assert.equal(association.key, 'blogPosts');
    assert.equal(association.modelName, 'blog-post');
    assert.equal(association.ownerModelName, 'word-smith');
    assert.deepEqual(association.inverse(), inverse);
  });

  (0, _qunit.test)('a named one-to-many association is correct', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      wordSmith: _emberCliMirage.Model.extend({
        posts: (0, _emberCliMirage.hasMany)('blog-post')
      }),
      blogPost: _emberCliMirage.Model.extend({
        author: (0, _emberCliMirage.belongsTo)('word-smith')
      })
    });

    var association = schema.associationsFor('word-smith').posts;
    var inverse = schema.associationsFor('blog-post').author;

    assert.equal(association.key, 'posts');
    assert.equal(association.modelName, 'blog-post');
    assert.equal(association.ownerModelName, 'word-smith');
    assert.deepEqual(association.inverse(), inverse);
  });

  (0, _qunit.test)('multiple has-many associations of the same type', function (assert) {
    var schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
      user: _emberCliMirage.Model.extend({
        notes: (0, _emberCliMirage.hasMany)('post', { inverse: 'author' }),
        messages: (0, _emberCliMirage.hasMany)('post', { inverse: 'messenger' })
      }),
      post: _emberCliMirage.Model.extend({
        author: (0, _emberCliMirage.belongsTo)('user', { inverse: 'notes' }),
        messenger: (0, _emberCliMirage.belongsTo)('user', { inverse: 'messages' })
      })
    });

    var _schema$associationsFor = schema.associationsFor('user');

    var notes = _schema$associationsFor.notes;
    var messages = _schema$associationsFor.messages;

    var _schema$associationsFor2 = schema.associationsFor('post');

    var author = _schema$associationsFor2.author;
    var messenger = _schema$associationsFor2.messenger;

    assert.equal(notes.key, 'notes');
    assert.equal(notes.modelName, 'post');
    assert.equal(notes.ownerModelName, 'user');
    assert.deepEqual(notes.inverse(), author);
    assert.equal(messages.key, 'messages');
    assert.equal(messages.modelName, 'post');
    assert.equal(messages.ownerModelName, 'user');
    assert.deepEqual(messages.inverse(), messenger);
  });
});
define('dummy/tests/integration/orm/schema-verification/mixed-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/schema-verification/mixed-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/schema-verification/mixed-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/update-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _qunit) {

  (0, _qunit.module)('Integration | ORM | update', {
    beforeEach: function beforeEach() {
      this.db = new _emberCliMirageDb['default']({
        users: [{ id: 1, name: 'Link', location: 'Hyrule', evil: false }, { id: 2, name: 'Zelda', location: 'Hyrule', evil: false }]
      });

      this.schema = new _emberCliMirageOrmSchema['default'](this.db, {
        user: _emberCliMirageOrmModel['default']
      });
    }
  });

  (0, _qunit.test)('a collection can update its models with a key and value', function (assert) {
    var collection = this.schema.users.all();
    collection.update('evil', true);

    assert.deepEqual(this.db.users, [{ id: '1', name: 'Link', location: 'Hyrule', evil: true }, { id: '2', name: 'Zelda', location: 'Hyrule', evil: true }]);
    assert.deepEqual(collection.models[0].attrs, { id: '1', name: 'Link', location: 'Hyrule', evil: true });
  });

  (0, _qunit.test)('it can update its models with a hash of attrs', function (assert) {
    var collection = this.schema.users.all();
    collection.update({ location: 'The water temple', evil: true });

    assert.deepEqual(this.db.users, [{ id: '1', name: 'Link', location: 'The water temple', evil: true }, { id: '2', name: 'Zelda', location: 'The water temple', evil: true }]);
    assert.deepEqual(collection.models[0].attrs, { id: '1', name: 'Link', location: 'The water temple', evil: true });
    assert.deepEqual(collection.models[1].attrs, { id: '2', name: 'Zelda', location: 'The water temple', evil: true });
  });

  (0, _qunit.test)('it can set an attribute and then save the model', function (assert) {
    var user = this.schema.users.find(1);

    user.name = 'Young link';

    assert.deepEqual(user.attrs, { id: '1', name: 'Young link', location: 'Hyrule', evil: false });
    assert.deepEqual(this.db.users.find(1), { id: '1', name: 'Link', location: 'Hyrule', evil: false });

    user.save();

    assert.deepEqual(user.attrs, { id: '1', name: 'Young link', location: 'Hyrule', evil: false });
    assert.deepEqual(this.db.users.find(1), { id: '1', name: 'Young link', location: 'Hyrule', evil: false });
  });

  (0, _qunit.test)('it can update and immediately persist a single attribute', function (assert) {
    var link = this.schema.users.find(1);
    link.update('evil', true);

    assert.deepEqual(link.attrs, { id: '1', name: 'Link', location: 'Hyrule', evil: true });
    assert.deepEqual(this.db.users.find(1), { id: '1', name: 'Link', location: 'Hyrule', evil: true });
  });

  (0, _qunit.test)('it can update a hash of attrs immediately', function (assert) {
    var link = this.schema.users.find(1);
    link.update({ name: 'Evil link', evil: true });

    assert.deepEqual(link.attrs, { id: '1', name: 'Evil link', location: 'Hyrule', evil: true });
    assert.deepEqual(this.db.users.find(1), { id: '1', name: 'Evil link', location: 'Hyrule', evil: true });
  });

  (0, _qunit.test)('it can update a non-existing attribute', function (assert) {
    var link = this.schema.users.find(1);
    link.update({ name: 'Evil link', evil: true, reallyEvil: 'absolutely evil' });

    assert.deepEqual(link.attrs, { id: '1', name: 'Evil link', location: 'Hyrule', evil: true, reallyEvil: 'absolutely evil' });
    assert.deepEqual(this.db.users.find(1), { id: '1', name: 'Evil link', location: 'Hyrule', evil: true, reallyEvil: 'absolutely evil' });
  });

  (0, _qunit.test)('if users sets incorrectly an attribute without using update, it will still work', function (assert) {
    var link = this.schema.users.find(1);
    link.reallyEvil = 'absolutely evil';
    link.update({ reallyEvil: 'a little flower', evil: true });
    assert.deepEqual(link.attrs, { id: '1', reallyEvil: 'a little flower', evil: true, location: 'Hyrule', name: 'Link' });
    assert.deepEqual(this.db.users.find(1), { id: '1', reallyEvil: 'a little flower', evil: true, location: 'Hyrule', name: 'Link' });
  });
});
define('dummy/tests/integration/orm/update-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/update-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/update-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/orm/where-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'ember-cli-mirage/orm/collection', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _emberCliMirageOrmCollection, _qunit) {

  var schema = undefined;
  var User = _emberCliMirageOrmModel['default'].extend();
  (0, _qunit.module)('Integration | ORM | #where', {
    beforeEach: function beforeEach() {
      var db = new _emberCliMirageDb['default']({ users: [{ id: 1, name: 'Link', good: true }, { id: 2, name: 'Zelda', good: true }, { id: 3, name: 'Ganon', good: false }] });

      schema = new _emberCliMirageOrmSchema['default'](db, {
        user: User
      });
    }
  });

  (0, _qunit.test)('it returns models that match a query with where', function (assert) {
    var users = schema.users.where({ good: false });

    assert.ok(users instanceof _emberCliMirageOrmCollection['default'], 'it returns a collection');
    assert.equal(users.models.length, 1);
    assert.ok(users.models[0] instanceof User);
    assert.deepEqual(users.models[0].attrs, { id: '3', name: 'Ganon', good: false });
  });

  (0, _qunit.test)('it returns models that match using a query function', function (assert) {
    var users = schema.users.where(function (rec) {
      return !rec.good;
    });

    assert.ok(users instanceof _emberCliMirageOrmCollection['default'], 'it returns a collection');
    assert.equal(users.models.length, 1);
    assert.ok(users.models[0] instanceof User);
    assert.deepEqual(users.models[0].attrs, { id: '3', name: 'Ganon', good: false });
  });

  (0, _qunit.test)('it returns an empty collection if no models match a query', function (assert) {
    var users = schema.users.where({ name: 'Link', good: false });

    assert.ok(users instanceof _emberCliMirageOrmCollection['default'], 'it returns a collection');
    assert.equal(users.models.length, 0);
  });
});
define('dummy/tests/integration/orm/where-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/orm/where-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/orm/where-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/passthrough-test', ['exports', 'qunit', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Passthrough', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development'
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('it can passthrough individual paths', function (assert) {
    assert.expect(2);
    var done1 = assert.async();
    var done2 = assert.async();
    var server = this.server;

    server.loadConfig(function () {
      this.get('/contacts', function () {
        return 123;
      });
      this.passthrough('/addresses');
    });

    $.ajax({
      method: 'GET',
      url: '/contacts',
      success: function success(data) {
        assert.equal(data, 123);
        done1();
      }
    });

    $.ajax({
      method: 'GET',
      url: '/addresses',
      error: function error(reason) {
        assert.equal(reason.status, 404);
        done2();
      }
    });
  });

  (0, _qunit.test)('it can passthrough certain verbs for individual paths', function (assert) {
    assert.expect(3);
    var done1 = assert.async();
    var done2 = assert.async();
    var done3 = assert.async();
    var server = this.server;

    server.loadConfig(function () {
      this.get('/contacts', function () {
        return 123;
      });
      this.passthrough('/addresses', ['post']);
    });
    server.pretender.unhandledRequest = function () /* verb, path */{
      assert.ok(true, 'it doesnt passthrough GET');
      done2();
    };

    $.ajax({
      method: 'GET',
      url: '/contacts',
      success: function success(data) {
        assert.equal(data, 123);
        done1();
      }
    });

    $.ajax({
      method: 'GET',
      url: '/addresses'
    });

    $.ajax({
      method: 'POST',
      url: '/addresses',
      error: function error(reason) {
        assert.equal(reason.status, 404);
        done3();
      }
    });
  });

  (0, _qunit.test)('it can passthrough multiple paths in a single call', function (assert) {
    assert.expect(2);
    var done1 = assert.async();
    var done2 = assert.async();
    var server = this.server;

    server.loadConfig(function () {
      this.get('/contacts', function () {
        return 123;
      });
      this.passthrough('/contacts', '/addresses');
    });

    $.ajax({
      method: 'GET',
      url: '/contacts',
      error: function error(reason) {
        assert.equal(reason.status, 404);
        done1();
      }
    });

    $.ajax({
      method: 'POST',
      url: '/addresses',
      error: function error(reason) {
        assert.equal(reason.status, 404);
        done2();
      }
    });
  });

  (0, _qunit.test)('user can call passthrough multiple times', function (assert) {
    assert.expect(2);
    var done1 = assert.async();
    var done2 = assert.async();
    var server = this.server;

    server.loadConfig(function () {
      this.passthrough('/contacts');
      this.passthrough('/addresses', ['post']);
    });

    $.ajax({
      method: 'GET',
      url: '/contacts',
      error: function error(reason) {
        assert.equal(reason.status, 404);
        done1();
      }
    });

    $.ajax({
      method: 'POST',
      url: '/addresses',
      error: function error(reason) {
        assert.equal(reason.status, 404);
        done2();
      }
    });
  });

  (0, _qunit.test)('passthrough without args allows all paths on the current domain to passthrough', function (assert) {
    assert.expect(2);
    var done1 = assert.async();
    var done2 = assert.async();
    var server = this.server;

    server.loadConfig(function () {
      this.get('/contacts', function () {
        return 123;
      });
      this.passthrough();
    });

    $.ajax({
      method: 'GET',
      url: '/contacts',
      success: function success(data) {
        assert.equal(data, 123);
        done1();
      }
    });

    $.ajax({
      method: 'GET',
      url: '/addresses',
      error: function error(reason) {
        assert.equal(reason.status, 404);
        done2();
      }
    });
  });

  (0, _qunit.test)('passthrough without args allows index route on current domain to passthrough', function (assert) {
    assert.expect(2);
    var done1 = assert.async();
    var done2 = assert.async();
    var server = this.server;

    server.loadConfig(function () {
      this.get('/contacts', function () {
        return 123;
      });
      this.passthrough();
    });

    $.ajax({
      method: 'GET',
      url: '/contacts',
      success: function success(data) {
        assert.equal(data, 123, 'contacts is intercepted');
        done1();
      }
    });

    $.ajax({
      method: 'GET',
      url: '/',
      error: function error() {
        done2(); // test will fail bc only 1 assertion, but we don't have to wait
      },
      success: function success(html) {
        // a passthrough request to index on the current domain
        // actually succeeds here, since that's where the test runner is served
        assert.ok(html, '/ is passed through');
        done2(); // test will fail bc only 1 assertion, but we don't have to wait
      }
    });
  });

  (0, _qunit.test)('it can passthrough other-origin hosts', function (assert) {
    assert.expect(1);
    var done1 = assert.async();
    var server = this.server;

    server.loadConfig(function () {
      this.passthrough('http://api.foo.bar/**');
    });

    $.ajax({
      method: 'GET',
      url: 'http://api.foo.bar/contacts',
      error: function error() {
        assert.ok(true);
        done1();
      }
    });
  });
});
define('dummy/tests/integration/passthrough-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/passthrough-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/passthrough-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/route-handlers/delete-shorthand-test', ['exports', 'qunit', 'ember-cli-mirage/server', 'ember-cli-mirage/orm/model', 'ember-cli-mirage', 'ember-cli-mirage/route-handlers/shorthands/delete', 'ember-cli-mirage/serializers/json-api-serializer'], function (exports, _qunit, _emberCliMirageServer, _emberCliMirageOrmModel, _emberCliMirage, _emberCliMirageRouteHandlersShorthandsDelete, _emberCliMirageSerializersJsonApiSerializer) {

  (0, _qunit.module)('Integration | Route Handlers | DELETE shorthand', {

    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        models: {
          wordSmith: _emberCliMirageOrmModel['default'].extend({
            blogPosts: _emberCliMirage['default'].hasMany()
          }),
          blogPost: _emberCliMirageOrmModel['default']
        }
      });
      this.server.timing = 0;
      this.server.logging = false;

      var wordSmiths = [{ id: 1, name: 'Ganon', blogPostIds: [1] }];
      var blogPosts = [{ id: 1, title: 'Lorem', wordSmithId: '1' }, { id: 2, title: 'Another', wordSmithId: '2' }];
      this.server.db.loadData({ wordSmiths: wordSmiths, blogPosts: blogPosts });

      this.schema = this.server.schema;
      this.serializer = new _emberCliMirageSerializersJsonApiSerializer['default']();
    },

    afterEach: function afterEach() {
      this.server.shutdown();
    }

  });

  (0, _qunit.test)('undefined shorthand deletes the record and returns null', function (assert) {
    var request = { url: '/word-smiths/1', params: { id: '1' } };
    var handler = new _emberCliMirageRouteHandlersShorthandsDelete['default'](this.schema, this.serializer, undefined, '/word-smiths/:id');

    var response = handler.handle(request);

    assert.equal(this.schema.db.wordSmiths.length, 0);
    assert.equal(response, null);
  });

  (0, _qunit.test)('query params are ignored', function (assert) {
    var request = { url: '/word-smiths/1?foo=bar', params: { id: '1' }, queryParams: { foo: 'bar' } };
    var handler = new _emberCliMirageRouteHandlersShorthandsDelete['default'](this.schema, this.serializer, undefined, '/word-smiths/:id');

    var response = handler.handle(request);

    assert.equal(this.schema.db.wordSmiths.length, 0);
    assert.equal(response, null);
  });

  (0, _qunit.test)('string shorthand deletes the record of the specified type', function (assert) {
    var request = { url: '/word-smiths/1?foo=bar', params: { id: '1' }, queryParams: { foo: 'bar' } };
    var handler = new _emberCliMirageRouteHandlersShorthandsDelete['default'](this.schema, this.serializer, undefined, '/word-smiths/:id');

    var response = handler.handle(request);

    assert.equal(this.schema.db.wordSmiths.length, 0);
    assert.equal(response, null);
  });

  (0, _qunit.test)('array shorthand deletes the record and all related records', function (assert) {
    var request = { url: '/word-smiths/1', params: { id: '1' } };
    var handler = new _emberCliMirageRouteHandlersShorthandsDelete['default'](this.schema, this.serializer, ['word-smith', 'blog-posts']);

    var response = handler.handle(request);

    assert.equal(this.schema.db.wordSmiths.length, 0);
    assert.equal(this.schema.db.blogPosts.length, 1);
    assert.equal(response, null);
  });

  (0, _qunit.test)('if a shorthand tries to access an unknown type it throws an error', function (assert) {
    var request = { url: '/foobars/1', params: { id: '1' } };
    var handler = new _emberCliMirageRouteHandlersShorthandsDelete['default'](this.schema, this.serializer, undefined, '/foobars/:id');

    assert.throws(function () {
      handler.handle(request);
    }, /model doesn't exist/);
    assert.ok(true);
  });
});
define('dummy/tests/integration/route-handlers/delete-shorthand-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/route-handlers/delete-shorthand-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/route-handlers/delete-shorthand-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/route-handlers/function-handler-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember', 'ember-cli-mirage/server', 'ember-cli-mirage/response', 'ember-cli-mirage/route-handlers/function', 'lodash/uniqBy'], function (exports, _qunit, _emberCliMirage, _ember, _emberCliMirageServer, _emberCliMirageResponse, _emberCliMirageRouteHandlersFunction, _lodashUniqBy) {
  var Promise = _ember['default'].RSVP.Promise;

  (0, _qunit.module)('Integration | Route handlers | Function handler', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        models: {
          user: _emberCliMirage.Model.extend({})
        },
        serializers: {
          sparseUser: _emberCliMirage.Serializer.extend({
            attrs: ['id', 'name', 'tall']
          })
        }
      });
      this.server.timing = 0;
      this.server.logging = false;

      this.functionHandler = new _emberCliMirageRouteHandlersFunction['default'](this.server.schema, this.server.serializerOrRegistry);
      this.schema = this.server.schema;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('mirage response string is not serialized to string', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server.get('/users', function () {
      return new _emberCliMirageResponse['default'](200, { 'Content-Type': 'text/csv' }, 'firstname,lastname\nbob,dylon');
    });

    $.ajax({ method: 'GET', url: '/users' }).done(function (res) {
      assert.equal(res, 'firstname,lastname\nbob,dylon');
      done();
    });
  });

  (0, _qunit.test)('function can return a promise with non-serializable content', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server.get('/users', function () {
      return new Promise(function (resolve) {
        resolve(new _emberCliMirageResponse['default'](200, { 'Content-Type': 'text/csv' }, 'firstname,lastname\nbob,dylan'));
      });
    });

    $.ajax({ method: 'GET', url: '/users' }).done(function (res) {
      assert.equal(res, 'firstname,lastname\nbob,dylan');
      done();
    });
  });

  (0, _qunit.test)('function can return a promise with serializable content', function (assert) {
    assert.expect(1);
    var done = assert.async();

    var user = this.schema.users.create({ name: 'Sam' });

    this.server.get('/users', function (schema) {
      return new Promise(function (resolve) {
        resolve(schema.users.all());
      });
    });

    $.ajax({ method: 'GET', url: '/users' }).done(function (res) {
      assert.deepEqual(res, { users: [{ id: user.id, name: 'Sam' }] });
      done();
    });
  });

  (0, _qunit.test)('function can return a promise with an empty string', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server.get('/users', function () {
      return new Promise(function (resolve) {
        resolve(new _emberCliMirageResponse['default'](200, { 'Content-Type': 'text/csv' }, ''));
      });
    });

    $.ajax({ method: 'GET', url: '/users' }).done(function (res) {
      assert.equal(res, '');
      done();
    });
  });

  (0, _qunit.test)('#serialize uses the default serializer on a model', function (assert) {
    this.schema.users.create({ name: 'Sam' });

    var user = this.schema.users.first();
    var json = this.functionHandler.serialize(user);

    assert.deepEqual(json, {
      user: {
        id: '1',
        name: 'Sam'
      }
    });
  });

  (0, _qunit.test)('#serialize uses the default serializer on a collection', function (assert) {
    this.schema.users.create({ name: 'Sam' });

    var users = this.schema.users.all();
    var json = this.functionHandler.serialize(users);

    assert.deepEqual(json, {
      users: [{ id: '1', name: 'Sam' }]
    });
  });

  (0, _qunit.test)('#serialize takes an optional serializer type', function (assert) {
    this.schema.users.create({ name: 'Sam', tall: true, evil: false });
    this.schema.users.create({ name: 'Ganondorf', tall: true, evil: true });

    var users = this.schema.users.all();
    var json = this.functionHandler.serialize(users, 'sparse-user');

    assert.deepEqual(json, {
      users: [{ id: '1', name: 'Sam', tall: true }, { id: '2', name: 'Ganondorf', tall: true }]
    });
  });

  (0, _qunit.test)('#serialize throws an error when trying to specify a serializer that doesnt exist', function (assert) {
    this.schema.users.create({ name: 'Sam' });

    var users = this.schema.users.all();

    assert.throws(function () {
      this.functionHandler.serialize(users, 'foo-user');
    }, /that serializer doesn't exist/);
  });

  (0, _qunit.test)('#serialize noops on plain JS arrays', function (assert) {
    this.server.schema.users.create({ name: 'Sam' });
    this.server.schema.users.create({ name: 'Sam' });
    this.server.schema.users.create({ name: 'Ganondorf' });

    var users = this.schema.users.all().models;
    var uniqueNames = (0, _lodashUniqBy['default'])(users, 'name');
    var serializedResponse = this.functionHandler.serialize(uniqueNames);

    assert.deepEqual(serializedResponse, uniqueNames);
  });

  (0, _qunit.test)('#serialize on a Collection takes an optional serializer type', function (assert) {
    this.server.schema.users.create({ name: 'Sam', tall: true, evil: false });
    this.server.schema.users.create({ name: 'Sam', tall: true, evil: false });
    this.server.schema.users.create({ name: 'Ganondorf', tall: true, evil: true });

    var users = this.schema.users.all().models;
    var uniqueNames = (0, _lodashUniqBy['default'])(users, 'name');
    var collection = new _emberCliMirage.Collection('user', uniqueNames);
    var json = this.functionHandler.serialize(collection, 'sparse-user');

    assert.deepEqual(json, {
      users: [{ id: '1', name: 'Sam', tall: true }, { id: '3', name: 'Ganondorf', tall: true }]
    });
  });
});
define('dummy/tests/integration/route-handlers/function-handler-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/route-handlers/function-handler-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/route-handlers/function-handler-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/route-handlers/get-shorthand-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/orm/collection', 'ember-cli-mirage/server', 'ember-cli-mirage/route-handlers/shorthands/get'], function (exports, _qunit, _emberCliMirage, _emberCliMirageOrmCollection, _emberCliMirageServer, _emberCliMirageRouteHandlersShorthandsGet) {

  (0, _qunit.module)('Integration | Route Handlers | GET shorthand', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        models: {
          author: _emberCliMirage.Model.extend({
            posts: (0, _emberCliMirage.hasMany)()
          }),
          post: _emberCliMirage.Model.extend({
            author: (0, _emberCliMirage.belongsTo)(),
            comments: (0, _emberCliMirage.hasMany)()
          }),
          comment: _emberCliMirage.Model.extend({
            post: (0, _emberCliMirage.belongsTo)()
          }),
          photo: _emberCliMirage.Model,
          'project-owner': _emberCliMirage.Model
        }
      });
      this.server.timing = 0;
      this.server.logging = false;

      this.authors = [{ id: 1, name: 'Link' }, { id: 2, name: 'Zelda' }, { id: 3, name: 'Epona' }];
      this.posts = [{ id: 1, title: 'Lorem', authorId: 1 }, { id: 2, title: 'Ipsum', authorId: 1 }];
      this.photos = [{ id: 1, title: 'Amazing', location: 'Hyrule' }, { id: 2, title: 'Photo', location: 'Goron City' }];
      this.projectOwners = [{ id: 1, name: 'Nintendo' }];
      this.server.db.loadData({
        authors: this.authors,
        posts: this.posts,
        photos: this.photos,
        projectOwners: this.projectOwners
      });

      this.schema = this.server.schema;
      this.serializer = new _emberCliMirage.JSONAPISerializer();
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('undefined shorthand returns the collection of models', function (assert) {
    var request = { url: '/authors' };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, undefined, '/authors');

    var authors = handler.handle(request);

    assert.equal(authors.models.length, 3);
    assert.ok(authors.models[0] instanceof _emberCliMirage.Model);
    assert.equal(authors.models[0].modelName, 'author');
  });

  (0, _qunit.test)('undefined shorthand ignores query params', function (assert) {
    var request = { url: '/authors?foo=bar' };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, undefined, '/authors');

    var authors = handler.handle(request);

    assert.equal(authors.models.length, 3);
    assert.ok(authors.models[0] instanceof _emberCliMirage.Model);
    assert.equal(authors.models[0].modelName, 'author');
  });

  (0, _qunit.test)('undefined shorthand can return a single model', function (assert) {
    var request = { url: '/authors/2', params: { id: 2 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, undefined, '/authors/:id');

    var author = handler.handle(request);

    assert.ok(author instanceof _emberCliMirage.Model);
    assert.equal(author.modelName, 'author');
    assert.equal(author.name, 'Zelda');
  });

  (0, _qunit.test)('undefined shorthand returns a 404 if a singular resource does not exist', function (assert) {
    var request = { url: '/authors/99', params: { id: 99 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, undefined, '/authors/:id');

    var author = handler.handle(request);

    assert.ok(author instanceof _emberCliMirage.Response);
    assert.equal(author.code, 404);
  });

  (0, _qunit.test)('undefined shorthand ignores query params for a singular resource', function (assert) {
    var request = { url: '/authors/2?foo=bar', params: { id: 2 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, undefined, '/authors/:id');

    var author = handler.handle(request);

    assert.ok(author instanceof _emberCliMirage.Model);
    assert.equal(author.modelName, 'author');
    assert.equal(author.name, 'Zelda');
  });

  (0, _qunit.test)('undefined shorthand with coalesce true returns the appropriate models', function (assert) {
    var request = { url: '/authors?ids[]=1&ids[]=3', queryParams: { ids: [1, 3] } };
    var options = { coalesce: true };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, undefined, '/authors', options);

    var authors = handler.handle(request);

    assert.equal(authors.models.length, 2);
    assert.deepEqual(authors.models.map(function (author) {
      return author.name;
    }), ['Link', 'Epona']);
  });

  (0, _qunit.test)('string shorthand returns the correct collection of models', function (assert) {
    var request = { url: '/people' };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, 'author');

    var authors = handler.handle(request);

    assert.equal(authors.models.length, 3);
    assert.ok(authors.models[0] instanceof _emberCliMirage.Model);
    assert.equal(authors.models[0].modelName, 'author');
  });

  (0, _qunit.test)('string shorthand with an id returns the correct model', function (assert) {
    var request = { url: '/people/2', params: { id: 2 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, 'author');

    var author = handler.handle(request);

    assert.ok(author instanceof _emberCliMirage.Model);
    assert.equal(author.modelName, 'author');
    assert.equal(author.name, 'Zelda');
  });

  (0, _qunit.test)('string shorthand with an id 404s if the model is not found', function (assert) {
    var request = { url: '/people/99', params: { id: 99 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, 'author');

    var author = handler.handle(request);

    assert.ok(author instanceof _emberCliMirage.Response);
    assert.equal(author.code, 404);
  });

  (0, _qunit.test)('string shorthand with coalesce returns the correct models', function (assert) {
    var request = { url: '/people?ids[]=1&ids[]=3', queryParams: { ids: [1, 3] } };
    var options = { coalesce: true };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, 'author', '/people', options);

    var authors = handler.handle(request);

    assert.equal(authors.models.length, 2);
    assert.deepEqual(authors.models.map(function (author) {
      return author.name;
    }), ['Link', 'Epona']);
  });

  (0, _qunit.test)('array shorthand returns the correct models', function (assert) {
    var url = '/home';
    var request = { url: url };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, ['authors', 'photos'], url);

    var models = handler.handle(request);

    assert.ok(models[0] instanceof _emberCliMirageOrmCollection['default']);
    assert.equal(models[0].modelName, 'author');
    assert.equal(models[0].models.length, this.authors.length);

    assert.ok(models[1] instanceof _emberCliMirageOrmCollection['default']);
    assert.equal(models[1].modelName, 'photo');
    assert.equal(models[1].models.length, this.photos.length);
  });

  (0, _qunit.test)('array shorthand for a singular resource errors', function (assert) {
    var url = '/authors/1';
    var request = { url: url, params: { id: 1 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, ['author', 'posts'], url);

    assert.throws(function () {
      handler.handle(request);
    }, /create a serializer/);
  });

  (0, _qunit.test)('shorthand for list of models with a dash in their name', function (assert) {
    var url = '/project-owners';
    var request = { url: url };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, undefined, url);
    var models = handler.handle(request);

    assert.equal(models.models.length, 1);
    assert.ok(models.models[0] instanceof _emberCliMirage.Model);
    assert.equal(models.models[0].modelName, 'project-owner');
  });

  (0, _qunit.test)('if a shorthand tries to access an unknown type it throws an error', function (assert) {
    var url = '/foobars';
    var request = { url: url };
    var handler = new _emberCliMirageRouteHandlersShorthandsGet['default'](this.schema, this.serializer, undefined, url);

    assert.throws(function () {
      handler.handle(request);
    }, /model doesn't exist/);
  });
});
define('dummy/tests/integration/route-handlers/get-shorthand-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/route-handlers/get-shorthand-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/route-handlers/get-shorthand-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/route-handlers/head-shorthand-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/server', 'ember-cli-mirage/route-handlers/shorthands/head'], function (exports, _qunit, _emberCliMirage, _emberCliMirageServer, _emberCliMirageRouteHandlersShorthandsHead) {

  (0, _qunit.module)('Integration | Route Handlers | HEAD shorthand', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        models: {
          author: _emberCliMirage.Model,
          photo: _emberCliMirage.Model
        }
      });
      this.server.timing = 0;
      this.server.logging = false;

      this.authors = [{ id: 1, name: 'Link' }, { id: 2, name: 'Zelda' }, { id: 3, name: 'Epona' }];
      this.photos = [{ id: 1, title: 'Amazing', location: 'Hyrule' }, { id: 2, title: 'Photo', location: 'Goron City' }];
      this.server.db.loadData({
        authors: this.authors,
        photos: this.photos
      });

      this.schema = this.server.schema;
      this.serializer = new _emberCliMirage.JSONAPISerializer();
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('undefined shorthand with an ID that is not in the DB will return a 404 Response', function (assert) {
    var request = { url: '/authors', params: { id: 101 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsHead['default'](this.schema, this.serializer, undefined, '/authors');

    var response = handler.handle(request);

    assert.ok(response instanceof _emberCliMirage.Response);
    assert.equal(response.code, 404);
  });

  (0, _qunit.test)('undefined shorthand with an ID that is in the DB will return a 204 Response', function (assert) {
    var request = { url: '/authors', params: { id: 1 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsHead['default'](this.schema, this.serializer, undefined, '/authors');

    var response = handler.handle(request);

    assert.ok(response instanceof _emberCliMirage.Response);
    assert.equal(response.code, 204);
  });

  (0, _qunit.test)('undefined shorthand with coalesce true will return a 204 response if one of the IDs are found', function (assert) {
    var request = { url: '/authors?ids[]=1&ids[]=3', queryParams: { ids: [1, 3] } };
    var options = { coalesce: true };
    var handler = new _emberCliMirageRouteHandlersShorthandsHead['default'](this.schema, this.serializer, undefined, '/authors', options);

    var response = handler.handle(request);

    assert.ok(response instanceof _emberCliMirage.Response);
    assert.equal(response.code, 204);
  });

  (0, _qunit.test)('undefined shorthand string (no id) shorthand returns a 204 (regardless of the length of the collection)', function (assert) {
    var request = { url: '/authors' };
    var handler = new _emberCliMirageRouteHandlersShorthandsHead['default'](this.schema, this.serializer, undefined, '/authors');

    var response = handler.handle(request);

    assert.ok(response instanceof _emberCliMirage.Response);
    assert.equal(response.code, 204);
  });

  (0, _qunit.test)('string shorthand with an ID that is not in the DB will return a 404 Response', function (assert) {
    var request = { url: '/authors', params: { id: 101 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsHead['default'](this.schema, this.serializer, 'author');

    var response = handler.handle(request);

    assert.ok(response instanceof _emberCliMirage.Response);
    assert.equal(response.code, 404);
  });

  (0, _qunit.test)('string shorthand with an ID that is in the DB will return a 204 Response', function (assert) {
    var request = { url: '/authors', params: { id: 1 } };
    var handler = new _emberCliMirageRouteHandlersShorthandsHead['default'](this.schema, this.serializer, 'author');

    var response = handler.handle(request);

    assert.ok(response instanceof _emberCliMirage.Response);
    assert.equal(response.code, 204);
  });

  (0, _qunit.test)('string shorthand with coalesce true will return a 204 response if one of the IDs are found', function (assert) {
    var request = { url: '/authors?ids[]=1&ids[]=3', queryParams: { ids: [1, 3] } };
    var options = { coalesce: true };
    var handler = new _emberCliMirageRouteHandlersShorthandsHead['default'](this.schema, this.serializer, 'author', '/people', options);

    var response = handler.handle(request);

    assert.ok(response instanceof _emberCliMirage.Response);
    assert.equal(response.code, 204);
  });

  (0, _qunit.test)('string shorthand string (no id) shorthand returns a 204 (regardless of the length of the collection)', function (assert) {
    var request = { url: '/authors' };
    var handler = new _emberCliMirageRouteHandlersShorthandsHead['default'](this.schema, this.serializer, 'author');

    var response = handler.handle(request);

    assert.ok(response instanceof _emberCliMirage.Response);
    assert.equal(response.code, 204);
  });
});
define('dummy/tests/integration/route-handlers/head-shorthand-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/route-handlers/head-shorthand-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/route-handlers/head-shorthand-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/route-handlers/post-shorthand-test', ['exports', 'qunit', 'ember-cli-mirage/server', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/route-handlers/shorthands/post', 'ember-cli-mirage/serializers/json-api-serializer'], function (exports, _qunit, _emberCliMirageServer, _emberCliMirageOrmModel, _emberCliMirageRouteHandlersShorthandsPost, _emberCliMirageSerializersJsonApiSerializer) {

  (0, _qunit.module)('Integration | Route Handlers | POST shorthand', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        models: {
          author: _emberCliMirageOrmModel['default'].extend({})
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
      this.schema = this.server.schema;

      this.serializer = new _emberCliMirageSerializersJsonApiSerializer['default']();

      this.body = {
        data: {
          type: 'authors',
          attributes: {
            'first-name': 'Ganon',
            'last-name': 'Dorf'
          }
        }
      };
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('string shorthand creates a record of the specified type and returns the new model', function (assert) {
    var request = { requestBody: JSON.stringify(this.body), url: '/people' };
    var handler = new _emberCliMirageRouteHandlersShorthandsPost['default'](this.schema, this.serializer, 'author');

    var model = handler.handle(request);

    assert.equal(this.schema.db.authors.length, 1);
    assert.ok(model instanceof _emberCliMirageOrmModel['default']);
    assert.equal(model.modelName, 'author');
    assert.equal(model.firstName, 'Ganon');
  });

  (0, _qunit.test)('query params are ignored', function (assert) {
    var request = { requestBody: JSON.stringify(this.body), url: '/authors?foo=bar', queryParams: { foo: 'bar' } };
    var handler = new _emberCliMirageRouteHandlersShorthandsPost['default'](this.schema, this.serializer, 'author');

    var model = handler.handle(request);

    assert.equal(this.schema.db.authors.length, 1);
    assert.ok(model instanceof _emberCliMirageOrmModel['default']);
    assert.equal(model.modelName, 'author');
    assert.equal(model.firstName, 'Ganon');
  });

  (0, _qunit.test)('undefined shorthand creates a record and returns the new model', function (assert) {
    var request = { requestBody: JSON.stringify(this.body), url: '/authors' };
    var handler = new _emberCliMirageRouteHandlersShorthandsPost['default'](this.schema, this.serializer, null, '/authors');

    var model = handler.handle(request);

    assert.equal(this.schema.db.authors.length, 1);
    assert.ok(model instanceof _emberCliMirageOrmModel['default']);
    assert.equal(model.modelName, 'author');
    assert.equal(model.firstName, 'Ganon');
  });

  (0, _qunit.test)('if a shorthand tries to access an unknown type it throws an error', function (assert) {
    var request = { requestBody: JSON.stringify(this.body), url: '/foobars' };
    var handler = new _emberCliMirageRouteHandlersShorthandsPost['default'](this.schema, this.serializer, 'foobar');

    assert.throws(function () {
      handler.handle(request);
    }, /model doesn't exist/);
    assert.ok(true);
  });
});
define('dummy/tests/integration/route-handlers/post-shorthand-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/route-handlers/post-shorthand-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/route-handlers/post-shorthand-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/route-handlers/put-shorthand-test', ['exports', 'qunit', 'ember-cli-mirage/route-handlers/shorthands/put', 'ember-cli-mirage/server', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/serializers/json-api-serializer'], function (exports, _qunit, _emberCliMirageRouteHandlersShorthandsPut, _emberCliMirageServer, _emberCliMirageOrmModel, _emberCliMirageSerializersJsonApiSerializer) {

  (0, _qunit.module)('Integration | Route Handlers | PUT shorthand', {

    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        models: {
          author: _emberCliMirageOrmModel['default'].extend()
        }
      });
      this.server.timing = 0;
      this.server.logging = false;

      this.authors = [{ id: 1, firstName: 'Ganon' }];
      this.server.db.loadData({
        authors: this.authors
      });

      this.schema = this.server.schema;
      this.serializer = new _emberCliMirageSerializersJsonApiSerializer['default']();

      this.body = {
        data: {
          type: 'authors',
          id: '1',
          attributes: {
            'first-name': 'Ganondorf'
          }
        }
      };
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }

  });

  (0, _qunit.test)('undefined shorthand updates the record and returns the model', function (assert) {
    var handler = new _emberCliMirageRouteHandlersShorthandsPut['default'](this.schema, this.serializer, undefined, '/authors/:id');
    var request = { requestBody: JSON.stringify(this.body), url: '/authors/1', params: { id: '1' } };

    var model = handler.handle(request);

    assert.equal(this.schema.db.authors.length, 1);
    assert.ok(model instanceof _emberCliMirageOrmModel['default']);
    assert.equal(model.modelName, 'author');
    assert.equal(model.firstName, 'Ganondorf');
  });

  (0, _qunit.test)('query params are ignored', function (assert) {
    var handler = new _emberCliMirageRouteHandlersShorthandsPut['default'](this.schema, this.serializer, 'author');
    var request = { requestBody: JSON.stringify(this.body), url: '/authors/1?foo=bar', params: { id: '1' }, queryParams: { foo: 'bar' } };

    var model = handler.handle(request);

    assert.equal(this.schema.db.authors.length, 1);
    assert.ok(model instanceof _emberCliMirageOrmModel['default']);
    assert.equal(model.modelName, 'author');
    assert.equal(model.firstName, 'Ganondorf');
  });

  (0, _qunit.test)('string shorthand updates the record of the specified type and returns the model', function (assert) {
    var handler = new _emberCliMirageRouteHandlersShorthandsPut['default'](this.schema, this.serializer, undefined, '/authors/:id');
    var request = { requestBody: JSON.stringify(this.body), url: '/authors/1', params: { id: '1' } };

    var model = handler.handle(request);

    assert.equal(this.schema.db.authors.length, 1);
    assert.ok(model instanceof _emberCliMirageOrmModel['default']);
    assert.equal(model.modelName, 'author');
    assert.equal(model.firstName, 'Ganondorf');
  });

  (0, _qunit.test)('if a shorthand tries to access an unknown type it throws an error', function (assert) {
    var handler = new _emberCliMirageRouteHandlersShorthandsPut['default'](this.schema, this.serializer, undefined, '/foobars/:id');
    var request = { requestBody: JSON.stringify(this.body), url: '/foobars/1', params: { id: '1' } };

    assert.throws(function () {
      handler.handle(request);
    }, /model doesn't exist/);
    assert.ok(true);
  });
});
define('dummy/tests/integration/route-handlers/put-shorthand-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/route-handlers/put-shorthand-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/route-handlers/put-shorthand-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/active-model-serializer-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _qunit) {

  (0, _qunit.module)('Integration | Serializer | ActiveModelSerializer', {
    beforeEach: function beforeEach() {
      var db = new _emberCliMirageDb['default']();
      this.schema = new _emberCliMirageOrmSchema['default'](db);
      this.schema.registerModels({
        wordSmith: _emberCliMirage.Model.extend({
          blogPosts: (0, _emberCliMirage.hasMany)()
        }),
        blogPost: _emberCliMirage.Model.extend({
          wordSmith: (0, _emberCliMirage.belongsTo)()
        }),
        user: _emberCliMirage.Model.extend({
          contactInfos: (0, _emberCliMirage.hasMany)()
        }),
        contactInfo: _emberCliMirage.Model.extend({
          user: (0, _emberCliMirage.belongsTo)()
        })
      });

      var link = this.schema.wordSmiths.create({ name: 'Link', age: 123 });
      link.createBlogPost({ title: 'Lorem' });
      link.createBlogPost({ title: 'Ipsum' });

      this.schema.wordSmiths.create({ name: 'Zelda', age: 230 });

      var user = this.schema.users.create({ name: 'John Peach', age: 123 });
      user.createContactInfo({ email: 'peach@bb.me' });
      user.createContactInfo({ email: 'john3000@mail.com' });

      this.schema.users.create({ name: 'Pine Apple', age: 230 });

      this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
        application: _emberCliMirage.ActiveModelSerializer,
        wordSmith: _emberCliMirage.ActiveModelSerializer.extend({
          attrs: ['id', 'name'],
          include: ['blogPosts']
        }),
        blogPost: _emberCliMirage.ActiveModelSerializer.extend({
          include: ['wordSmith']
        }),
        contactInfo: _emberCliMirage.ActiveModelSerializer.extend({
          include: ['user']
        }),
        user: _emberCliMirage.ActiveModelSerializer.extend({
          attrs: ['id', 'name'],
          include: ['contactInfos'],
          embed: true
        })
      });
    },

    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it sideloads associations and snake-cases relationships and attributes correctly for a model', function (assert) {
    var link = this.schema.wordSmiths.find(1);
    var result = this.registry.serialize(link);

    assert.deepEqual(result, {
      word_smith: {
        id: '1',
        name: 'Link',
        blog_post_ids: ['1', '2']
      },
      blog_posts: [{
        id: '1',
        title: 'Lorem',
        word_smith_id: '1'
      }, {
        id: '2',
        title: 'Ipsum',
        word_smith_id: '1'
      }]
    });
  });

  (0, _qunit.test)('it sideloads associations and snake-cases relationships and attributes correctly for a collection', function (assert) {
    var wordSmiths = this.schema.wordSmiths.all();
    var result = this.registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      word_smiths: [{
        id: '1',
        name: 'Link',
        blog_post_ids: ['1', '2']
      }, {
        id: '2',
        name: 'Zelda',
        blog_post_ids: []
      }],
      blog_posts: [{
        id: '1',
        title: 'Lorem',
        word_smith_id: '1'
      }, {
        id: '2',
        title: 'Ipsum',
        word_smith_id: '1'
      }]
    });
  });

  (0, _qunit.test)('it embeds associations and snake-cases relationships and attributes correctly for a collection', function (assert) {
    var users = this.schema.users.all();
    var result = this.registry.serialize(users);

    assert.deepEqual(result, {
      users: [{
        id: '1',
        name: 'John Peach',
        contact_infos: [{
          id: '1',
          email: 'peach@bb.me',
          user_id: '1'
        }, {
          id: '2',
          email: 'john3000@mail.com',
          user_id: '1'
        }]
      }, {
        id: '2',
        name: 'Pine Apple',
        contact_infos: []
      }]
    });
  });
});
define('dummy/tests/integration/serializers/active-model-serializer-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/active-model-serializer-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/active-model-serializer-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/associations/embedded-collection-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer', 'ember-cli-mirage/serializer-registry', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializer, _emberCliMirageSerializerRegistry, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Associations | Embedded Collections', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          posts: (0, _emberCliMirage.hasMany)('blogPost', { inverse: 'author' })
        }),
        blogPost: _emberCliMirage.Model.extend({
          author: (0, _emberCliMirage.belongsTo)('wordSmith', { inverse: 'posts' }),
          comments: (0, _emberCliMirage.hasMany)('fineComment', { inverse: 'post' })
        }),
        fineComment: _emberCliMirage.Model.extend({
          post: (0, _emberCliMirage.belongsTo)('blogPost')
        })
      });

      var wordSmith = this.schema.wordSmiths.create({ name: 'Link' });
      var blogPost = wordSmith.createPost({ title: 'Lorem' });
      blogPost.createComment({ text: 'pwned' });

      wordSmith.createPost({ title: 'Ipsum' });

      this.schema.wordSmiths.create({ name: 'Zelda' });

      this.BaseSerializer = _emberCliMirageSerializer['default'].extend({
        embed: true
      });
    },

    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it can embed a collection with a has-many relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        include: ['posts']
      })
    });

    var wordSmiths = this.schema.wordSmiths.all();
    var result = registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      wordSmiths: [{
        id: '1',
        name: 'Link',
        posts: [{ id: '1', title: 'Lorem' }, { id: '2', title: 'Ipsum' }]
      }, {
        id: '2',
        name: 'Zelda',
        posts: []
      }]
    });
  });

  (0, _qunit.test)('it can embed a collection with a chain of has-many relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        include: ['posts']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['comments']
      })
    });

    var wordSmiths = this.schema.wordSmiths.all();
    var result = registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      wordSmiths: [{
        id: '1',
        name: 'Link',
        posts: [{
          id: '1',
          title: 'Lorem',
          comments: [{ id: '1', text: 'pwned' }]
        }, {
          id: '2',
          title: 'Ipsum',
          comments: []
        }]
      }, {
        id: '2',
        name: 'Zelda',
        posts: []
      }]
    });
  });

  (0, _qunit.test)('it can embed a collection with a belongs-to relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      blogPost: this.BaseSerializer.extend({
        include: ['author']
      })
    });

    var blogPosts = this.schema.blogPosts.all();
    var result = registry.serialize(blogPosts);

    assert.deepEqual(result, {
      blogPosts: [{
        id: '1',
        title: 'Lorem',
        author: { id: '1', name: 'Link' }
      }, {
        id: '2',
        title: 'Ipsum',
        author: { id: '1', name: 'Link' }
      }]
    });
  });

  (0, _qunit.test)('it can embed a collection with a chain of belongs-to relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      fineComment: this.BaseSerializer.extend({
        include: ['post']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['author']
      })
    });

    var fineComments = this.schema.fineComments.all();
    var result = registry.serialize(fineComments);

    assert.deepEqual(result, {
      fineComments: [{
        id: '1',
        text: 'pwned',
        post: {
          id: '1',
          title: 'Lorem',
          author: { id: '1', name: 'Link' }
        }
      }]
    });
  });
});
define('dummy/tests/integration/serializers/base/associations/embedded-collection-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/associations/embedded-collection-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/associations/embedded-collection-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/associations/embedded-model-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer', 'ember-cli-mirage/serializer-registry', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializer, _emberCliMirageSerializerRegistry, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Associations | Embedded Models', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          posts: (0, _emberCliMirage.hasMany)('blogPost', { inverse: 'author' })
        }),
        blogPost: _emberCliMirage.Model.extend({
          author: (0, _emberCliMirage.belongsTo)('wordSmith', { inverse: 'posts' }),
          comments: (0, _emberCliMirage.hasMany)('fineComment', { inverse: 'post' })
        }),
        fineComment: _emberCliMirage.Model.extend({
          post: (0, _emberCliMirage.belongsTo)('blogPost')
        })
      });

      var wordSmith = this.schema.wordSmiths.create({ name: 'Link' });
      var post = wordSmith.createPost({ title: 'Lorem' });
      post.createComment({ text: 'pwned' });

      wordSmith.createPost({ title: 'Ipsum' });

      this.schema.wordSmiths.create({ name: 'Zelda' });

      this.BaseSerializer = _emberCliMirageSerializer['default'].extend({
        embed: true
      });
    },

    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it can embed has-many relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        include: ['posts']
      })
    });

    var link = this.schema.wordSmiths.find(1);
    var result = registry.serialize(link);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        posts: [{ id: '1', title: 'Lorem' }, { id: '2', title: 'Ipsum' }]
      }
    });
  });

  (0, _qunit.test)('it can embed a chain of has-many relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        include: ['posts']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['comments']
      })
    });

    var wordSmith = this.schema.wordSmiths.find(1);
    var result = registry.serialize(wordSmith);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        posts: [{ id: '1', title: 'Lorem', comments: [{ id: '1', text: 'pwned' }] }, { id: '2', title: 'Ipsum', comments: [] }]
      }
    });
  });

  (0, _qunit.test)('it can embed a belongs-to relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      blogPost: this.BaseSerializer.extend({
        embed: true,
        include: ['author']
      })
    });

    var blogPost = this.schema.blogPosts.find(1);
    var result = registry.serialize(blogPost);

    assert.deepEqual(result, {
      blogPost: {
        id: '1',
        title: 'Lorem',
        author: { id: '1', name: 'Link' }
      }
    });
  });

  (0, _qunit.test)('it can serialize a chain of belongs-to relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      fineComment: this.BaseSerializer.extend({
        include: ['post']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['author']
      })
    });

    var fineComment = this.schema.fineComments.find(1);
    var result = registry.serialize(fineComment);

    assert.deepEqual(result, {
      fineComment: {
        id: '1',
        text: 'pwned',
        post: {
          id: '1',
          title: 'Lorem',
          author: {
            id: '1', name: 'Link'
          }
        }
      }
    });
  });

  (0, _qunit.test)('it ignores relationships that refer to serialized ancestor resources', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        include: ['posts']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['author']
      })
    });

    var wordSmith = this.schema.wordSmiths.find(1);
    var result = registry.serialize(wordSmith);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        posts: [{ id: '1', title: 'Lorem' }, { id: '2', title: 'Ipsum' }]
      }
    });
  });

  (0, _qunit.test)('it ignores relationships that refer to serialized ancestor resources, multiple levels down', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        embed: true,
        include: ['posts']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['author', 'comments']
      }),
      fineComment: this.BaseSerializer.extend({
        include: ['post']
      })
    });

    var wordSmith = this.schema.wordSmiths.find(1);
    var result = registry.serialize(wordSmith);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        posts: [{ id: '1', title: 'Lorem', comments: [{ id: '1', text: 'pwned' }] }, { id: '2', title: 'Ipsum', comments: [] }]
      }
    });
  });
});
define('dummy/tests/integration/serializers/base/associations/embedded-model-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/associations/embedded-model-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/associations/embedded-model-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/associations/many-to-many-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/db', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/serializer-registry'], function (exports, _qunit, _emberCliMirage, _emberCliMirageDb, _emberCliMirageOrmSchema, _emberCliMirageSerializerRegistry) {

  (0, _qunit.module)('Integration | Serializers | Base | Associations | Many To Many', {
    beforeEach: function beforeEach() {
      var db = new _emberCliMirageDb['default']();

      var schema = new _emberCliMirageOrmSchema['default'](db, {
        contact: _emberCliMirage.Model.extend({
          addresses: (0, _emberCliMirage.hasMany)(),
          contactAddresses: (0, _emberCliMirage.hasMany)()
        }),
        address: _emberCliMirage.Model.extend({
          contacts: (0, _emberCliMirage.hasMany)(),
          contactAddresses: (0, _emberCliMirage.hasMany)()
        }),
        contactAddress: _emberCliMirage.Model.extend({
          contact: (0, _emberCliMirage.belongsTo)(),
          address: (0, _emberCliMirage.belongsTo)()
        })
      });

      var registry = new _emberCliMirageSerializerRegistry['default'](schema, {
        contact: _emberCliMirage.Serializer.extend({
          include: ['addresses'],
          addresses: function addresses(model) {
            var models = model.contactAddresses.models.map(function (ca) {
              return ca.address;
            });
            return new _emberCliMirage.Collection('address', models);
          }
        }),
        address: _emberCliMirage.Serializer.extend({
          include: ['contacts'],
          contacts: function contacts(model) {
            var models = model.contactAddresses.models.map(function (ca) {
              return ca.contact;
            });
            return new _emberCliMirage.Collection('contact', models);
          }
        })
      });

      var mario = schema.contacts.create({ name: 'Mario' });
      var newYork = schema.addresses.create({ street: 'Some New York Street' });
      var mushroomKingdom = schema.addresses.create({ street: 'Some Mushroom Kingdom Street' });

      schema.contactAddresses.create({ contact: mario, address: newYork });
      schema.contactAddresses.create({ contact: mario, address: mushroomKingdom });

      this.schema = schema;
      this.registry = registry;
    }
  });

  (0, _qunit.skip)('it serializes manyToMany if properly configured to passthrough', function (assert) {
    var contact = this.schema.contacts.find(1);
    var result = this.registry.serialize(contact);

    assert.deepEqual(result, {
      addresses: [{
        contactId: null, // side-effect of having a HasMany on the contactAddress side of things
        contactIds: ['1'],
        id: '1',
        street: 'Some New York Street'
      }, {
        contactId: null,
        contactIds: ['1'],
        id: '2',
        street: 'Some Mushroom Kingdom Street'
      }],
      contact: {
        addressId: null, // side-effect of having a HasMany on the contactAddress side of things
        addressIds: ['1', '2'],
        id: '1',
        name: 'Mario'
      }
    });
  });
});
define('dummy/tests/integration/serializers/base/associations/many-to-many-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/associations/many-to-many-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/associations/many-to-many-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/associations/sideloading-assorted-collections-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage/serializer', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _emberCliMirageSerializer, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Associations | Sideloading Assorted Collections', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          blogPosts: (0, _emberCliMirage.hasMany)()
        }),
        blogPost: _emberCliMirage.Model,
        greatPhoto: _emberCliMirage.Model
      });

      var BaseSerializer = _emberCliMirageSerializer['default'].extend({
        embed: false
      });
      this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
        application: BaseSerializer,
        wordSmith: BaseSerializer.extend({
          include: ['blogPosts']
        }),
        greatPhoto: BaseSerializer.extend({
          attrs: ['id', 'title']
        })
      });
      this.wordSmiths = [{ id: '1', name: 'Link', blogPostIds: ['1', '2'] }, { id: '2', name: 'Zelda', blogPostIds: [] }, { id: '3', name: 'Epona', blogPostIds: [] }];
      this.blogPosts = [{ id: '1', title: 'Lorem' }, { id: '2', title: 'Ipsum' }];
      this.greatPhotos = [{ id: '1', title: 'Amazing', location: 'Hyrule' }, { id: '2', title: 'greatPhoto', location: 'Goron City' }];
      this.schema.db.loadData({
        wordSmiths: this.wordSmiths,
        blogPosts: this.blogPosts,
        greatPhotos: this.greatPhotos
      });
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  /*
    This is a strange response from a route handler, but it's used in the array get shorthand. Deprecate that shorthand?
  */
  (0, _qunit.test)('it can sideload an array of assorted collections that have relationships', function (assert) {
    var result = this.registry.serialize([this.schema.wordSmiths.all(), this.schema.greatPhotos.all()]);

    assert.deepEqual(result, {
      wordSmiths: this.wordSmiths,
      blogPosts: this.blogPosts,
      greatPhotos: this.greatPhotos.map(function (attrs) {
        delete attrs.location;
        return attrs;
      })
    });
  });
});
define('dummy/tests/integration/serializers/base/associations/sideloading-assorted-collections-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/associations/sideloading-assorted-collections-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/associations/sideloading-assorted-collections-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/associations/sideloading-collection-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer', 'ember-cli-mirage/serializer-registry', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirage, _emberCliMirageDb, _emberCliMirageSerializer, _emberCliMirageSerializerRegistry, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Associations | Sideloading Collections', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          posts: (0, _emberCliMirage.hasMany)('blog-post')
        }),
        blogPost: _emberCliMirage.Model.extend({
          author: (0, _emberCliMirage.belongsTo)('word-smith'),
          comments: (0, _emberCliMirage.hasMany)('fine-comment')
        }),
        fineComment: _emberCliMirage.Model.extend({
          post: (0, _emberCliMirage.belongsTo)('blog-post')
        })
      });

      var link = this.schema.wordSmiths.create({ name: 'Link' });
      var blogPost = link.createPost({ title: 'Lorem' });
      link.createPost({ title: 'Ipsum' });

      blogPost.createComment({ text: 'pwned' });

      var zelda = this.schema.wordSmiths.create({ name: 'Zelda' });
      zelda.createPost({ title: 'Zeldas blogPost' });

      this.BaseSerializer = _emberCliMirageSerializer['default'].extend({
        embed: false
      });
    },

    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it throws an error if embed is false and root is false', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      wordSmith: this.BaseSerializer.extend({
        root: false,
        include: ['posts']
      })
    });

    var wordSmiths = this.schema.wordSmiths.all();

    assert.throws(function () {
      registry.serialize(wordSmiths);
    }, /disables the root/);
  });

  (0, _qunit.test)('it can sideload an empty collection', function (assert) {
    this.schema.db.emptyData();
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        include: ['posts']
      })
    });

    var result = registry.serialize(this.schema.wordSmiths.all());

    assert.deepEqual(result, {
      wordSmiths: []
    });
  });

  (0, _qunit.test)('it can sideload a collection with a has-many relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        embed: false,
        include: ['posts']
      })
    });

    var wordSmiths = this.schema.wordSmiths.all();
    var result = registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      wordSmiths: [{ id: '1', name: 'Link', postIds: ['1', '2'] }, { id: '2', name: 'Zelda', postIds: ['3'] }],
      blogPosts: [{ id: '1', title: 'Lorem' }, { id: '2', title: 'Ipsum' }, { id: '3', title: 'Zeldas blogPost' }]
    });
  });

  (0, _qunit.test)('it can sideload a collection with a chain of has-many relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        embed: false,
        include: ['posts']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['comments']
      })
    });

    var wordSmiths = this.schema.wordSmiths.all();
    var result = registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      wordSmiths: [{ id: '1', name: 'Link', postIds: ['1', '2'] }, { id: '2', name: 'Zelda', postIds: ['3'] }],
      blogPosts: [{ id: '1', title: 'Lorem', commentIds: ['1'] }, { id: '2', title: 'Ipsum', commentIds: [] }, { id: '3', title: 'Zeldas blogPost', commentIds: [] }],
      fineComments: [{ id: '1', text: 'pwned' }]
    });
  });

  (0, _qunit.test)('it avoids circularity when serializing a collection', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        embed: false,
        include: ['posts']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['author']
      })
    });

    var wordSmiths = this.schema.wordSmiths.all();
    var result = registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      wordSmiths: [{ id: '1', name: 'Link', postIds: ['1', '2'] }, { id: '2', name: 'Zelda', postIds: ['3'] }],
      blogPosts: [{ id: '1', title: 'Lorem', authorId: '1' }, { id: '2', title: 'Ipsum', authorId: '1' }, { id: '3', title: 'Zeldas blogPost', authorId: '2' }]
    });
  });

  (0, _qunit.test)('it can sideload a collection with a belongs-to relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      blogPost: this.BaseSerializer.extend({
        embed: false,
        include: ['author']
      })
    });

    var blogPosts = this.schema.blogPosts.all();
    var result = registry.serialize(blogPosts);

    assert.deepEqual(result, {
      blogPosts: [{ id: '1', title: 'Lorem', authorId: '1' }, { id: '2', title: 'Ipsum', authorId: '1' }, { id: '3', title: 'Zeldas blogPost', authorId: '2' }],
      wordSmiths: [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }]
    });
  });

  (0, _qunit.test)('it can sideload a collection with a chain of belongs-to relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      fineComment: this.BaseSerializer.extend({
        embed: false,
        include: ['post']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['author']
      })
    });

    var fineComments = this.schema.fineComments.all();
    var result = registry.serialize(fineComments);

    assert.deepEqual(result, {
      fineComments: [{ id: '1', text: 'pwned', postId: '1' }],
      blogPosts: [{ id: '1', title: 'Lorem', authorId: '1' }],
      wordSmiths: [{ id: '1', name: 'Link' }]
    });
  });
});
define('dummy/tests/integration/serializers/base/associations/sideloading-collection-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/associations/sideloading-collection-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/associations/sideloading-collection-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/associations/sideloading-model-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer', 'ember-cli-mirage/serializer-registry', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirage, _emberCliMirageDb, _emberCliMirageSerializer, _emberCliMirageSerializerRegistry, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Associations | Sideloading Models', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          posts: (0, _emberCliMirage.hasMany)('blog-post')
        }),
        blogPost: _emberCliMirage.Model.extend({
          author: (0, _emberCliMirage.belongsTo)('word-smith'),
          comments: (0, _emberCliMirage.hasMany)('fine-comment')
        }),
        fineComment: _emberCliMirage.Model.extend({
          post: (0, _emberCliMirage.belongsTo)('blog-post')
        })
      });

      var wordSmith = this.schema.wordSmiths.create({ name: 'Link' });
      var blogPost = wordSmith.createPost({ title: 'Lorem' });
      blogPost.createComment({ text: 'pwned' });

      wordSmith.createPost({ title: 'Ipsum' });

      this.schema.wordSmiths.create({ name: 'Zelda' });

      this.BaseSerializer = _emberCliMirageSerializer['default'].extend({
        embed: false
      });
    },

    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it throws an error if embed is false and root is false', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      wordSmith: this.BaseSerializer.extend({
        root: false,
        include: ['posts']
      })
    });

    var link = this.schema.wordSmiths.find(1);
    assert.throws(function () {
      registry.serialize(link);
    }, /disables the root/);
  });

  (0, _qunit.test)('it can sideload a model with a has-many relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        include: ['posts']
      })
    });

    var link = this.schema.wordSmiths.find(1);
    var result = registry.serialize(link);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        postIds: ['1', '2']
      },
      blogPosts: [{ id: '1', title: 'Lorem' }, { id: '2', title: 'Ipsum' }]
    });
  });

  (0, _qunit.test)('it can sideload a model with a chain of has-many relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        include: ['posts']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['comments']
      })
    });

    var link = this.schema.wordSmiths.find(1);
    var result = registry.serialize(link);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        postIds: ['1', '2']
      },
      blogPosts: [{ id: '1', title: 'Lorem', commentIds: ['1'] }, { id: '2', title: 'Ipsum', commentIds: [] }],
      fineComments: [{ id: '1', text: 'pwned' }]
    });
  });

  (0, _qunit.test)('it avoids circularity when serializing a model', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      wordSmith: this.BaseSerializer.extend({
        include: ['posts']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['author']
      })
    });

    var link = this.schema.wordSmiths.find(1);
    var result = registry.serialize(link);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        postIds: ['1', '2']
      },
      blogPosts: [{ id: '1', title: 'Lorem', authorId: '1' }, { id: '2', title: 'Ipsum', authorId: '1' }]
    });
  });

  (0, _qunit.test)('it can sideload a model with a belongs-to relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      blogPost: this.BaseSerializer.extend({
        include: ['author']
      })
    });

    var blogPost = this.schema.blogPosts.find(1);
    var result = registry.serialize(blogPost);

    assert.deepEqual(result, {
      blogPost: {
        id: '1', title: 'Lorem', authorId: '1'
      },
      wordSmiths: [{ id: '1', name: 'Link' }]
    });
  });

  (0, _qunit.test)('it can sideload a model with a chain of belongs-to relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: this.BaseSerializer,
      fineComment: this.BaseSerializer.extend({
        include: ['post']
      }),
      blogPost: this.BaseSerializer.extend({
        include: ['author']
      })
    });

    var fineComment = this.schema.fineComments.find(1);
    var result = registry.serialize(fineComment);

    assert.deepEqual(result, {
      fineComment: {
        id: '1', text: 'pwned', postId: '1'
      },
      blogPosts: [{ id: '1', title: 'Lorem', authorId: '1' }],
      wordSmiths: [{ id: '1', name: 'Link' }]
    });
  });
});
define('dummy/tests/integration/serializers/base/associations/sideloading-model-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/associations/sideloading-model-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/associations/sideloading-model-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/assorted-collections-test', ['exports', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage/serializer', 'dummy/tests/integration/serializers/schema-helper', 'qunit'], function (exports, _emberCliMirageSerializerRegistry, _emberCliMirageSerializer, _dummyTestsIntegrationSerializersSchemaHelper, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Assorted Collections', {
    beforeEach: function beforeEach() {
      this.schema = _dummyTestsIntegrationSerializersSchemaHelper['default'].setup();
      this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
        greatPhoto: _emberCliMirageSerializer['default'].extend({
          attrs: ['id', 'title']
        })
      });
      this.wordSmiths = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }, { id: '3', name: 'Epona' }];
      this.greatPhotos = [{ id: '1', title: 'Amazing', location: 'Hyrule' }, { id: '2', title: 'greatPhoto', location: 'Goron City' }];
      this.schema.db.loadData({
        wordSmiths: this.wordSmiths,
        greatPhotos: this.greatPhotos
      });
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('an array of assorted collections can be serialized', function (assert) {
    var result = this.registry.serialize([this.schema.wordSmiths.all(), this.schema.greatPhotos.all()]);

    assert.deepEqual(result, {
      wordSmiths: this.wordSmiths,
      greatPhotos: this.greatPhotos.map(function (attrs) {
        delete attrs.location;
        return attrs;
      })
    });
  });
});
define('dummy/tests/integration/serializers/base/assorted-collections-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/assorted-collections-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/assorted-collections-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/attribute-key-formatting-test', ['exports', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage/serializer', 'dummy/tests/integration/serializers/schema-helper', 'ember-cli-mirage/utils/inflector', 'qunit'], function (exports, _emberCliMirageSerializerRegistry, _emberCliMirageSerializer, _dummyTestsIntegrationSerializersSchemaHelper, _emberCliMirageUtilsInflector, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Attribute Key Formatting', {
    beforeEach: function beforeEach() {
      this.schema = _dummyTestsIntegrationSerializersSchemaHelper['default'].setup();
      this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
        wordSmith: _emberCliMirageSerializer['default'].extend({
          keyForAttribute: function keyForAttribute(key) {
            return (0, _emberCliMirageUtilsInflector.camelize)(key);
          }
        })
      });
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('keyForAttribute formats the attributes of a model', function (assert) {
    var wordSmith = this.schema.wordSmiths.create({
      id: 1,
      'first-name': 'Link',
      'last-name': 'Jackson',
      age: 323
    });

    var result = this.registry.serialize(wordSmith);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        firstName: 'Link',
        lastName: 'Jackson',
        age: 323
      }
    });
  });

  (0, _qunit.test)('keyForAttribute also formats the models in a collections', function (assert) {
    this.schema.wordSmiths.create({ id: 1, 'first-name': 'Link', 'last-name': 'Jackson' });
    this.schema.wordSmiths.create({ id: 2, 'first-name': 'Zelda', 'last-name': 'Brown' });
    var wordSmiths = this.schema.wordSmiths.all();

    var result = this.registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      wordSmiths: [{ id: '1', firstName: 'Link', lastName: 'Jackson' }, { id: '2', firstName: 'Zelda', lastName: 'Brown' }]
    });
  });
});
define('dummy/tests/integration/serializers/base/attribute-key-formatting-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/attribute-key-formatting-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/attribute-key-formatting-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/attrs-test', ['exports', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage/serializer', 'dummy/tests/integration/serializers/schema-helper', 'qunit'], function (exports, _emberCliMirageSerializerRegistry, _emberCliMirageSerializer, _dummyTestsIntegrationSerializersSchemaHelper, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Attrs List', {
    beforeEach: function beforeEach() {
      this.schema = _dummyTestsIntegrationSerializersSchemaHelper['default'].setup();
      this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
        wordSmith: _emberCliMirageSerializer['default'].extend({
          attrs: ['id', 'name']
        })
      });
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it returns only the whitelisted attrs when serializing a model', function (assert) {
    var wordSmith = this.schema.wordSmiths.create({
      id: 1,
      name: 'Link',
      age: 123
    });

    var result = this.registry.serialize(wordSmith);
    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link'
      }
    });
  });

  (0, _qunit.test)('it returns only the whitelisted attrs when serializing a collection', function (assert) {
    var schema = this.schema;

    schema.wordSmiths.create({ id: 1, name: 'Link', age: 123 });
    schema.wordSmiths.create({ id: 2, name: 'Zelda', age: 456 });

    var collection = this.schema.wordSmiths.all();
    var result = this.registry.serialize(collection);

    assert.deepEqual(result, {
      wordSmiths: [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }]
    });
  });
});
define('dummy/tests/integration/serializers/base/attrs-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/attrs-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/attrs-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/basic-test', ['exports', 'ember-cli-mirage/serializer-registry', 'dummy/tests/integration/serializers/schema-helper', 'qunit', 'lodash/uniqBy'], function (exports, _emberCliMirageSerializerRegistry, _dummyTestsIntegrationSerializersSchemaHelper, _qunit, _lodashUniqBy) {

  (0, _qunit.module)('Integration | Serializers | Base | Basic', {
    beforeEach: function beforeEach() {
      this.schema = _dummyTestsIntegrationSerializersSchemaHelper['default'].setup();
      this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema);
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it returns objects unaffected', function (assert) {
    var result = this.registry.serialize({ oh: 'hai' });

    assert.deepEqual(result, { oh: 'hai' });
  });

  (0, _qunit.test)('it returns arrays unaffected', function (assert) {
    var data = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    var result = this.registry.serialize(data);

    assert.deepEqual(result, data);
  });

  (0, _qunit.test)('it returns empty arrays unaffected', function (assert) {
    var result = this.registry.serialize([]);

    assert.deepEqual(result, []);
  });

  (0, _qunit.test)('it serializes a model by returning its attrs under a root', function (assert) {
    var wordSmith = this.schema.wordSmiths.create({
      id: 1,
      name: 'Link'
    });
    var result = this.registry.serialize(wordSmith);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link'
      }
    });
  });

  (0, _qunit.test)('it serializes a collection of models by returning an array of their attrs under a pluralized root', function (assert) {
    this.schema.wordSmiths.create({ id: 1, name: 'Link' });
    this.schema.wordSmiths.create({ id: 2, name: 'Zelda' });

    var wordSmiths = this.schema.wordSmiths.all();

    var result = this.registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      wordSmiths: [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }]
    });
  });

  (0, _qunit.test)('it can serialize an empty collection', function (assert) {
    var wordSmiths = this.schema.wordSmiths.all();
    var result = this.registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      wordSmiths: []
    });
  });

  (0, _qunit.test)('it returns POJAs of models unaffected', function (assert) {
    this.schema.wordSmiths.create({ name: 'Sam' });
    this.schema.wordSmiths.create({ name: 'Sam' });
    this.schema.wordSmiths.create({ name: 'Ganondorf' });

    var wordSmiths = this.schema.wordSmiths.all().models;
    var uniqueNames = (0, _lodashUniqBy['default'])(wordSmiths, 'name');
    var result = this.registry.serialize(uniqueNames);

    assert.deepEqual(result, uniqueNames);
  });
});
define('dummy/tests/integration/serializers/base/basic-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/basic-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/basic-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/full-request-test', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/server', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/serializer', 'qunit'], function (exports, _emberCliMirage, _emberCliMirageServer, _emberCliMirageOrmModel, _emberCliMirageSerializer, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Full Request', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        models: {
          author: _emberCliMirageOrmModel['default'].extend({
            posts: _emberCliMirage['default'].hasMany()
          }),
          post: _emberCliMirageOrmModel['default'].extend({
            author: _emberCliMirage['default'].belongsTo(),
            comments: _emberCliMirage['default'].hasMany()
          }),
          comment: _emberCliMirageOrmModel['default'].extend({
            post: _emberCliMirage['default'].belongsTo()
          })
        },
        serializers: {
          application: _emberCliMirageSerializer['default'].extend({
            embed: true,
            root: false
          }),
          author: _emberCliMirageSerializer['default'].extend({
            embed: true,
            attrs: ['id', 'first'],
            include: ['posts']
          }),
          comment: _emberCliMirageSerializer['default'].extend({
            embed: true,
            root: false,
            include: function include(request) {
              return request.queryParams.include_post ? ['post'] : [];
            }
          })
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('the appropriate serializer is used', function (assert) {
    assert.expect(1);
    var done = assert.async();
    var author = this.server.schema.authors.create({
      first: 'Link',
      last: 'of Hyrule',
      age: 323
    });
    author.createPost({ title: 'Lorem ipsum' });

    this.server.get('/authors/:id', function (schema, request) {
      var id = request.params.id;

      return schema.authors.find(id);
    });

    $.ajax({
      method: 'GET',
      url: '/authors/1'
    }).done(function (res) {
      assert.deepEqual(res, {
        author: {
          id: '1',
          first: 'Link',
          posts: [{ id: '1', title: 'Lorem ipsum' }]
        }
      });
      done();
    });
  });

  (0, _qunit.test)('components decoded', function (assert) {
    assert.expect(1);
    var done = assert.async();

    this.server.get('/authors/:id', function (schema, request) {
      var id = request.params.id;

      return { data: { id: id } };
    });

    $.ajax({
      method: 'GET',
      url: '/authors/%3A1'
    }).done(function (res) {
      assert.deepEqual(res, {
        data: { id: ':1' }
      });
      done();
    });
  });

  (0, _qunit.test)('a response falls back to the application serializer, if it exists', function (assert) {
    assert.expect(1);
    var done = assert.async();
    this.server.schema.posts.create({
      title: 'Lorem',
      date: '20001010'
    });

    this.server.get('/posts/:id', function (schema, request) {
      var id = request.params.id;

      return schema.posts.find(id);
    });

    $.ajax({
      method: 'GET',
      url: '/posts/1'
    }).done(function (res) {
      assert.deepEqual(res, {
        id: '1',
        title: 'Lorem',
        date: '20001010'
      });
      done();
    });
  });

  (0, _qunit.test)('serializer.include is invoked when it is a function', function (assert) {
    assert.expect(1);
    var done = assert.async();
    var post = this.server.schema.posts.create({
      title: 'Lorem',
      date: '20001010'
    });
    post.createComment({
      description: 'Lorem is the best'
    });

    this.server.get('/comments/:id', function (schema, request) {
      var id = request.params.id;

      return schema.comments.find(id);
    });

    $.ajax({
      method: 'GET',
      url: '/comments/1?include_post=true'
    }).done(function (res) {
      assert.deepEqual(res, {
        id: '1',
        description: 'Lorem is the best',
        post: {
          id: '1',
          title: 'Lorem',
          date: '20001010'
        }
      });
      done();
    });
  });
});
define('dummy/tests/integration/serializers/base/full-request-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/full-request-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/full-request-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/override-serialize-test', ['exports', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage/serializer', 'dummy/tests/integration/serializers/schema-helper', 'qunit'], function (exports, _emberCliMirageSerializerRegistry, _emberCliMirageSerializer, _dummyTestsIntegrationSerializersSchemaHelper, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Overriding Serialize', {
    beforeEach: function beforeEach() {
      this.schema = _dummyTestsIntegrationSerializersSchemaHelper['default'].setup();
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it can use a completely custom serialize function', function (assert) {
    this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      wordSmith: _emberCliMirageSerializer['default'].extend({
        serialize: function serialize() {
          return 'blah';
        }
      })
    });

    var wordSmith = this.schema.wordSmiths.create({
      id: 1,
      title: 'Link'
    });

    var result = this.registry.serialize(wordSmith);

    assert.deepEqual(result, 'blah');
  });

  (0, _qunit.test)('it can access the request in a custom serialize function', function (assert) {
    this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      wordSmith: _emberCliMirageSerializer['default'].extend({
        serialize: function serialize(response, request) {
          return request.queryParams.foo || 'blah';
        }
      })
    });

    var wordSmith = this.schema.wordSmiths.create({
      id: 1,
      title: 'Link'
    });

    var request = { url: '/word-smiths/1?foo=bar', params: { id: '1' }, queryParams: { foo: 'bar' } };
    var result = this.registry.serialize(wordSmith, request);

    assert.deepEqual(result, 'bar');
  });
});
define('dummy/tests/integration/serializers/base/override-serialize-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/override-serialize-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/override-serialize-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/root-test', ['exports', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage/serializer', 'dummy/tests/integration/serializers/schema-helper', 'qunit'], function (exports, _emberCliMirageSerializerRegistry, _emberCliMirageSerializer, _dummyTestsIntegrationSerializersSchemaHelper, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Root', {
    beforeEach: function beforeEach() {
      this.schema = _dummyTestsIntegrationSerializersSchemaHelper['default'].setup();
      this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
        wordSmith: _emberCliMirageSerializer['default'].extend({
          embed: true,
          root: false
        })
      });
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('if root is false, it serializes a model by returning its attrs', function (assert) {
    var wordSmith = this.schema.wordSmiths.create({
      id: '1',
      name: 'Link'
    });

    var result = this.registry.serialize(wordSmith);
    assert.deepEqual(result, {
      id: '1',
      name: 'Link'
    });
  });

  (0, _qunit.test)('if root is false, it serializes a collection of models by returning an array of their attrs', function (assert) {
    this.schema.wordSmiths.create({ id: 1, name: 'Link' });
    this.schema.wordSmiths.create({ id: 2, name: 'Zelda' });
    var wordSmiths = this.schema.wordSmiths.all();

    var result = this.registry.serialize(wordSmiths);

    assert.deepEqual(result, [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }]);
  });

  (0, _qunit.test)('if root is false, it serializes an empty collection by returning an empty array', function (assert) {
    var emptywordSmithCollection = this.schema.wordSmiths.all();
    var result = this.registry.serialize(emptywordSmithCollection);

    assert.deepEqual(result, []);
  });
});
define('dummy/tests/integration/serializers/base/root-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/root-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/root-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/serialize-array-of-models-test', ['exports', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage/serializer', 'dummy/tests/integration/serializers/schema-helper', 'qunit'], function (exports, _emberCliMirageSerializerRegistry, _emberCliMirageSerializer, _dummyTestsIntegrationSerializersSchemaHelper, _qunit) {

  (0, _qunit.module)('Integration | Serializers | Base | Array of Models', {
    beforeEach: function beforeEach() {
      this.schema = _dummyTestsIntegrationSerializersSchemaHelper['default'].setup();
      this.schema.wordSmiths.create({ id: 1, title: 'Link' });
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it applies correct serializer when the response is an array of models', function (assert) {
    assert.expect(1);

    var wordSmiths = this.schema.wordSmiths.all().filter(function () {
      return true;
    });
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      wordSmith: _emberCliMirageSerializer['default'].extend({
        serialize: function serialize() {
          assert.ok('serializer ran');
          return {};
        }
      })
    });

    registry.serialize(wordSmiths);
  });
});
define('dummy/tests/integration/serializers/base/serialize-array-of-models-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/serialize-array-of-models-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/serialize-array-of-models-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/base/serialize-ids-test', ['exports', 'qunit', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage'], function (exports, _qunit, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _emberCliMirage) {

  (0, _qunit.module)('Integration | Serializers | Base | Serialize ids', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          blogPosts: (0, _emberCliMirage.hasMany)(),
          specialPosts: (0, _emberCliMirage.hasMany)('blog-post', { inverse: 'specialAuthor' })
        }),
        blogPost: _emberCliMirage.Model
      });
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('if serializeIds is \'include\' it serializes ids of hasMany associations that are included', function (assert) {
    var ApplicationSerializer = _emberCliMirage.Serializer.extend({
      serializeIds: 'included'
    });
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: ApplicationSerializer,
      wordSmith: ApplicationSerializer.extend({
        include: ['blogPosts']
      })
    });

    var wordSmith = this.schema.wordSmiths.create({
      id: 1,
      name: 'Link'
    });
    wordSmith.createBlogPost();
    wordSmith.createBlogPost();
    wordSmith.createSpecialPost();
    var result = registry.serialize(wordSmith);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        blogPostIds: ['1', '2']
      },
      blogPosts: [{ id: '1' }, { id: '2' }]
    });
  });

  (0, _qunit.test)('if serializeIds is \'always\' it serializes ids of all hasMany associations', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.Serializer.extend({
        serializeIds: 'always'
      })
    });

    var wordSmith = this.schema.wordSmiths.create({
      id: 1,
      name: 'Link'
    });
    wordSmith.createBlogPost();
    wordSmith.createBlogPost();
    wordSmith.createSpecialPost();
    var result = registry.serialize(wordSmith);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        blogPostIds: ['1', '2'],
        specialPostIds: ['3']
      }
    });
  });
});
define('dummy/tests/integration/serializers/base/serialize-ids-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/base/serialize-ids-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/base/serialize-ids-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/collection-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | Serializers | JSON API Serializer | Associations | Collection', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          posts: (0, _emberCliMirage.hasMany)('blogPost', { inverse: 'author' })
        }),
        blogPost: _emberCliMirage.Model.extend({
          author: (0, _emberCliMirage.belongsTo)('wordSmith', { inverse: 'posts' }),
          comments: (0, _emberCliMirage.hasMany)('fineComment', { inverse: 'post' })
        }),
        fineComment: _emberCliMirage.Model.extend({
          post: (0, _emberCliMirage.belongsTo)('blogPost')
        })
      });
    }
  });

  (0, _qunit.test)('it includes all relationships for a collection, regardless of being included', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer
    });
    this.schema.wordSmiths.create({ firstName: 'Link', age: 123 });
    this.schema.wordSmiths.create({ firstName: 'Zelda', age: 456 });

    var collection = this.schema.wordSmiths.all();
    var result = registry.serialize(collection);

    assert.deepEqual(result, {
      data: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link',
          age: 123
        },
        relationships: {
          'posts': {
            data: []
          }
        }
      }, {
        type: 'word-smiths',
        id: '2',
        attributes: {
          'first-name': 'Zelda',
          age: 456
        },
        relationships: {
          'posts': {
            data: []
          }
        }
      }]
    });
  });

  (0, _qunit.test)('it can serialize a collection with a has-many relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      wordSmith: _emberCliMirage.JSONAPISerializer.extend({
        include: ['posts']
      })
    });
    var link = this.schema.wordSmiths.create({ firstName: 'Link' });
    link.createPost({ title: 'Lorem' });
    link.createPost({ title: 'Ipsum' });
    this.schema.wordSmiths.create({ firstName: 'Zelda' });

    var collection = this.schema.wordSmiths.all();
    var result = registry.serialize(collection);

    assert.deepEqual(result, {
      data: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        },
        relationships: {
          'posts': {
            data: [{ type: 'blog-posts', id: '1' }, { type: 'blog-posts', id: '2' }]
          }
        }
      }, {
        type: 'word-smiths',
        id: '2',
        attributes: {
          'first-name': 'Zelda'
        },
        relationships: {
          'posts': {
            data: []
          }
        }
      }],
      included: [{
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'comments': {
            data: []
          },
          'author': {
            data: { type: 'word-smiths', id: '1' }
          }
        }
      }, {
        type: 'blog-posts',
        id: '2',
        attributes: {
          title: 'Ipsum'
        },
        relationships: {
          'comments': {
            data: []
          },
          'author': {
            data: { type: 'word-smiths', id: '1' }
          }
        }
      }]
    });
  });

  (0, _qunit.test)('it can serialize a collection with a chain of has-many relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      wordSmith: _emberCliMirage.JSONAPISerializer.extend({
        include: ['posts']
      }),
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['comments']
      })
    });

    var link = this.schema.wordSmiths.create({ firstName: 'Link' });
    var lorem = link.createPost({ title: 'Lorem' });
    lorem.createComment({ text: 'pwned' });
    link.createPost({ title: 'Ipsum' });
    this.schema.wordSmiths.create({ firstName: 'Zelda' });

    var collection = this.schema.wordSmiths.all();
    var result = registry.serialize(collection);

    assert.deepEqual(result, {
      data: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        },
        relationships: {
          'posts': {
            data: [{ type: 'blog-posts', id: '1' }, { type: 'blog-posts', id: '2' }]
          }
        }
      }, {
        type: 'word-smiths',
        id: '2',
        attributes: {
          'first-name': 'Zelda'
        },
        relationships: {
          'posts': {
            data: []
          }
        }
      }],
      included: [{
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'comments': {
            data: [{ type: 'fine-comments', id: '1' }]
          },
          'author': {
            data: { type: 'word-smiths', id: '1' }
          }
        }
      }, {
        type: 'fine-comments',
        id: '1',
        attributes: {
          text: 'pwned'
        },
        relationships: {
          'post': {
            data: { type: 'blog-posts', id: '1' }
          }
        }
      }, {
        type: 'blog-posts',
        id: '2',
        attributes: {
          title: 'Ipsum'
        },
        relationships: {
          'comments': {
            data: []
          },
          'author': {
            data: { type: 'word-smiths', id: '1' }
          }
        }
      }]
    });
  });

  (0, _qunit.test)('it can serialize a collection with a belongs-to relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['author']
      })
    });

    var link = this.schema.wordSmiths.create({ firstName: 'Link' });
    var post = link.createPost({ title: 'Lorem' });
    post.createComment();
    link.createPost({ title: 'Ipsum' });
    this.schema.wordSmiths.create({ firstName: 'Zelda' });

    var blogPosts = this.schema.blogPosts.all();
    var result = registry.serialize(blogPosts);

    assert.deepEqual(result, {
      data: [{
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'comments': {
            data: [{ type: 'fine-comments', id: '1' }]
          },
          'author': {
            data: { type: 'word-smiths', id: '1' }
          }
        }
      }, {
        type: 'blog-posts',
        id: '2',
        attributes: {
          title: 'Ipsum'
        },
        relationships: {
          'comments': {
            data: []
          },
          'author': {
            data: { type: 'word-smiths', id: '1' }
          }
        }
      }],
      included: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        },
        relationships: {
          'posts': {
            data: [{ type: 'blog-posts', id: '1' }, { type: 'blog-posts', id: '2' }]
          }
        }
      }]
    });
  });

  (0, _qunit.test)('it can serialize a collection with a chain of belongs-to relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      fineComment: _emberCliMirage.JSONAPISerializer.extend({
        include: ['post']
      }),
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['author']
      })
    });

    var link = this.schema.wordSmiths.create({ firstName: 'Link' });
    var post = link.createPost({ title: 'Lorem' });
    post.createComment({ text: 'pwned' });
    link.createPost({ title: 'Ipsum' });
    this.schema.wordSmiths.create({ firstName: 'Zelda' });

    var fineComments = this.schema.fineComments.all();
    var result = registry.serialize(fineComments);

    assert.deepEqual(result, {
      data: [{
        type: 'fine-comments',
        id: '1',
        attributes: {
          text: 'pwned'
        },
        relationships: {
          'post': {
            data: { type: 'blog-posts', id: '1' }
          }
        }
      }],
      included: [{
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'comments': {
            data: [{
              id: '1',
              type: 'fine-comments'
            }]
          },
          'author': {
            data: { type: 'word-smiths', id: '1' }
          }
        }
      }, {
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        },
        relationships: {
          'posts': {
            data: [{
              id: '1',
              type: 'blog-posts'
            }, {
              id: '2',
              type: 'blog-posts'
            }]
          }
        }
      }]
    });
  });

  (0, _qunit.test)('it can serialize a collection of models that have both belongs-to and has-many relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['author', 'comments']
      })
    });

    var link = this.schema.wordSmiths.create({ firstName: 'Link' });
    var post = link.createPost({ title: 'Lorem' });
    post.createComment({ text: 'pwned' });
    link.createPost({ title: 'Ipsum' });
    this.schema.wordSmiths.create({ firstName: 'Zelda' });

    var blogPost = this.schema.blogPosts.find(1);
    var result = registry.serialize(blogPost);

    assert.deepEqual(result, {
      data: {
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'author': {
            data: { type: 'word-smiths', id: '1' }
          },
          'comments': {
            data: [{ type: 'fine-comments', id: '1' }]
          }
        }
      },
      included: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        },
        relationships: {
          'posts': {
            data: [{
              id: '1',
              type: 'blog-posts'
            }, {
              id: '2',
              type: 'blog-posts'
            }]
          }
        }
      }, {
        type: 'fine-comments',
        id: '1',
        attributes: {
          'text': 'pwned'
        },
        relationships: {
          'post': {
            data: {
              id: '1',
              type: 'blog-posts'
            }
          }
        }
      }]
    });
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/collection-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/json-api-serializer/associations/collection-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/json-api-serializer/associations/collection-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/includes-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | Serializers | JSON API Serializer | Associations | Includes', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          blogPosts: (0, _emberCliMirage.hasMany)()
        }),

        blogPost: _emberCliMirage.Model.extend({
          wordSmith: (0, _emberCliMirage.belongsTo)(),
          fineComments: (0, _emberCliMirage.hasMany)()
        }),

        fineComment: _emberCliMirage.Model.extend({
          blogPost: (0, _emberCliMirage.belongsTo)(),
          category: (0, _emberCliMirage.belongsTo)()
        }),

        category: _emberCliMirage.Model.extend({
          labels: (0, _emberCliMirage.hasMany)()
        }),

        label: _emberCliMirage.Model.extend({})
      });
    }
  });

  (0, _qunit.test)('includes get serialized with correct serializer', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        attrs: ['title'],
        include: ['wordSmith']
      }),
      wordSmith: _emberCliMirage.JSONAPISerializer.extend({
        attrs: ['firstName']
      })
    });

    var post = this.schema.blogPosts.create({ title: 'We love Mirage!' });
    post.createWordSmith({ firstName: 'Sam' });

    var result = registry.serialize(post);

    assert.propEqual(result, {
      data: {
        type: 'blog-posts',
        id: '1',
        attributes: {
          'title': 'We love Mirage!'
        },
        relationships: {
          'fine-comments': {
            'data': []
          },
          'word-smith': {
            data: { type: 'word-smiths', id: '1' }
          }
        }
      },
      included: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Sam'
        },
        relationships: {
          'blog-posts': {
            data: [{ type: 'blog-posts', id: '1' }]
          }
        }
      }]
    });
  });

  (0, _qunit.test)('query param includes work when serializing a model', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer
    });

    var post = this.schema.blogPosts.create();
    post.createWordSmith();
    post.createFineComment();
    post.createFineComment();

    var request = {
      queryParams: {
        include: 'word-smith,fine-comments'
      }
    };

    var result = registry.serialize(post, request);

    assert.propEqual(result, {
      data: {
        type: 'blog-posts',
        id: '1',
        attributes: {},
        relationships: {
          'word-smith': {
            data: { type: 'word-smiths', id: '1' }
          },
          'fine-comments': {
            data: [{ type: 'fine-comments', id: '1' }, { type: 'fine-comments', id: '2' }]
          }
        }
      },
      included: [{
        type: 'word-smiths',
        id: '1',
        attributes: {},
        relationships: {
          'blog-posts': {
            data: [{ type: 'blog-posts', id: '1' }]
          }
        }
      }, {
        type: 'fine-comments',
        id: '1',
        attributes: {},
        relationships: {
          'blog-post': {
            data: { type: 'blog-posts', id: '1' }
          },
          category: { data: null }
        }
      }, {
        type: 'fine-comments',
        id: '2',
        attributes: {},
        relationships: {
          'blog-post': {
            data: { type: 'blog-posts', id: '1' }
          },
          category: { data: null }
        }
      }]
    });
  });

  (0, _qunit.test)('query param includes work when serializing a collection', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer
    });

    var post1 = this.schema.blogPosts.create();
    post1.createWordSmith();
    post1.createFineComment();
    post1.createFineComment();
    this.schema.blogPosts.create();

    var request = {
      queryParams: {
        include: 'word-smith,fine-comments'
      }
    };

    var result = registry.serialize(this.schema.blogPosts.all(), request);

    assert.propEqual(result, {
      data: [{
        type: 'blog-posts',
        id: '1',
        attributes: {},
        relationships: {
          'word-smith': {
            data: { type: 'word-smiths', id: '1' }
          },
          'fine-comments': {
            data: [{ type: 'fine-comments', id: '1' }, { type: 'fine-comments', id: '2' }]
          }
        }
      }, {
        type: 'blog-posts',
        id: '2',
        attributes: {},
        relationships: {
          'word-smith': {
            data: null
          },
          'fine-comments': {
            data: []
          }
        }
      }],
      included: [{
        type: 'word-smiths',
        id: '1',
        attributes: {},
        relationships: {
          'blog-posts': {
            data: [{ type: 'blog-posts', id: '1' }]
          }
        }
      }, {
        type: 'fine-comments',
        id: '1',
        attributes: {},
        relationships: {
          'blog-post': {
            data: { type: 'blog-posts', id: '1' }
          },
          category: { data: null }
        }
      }, {
        type: 'fine-comments',
        id: '2',
        attributes: {},
        relationships: {
          'blog-post': {
            data: { type: 'blog-posts', id: '1' }
          },
          category: { data: null }
        }
      }]
    });
  });

  (0, _qunit.test)('query param includes take precedence over default server includes', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['wordSmith']
      })
    });

    var post = this.schema.blogPosts.create();
    post.createWordSmith();
    post.createFineComment();
    post.createFineComment();

    var request = {
      queryParams: {
        include: 'fine-comments'
      }
    };

    var result = registry.serialize(post, request);

    assert.propEqual(result, {
      data: {
        type: 'blog-posts',
        id: '1',
        attributes: {},
        relationships: {
          'word-smith': {
            data: { type: 'word-smiths', id: '1' }
          },
          'fine-comments': {
            data: [{ type: 'fine-comments', id: '1' }, { type: 'fine-comments', id: '2' }]
          }
        }
      },
      included: [{
        type: 'fine-comments',
        id: '1',
        attributes: {},
        relationships: {
          'blog-post': {
            data: { type: 'blog-posts', id: '1' }
          },
          category: { data: null }
        }
      }, {
        type: 'fine-comments',
        id: '2',
        attributes: {},
        relationships: {
          'blog-post': {
            data: { type: 'blog-posts', id: '1' }
          },
          category: { data: null }
        }
      }]
    });
  });

  (0, _qunit.test)('query param includes support dot-paths when serializing a model', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer
    });

    this.schema.db.loadData({
      wordSmiths: [{ id: 1, name: 'Sam', blogPostIds: [2] }],
      blogPosts: [{ id: 2, wordSmithId: 1, fineCommentIds: [3], title: 'Lorem Ipsum' }],
      fineComments: [{ id: 3, text: 'Foo', blogPostId: 2, categoryId: 10 }],
      categories: [{ id: 10, foo: 'bar', labelIds: [20] }],
      labels: [{ id: 20, name: 'Economics' }]
    });
    var request = {
      queryParams: {
        include: 'wordSmith,fineComments.category.labels'
      }
    };
    var result = registry.serialize(this.schema.blogPosts.first(), request);

    assert.propEqual(result, {
      data: {
        type: 'blog-posts',
        id: '2',
        attributes: {
          title: 'Lorem Ipsum'
        },
        relationships: {
          'word-smith': {
            data: { type: 'word-smiths', id: '1' }
          },
          'fine-comments': {
            data: [{ type: 'fine-comments', id: '3' }]
          }
        }
      },
      included: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          name: 'Sam'
        },
        relationships: {
          'blog-posts': {
            data: [{ type: 'blog-posts', id: '2' }]
          }
        }
      }, {
        type: 'fine-comments',
        id: '3',
        attributes: {
          text: 'Foo'
        },
        relationships: {
          'blog-post': {
            data: { type: 'blog-posts', id: '2' }
          },
          'category': {
            data: { type: 'categories', id: '10' }
          }
        }
      }, {
        type: 'categories',
        id: '10',
        attributes: {
          foo: 'bar'
        },
        relationships: {
          'labels': {
            data: [{ type: 'labels', id: '20' }]
          }
        }
      }, {
        type: 'labels',
        id: '20',
        attributes: {
          name: 'Economics'
        }
      }]
    });
  });

  (0, _qunit.test)('query param includes support dot-paths when serializing a collection', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer
    });

    this.schema.db.loadData({
      wordSmiths: [{ id: 1, name: 'Sam', blogPostIds: [2, 5] }],
      blogPosts: [{ id: 2, wordSmithId: 1, fineCommentIds: [3], title: 'Lorem Ipsum' }, { id: 5, wordSmithId: 1, title: 'Dolor' }],
      fineComments: [{ id: 3, text: 'Foo', blogPostId: 2, categoryId: 10 }],
      categories: [{ id: 10, foo: 'bar', labelIds: [20] }],
      labels: [{ id: 20, name: 'Economics' }]
    });
    var request = {
      queryParams: {
        include: 'wordSmith,fineComments.category.labels'
      }
    };
    var result = registry.serialize(this.schema.blogPosts.all(), request);

    assert.propEqual(result, {
      data: [{
        type: 'blog-posts',
        id: '2',
        attributes: {
          title: 'Lorem Ipsum'
        },
        relationships: {
          'word-smith': {
            data: { type: 'word-smiths', id: '1' }
          },
          'fine-comments': {
            data: [{ type: 'fine-comments', id: '3' }]
          }
        }
      }, {
        type: 'blog-posts',
        id: '5',
        attributes: {
          title: 'Dolor'
        },
        relationships: {
          'word-smith': {
            data: { type: 'word-smiths', id: '1' }
          },
          'fine-comments': {
            data: []
          }
        }
      }],
      included: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          name: 'Sam'
        },
        relationships: {
          'blog-posts': {
            data: [{ type: 'blog-posts', id: '2' }, { type: 'blog-posts', id: '5' }]
          }
        }
      }, {
        type: 'fine-comments',
        id: '3',
        attributes: {
          text: 'Foo'
        },
        relationships: {
          'blog-post': {
            data: { type: 'blog-posts', id: '2' }
          },
          'category': {
            data: { type: 'categories', id: '10' }
          }
        }
      }, {
        type: 'categories',
        id: '10',
        attributes: {
          foo: 'bar'
        },
        relationships: {
          'labels': {
            data: [{ type: 'labels', id: '20' }]
          }
        }
      }, {
        type: 'labels',
        id: '20',
        attributes: {
          name: 'Economics'
        }
      }]
    });
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/includes-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/json-api-serializer/associations/includes-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/json-api-serializer/associations/includes-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/key-for-relationship-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage', 'ember-cli-mirage/utils/inflector', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _emberCliMirage, _emberCliMirageUtilsInflector, _qunit) {

  (0, _qunit.module)('Integration | Serializers | JSON API Serializer | Key for relationship', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          blogPosts: (0, _emberCliMirage.hasMany)()
        }),
        blogPost: _emberCliMirage.Model
      });
    }
  });

  (0, _qunit.test)('keyForRelationship works', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer.extend({
        keyForRelationship: function keyForRelationship(key) {
          return (0, _emberCliMirageUtilsInflector.underscore)(key);
        }
      })
    });
    var wordSmith = this.schema.wordSmiths.create({
      id: 1,
      firstName: 'Link',
      lastName: 'Jackson',
      age: 323
    });
    wordSmith.createBlogPost({ title: 'Lorem ipsum' });

    var result = registry.serialize(wordSmith);

    assert.deepEqual(result, {
      data: {
        type: 'word-smiths',
        id: '1',
        attributes: {
          age: 323,
          'first-name': 'Link',
          'last-name': 'Jackson'
        },
        relationships: {
          'blog_posts': {
            data: [{ id: '1', type: 'blog-posts' }]
          }
        }
      }
    });
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/key-for-relationship-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/json-api-serializer/associations/key-for-relationship-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/json-api-serializer/associations/key-for-relationship-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/links-test', ['exports', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage', 'qunit', 'ember-cli-mirage/db', 'ember-cli-mirage/orm/schema'], function (exports, _emberCliMirageSerializerRegistry, _emberCliMirage, _qunit, _emberCliMirageDb, _emberCliMirageOrmSchema) {

  (0, _qunit.module)('Integration | Serializers | JSON API Serializer | Associations | Links', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          blogPosts: (0, _emberCliMirage.hasMany)()
        }),
        blogPost: _emberCliMirage.Model.extend({
          wordSmith: (0, _emberCliMirage.belongsTo)(),
          fineComments: (0, _emberCliMirage.hasMany)()
        }),
        fineComment: _emberCliMirage.Model.extend({
          blogPost: (0, _emberCliMirage.belongsTo)()
        })
      });
    },
    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it can link to relationships, omitting \'data\'', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        links: function links(model) {
          return {
            'wordSmith': {
              related: '/api/word_smiths/' + model.wordSmith.id,
              self: '/api/blog_posts/' + model.id + '/relationships/word_smith'
            },
            'fineComments': {
              related: '/api/fine_comments?blog_post_id=' + model.id,
              self: '/api/blog_posts/' + model.id + '/relationships/fine_comments'
            }
          };
        }
      })
    });

    var link = this.schema.wordSmiths.create({ id: 3, name: 'Link' }); // specify id to really test our links function
    var blogPost = link.createBlogPost({ title: 'Lorem ipsum' });

    var result = registry.serialize(blogPost);

    assert.deepEqual(result, {
      data: {
        type: 'blog-posts',
        id: blogPost.id,
        attributes: {
          'title': 'Lorem ipsum'
        },
        relationships: {
          'word-smith': {
            links: {
              related: '/api/word_smiths/' + link.id,
              self: '/api/blog_posts/' + blogPost.id + '/relationships/word_smith'
            }
          },
          'fine-comments': {
            links: {
              related: '/api/fine_comments?blog_post_id=' + blogPost.id,
              self: '/api/blog_posts/' + blogPost.id + '/relationships/fine_comments'
            }
          }
        }
      }
    });
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/links-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/json-api-serializer/associations/links-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/json-api-serializer/associations/links-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/many-to-many-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/db', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/serializer-registry'], function (exports, _qunit, _emberCliMirage, _emberCliMirageDb, _emberCliMirageOrmSchema, _emberCliMirageSerializerRegistry) {

  (0, _qunit.module)('Integration | Serializers | JSON API Serializer | Associations | Many To Many', {
    beforeEach: function beforeEach() {
      var db = new _emberCliMirageDb['default']();

      var schema = new _emberCliMirageOrmSchema['default'](db, {
        contact: _emberCliMirage.Model.extend({
          addresses: (0, _emberCliMirage.hasMany)(),
          contactAddresses: (0, _emberCliMirage.hasMany)()
        }),
        address: _emberCliMirage.Model.extend({
          contacts: (0, _emberCliMirage.hasMany)(),
          contactAddresses: (0, _emberCliMirage.hasMany)()
        }),
        contactAddress: _emberCliMirage.Model.extend({
          contact: (0, _emberCliMirage.belongsTo)(),
          address: (0, _emberCliMirage.belongsTo)()
        })
      });

      var mario = schema.contacts.create({ name: 'Mario' });
      var newYork = schema.addresses.create({ street: 'Some New York Street' });
      var mushroomKingdom = schema.addresses.create({ street: 'Some Mushroom Kingdom Street' });

      schema.contactAddresses.create({ contact: mario, address: newYork });
      schema.contactAddresses.create({ contact: mario, address: mushroomKingdom });

      this.schema = schema;
    }
  });

  (0, _qunit.skip)('it serializes manyToMany if properly configured to passthrough ', function (assert) {
    var contactSerializer = _emberCliMirage.JSONAPISerializer.extend({
      addresses: function addresses(model) {
        var models = model.contactAddresses.models.map(function (ca) {
          return ca.address;
        });
        return new _emberCliMirage.Collection('address', models);
      }
    });

    var addressSerializer = _emberCliMirage.JSONAPISerializer.extend({
      contacts: function contacts(model) {
        var models = model.contactAddresses.models.map(function (ca) {
          return ca.contact;
        });
        return new _emberCliMirage.Collection('contact', models);
      }
    });

    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      address: addressSerializer,
      contact: contactSerializer
    });

    var contact = this.schema.contacts.find(1);
    var result = registry.serialize(contact);

    assert.deepEqual(result, {
      data: {
        id: '1',
        type: 'contacts',
        attributes: {
          name: 'Mario'
        },
        relationships: {
          addresses: {
            data: [{ id: '1', type: 'addresses' }, { id: '2', type: 'addresses' }]
          },
          'contact-addresses': {
            data: [{ id: '1', type: 'contact-addresses' }, { id: '2', type: 'contact-addresses' }]
          }
        }
      }
    });
  });

  (0, _qunit.skip)('it sideloads manyToMany if properly configured to passthrough and include', function (assert) {
    var contactSerializer = _emberCliMirage.JSONAPISerializer.extend({
      include: ['addresses'],
      addresses: function addresses(model) {
        var models = model.contactAddresses.models.map(function (ca) {
          return ca.address;
        });
        return new _emberCliMirage.Collection('address', models);
      }
    });

    var addressSerializer = _emberCliMirage.JSONAPISerializer.extend({
      include: ['contacts'],
      contacts: function contacts(model) {
        var models = model.contactAddresses.models.map(function (ca) {
          return ca.contact;
        });
        return new _emberCliMirage.Collection('contact', models);
      }
    });

    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      address: addressSerializer,
      contact: contactSerializer
    });

    var contact = this.schema.contacts.find(1);
    var result = registry.serialize(contact);

    var data = result.data;
    var included = result.included;

    assert.deepEqual(data, {
      id: '1',
      type: 'contacts',
      attributes: {
        name: 'Mario'
      },
      relationships: {
        addresses: {
          data: [{ id: '1', type: 'addresses' }, { id: '2', type: 'addresses' }]
        },
        'contact-addresses': {
          data: [{ id: '1', type: 'contact-addresses' }, { id: '2', type: 'contact-addresses' }]
        }
      }
    });

    assert.deepEqual(included, [{
      id: '1',
      type: 'addresses',
      attributes: {
        street: 'Some New York Street'
      },
      relationships: {
        contacts: { data: [{ id: '1', type: 'contacts' }] },
        'contact-addresses': { data: [{ id: '1', type: 'contact-addresses' }] }
      }
    }, {
      id: '2',
      type: 'addresses',
      attributes: {
        street: 'Some Mushroom Kingdom Street'
      },
      relationships: {
        contacts: { data: [{ id: '1', type: 'contacts' }] },
        'contact-addresses': { data: [{ id: '2', type: 'contact-addresses' }] }
      }
    }]);
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/many-to-many-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/json-api-serializer/associations/many-to-many-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/json-api-serializer/associations/many-to-many-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/model-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | Serializers | JSON API Serializer | Associations | Model', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model.extend({
          blogPosts: (0, _emberCliMirage.hasMany)()
        }),
        blogPost: _emberCliMirage.Model.extend({
          wordSmith: (0, _emberCliMirage.belongsTo)(),
          fineComments: (0, _emberCliMirage.hasMany)()
        }),
        fineComment: _emberCliMirage.Model.extend({
          blogPost: (0, _emberCliMirage.belongsTo)()
        })
      });
    }
  });

  (0, _qunit.test)('it contains resource identifier objects for all a model\'s relationships, regardless of includes', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer
    });
    var link = this.schema.wordSmiths.create({
      firstName: 'Link',
      age: 123
    });
    var post = link.createBlogPost({ title: 'Lorem ipsum' });

    var result = registry.serialize(post);
    assert.deepEqual(result, {
      data: {
        type: 'blog-posts',
        id: '1',
        attributes: {
          'title': 'Lorem ipsum'
        },
        relationships: {
          'word-smith': {
            data: {
              type: 'word-smiths',
              id: '1'
            }
          },
          'fine-comments': {
            data: []
          }
        }
      }
    });
  });

  (0, _qunit.test)('it can include a has-many relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      wordSmith: _emberCliMirage.JSONAPISerializer.extend({
        include: ['blogPosts']
      })
    });

    var link = this.schema.wordSmiths.create({ firstName: 'Link' });
    link.createBlogPost({ title: 'Lorem' });
    link.createBlogPost({ title: 'Ipsum' });

    var result = registry.serialize(link);

    assert.deepEqual(result, {
      data: {
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        },
        relationships: {
          'blog-posts': {
            data: [{ type: 'blog-posts', id: '1' }, { type: 'blog-posts', id: '2' }]
          }
        }
      },
      included: [{
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'fine-comments': {
            data: []
          },
          'word-smith': {
            data: {
              id: '1',
              type: 'word-smiths'
            }
          }
        }
      }, {
        type: 'blog-posts',
        id: '2',
        attributes: {
          title: 'Ipsum'
        },
        relationships: {
          'fine-comments': {
            data: []
          },
          'word-smith': {
            data: {
              id: '1',
              type: 'word-smiths'
            }
          }
        }
      }]
    });
  });

  (0, _qunit.test)('it can include a chain of has-many relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      wordSmith: _emberCliMirage.JSONAPISerializer.extend({
        include: ['blogPosts']
      }),
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['fineComments']
      })
    });

    var link = this.schema.wordSmiths.create({ firstName: 'Link' });
    var post1 = link.createBlogPost({ title: 'Lorem' });
    post1.createFineComment({ text: 'pwned' });
    link.createBlogPost({ title: 'Ipsum' });

    var result = registry.serialize(link);

    assert.deepEqual(result, {
      data: {
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        },
        relationships: {
          'blog-posts': {
            data: [{ type: 'blog-posts', id: '1' }, { type: 'blog-posts', id: '2' }]
          }
        }
      },
      included: [{
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'fine-comments': {
            data: [{ type: 'fine-comments', id: '1' }]
          },
          'word-smith': {
            data: {
              id: '1',
              type: 'word-smiths'
            }
          }
        }
      }, {
        type: 'fine-comments',
        id: '1',
        attributes: {
          text: 'pwned'
        },
        relationships: {
          'blog-post': {
            data: {
              id: '1',
              type: 'blog-posts'
            }
          }
        }
      }, {
        type: 'blog-posts',
        id: '2',
        attributes: {
          title: 'Ipsum'
        },
        relationships: {
          'fine-comments': {
            data: []
          },
          'word-smith': {
            data: {
              id: '1',
              type: 'word-smiths'
            }
          }
        }
      }]
    });
  });

  (0, _qunit.test)('it can include a belongs-to relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['wordSmith']
      })
    });

    var link = this.schema.wordSmiths.create({ firstName: 'Link' });
    var blogPost = link.createBlogPost({ title: 'Lorem' });
    blogPost.createFineComment();

    var result = registry.serialize(blogPost);

    assert.deepEqual(result, {
      data: {
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'fine-comments': {
            data: [{
              id: '1',
              type: 'fine-comments'
            }]
          },
          'word-smith': {
            data: {
              id: '1',
              type: 'word-smiths'
            }
          }
        }
      },
      'included': [{
        attributes: {
          'first-name': 'Link'
        },
        id: '1',
        type: 'word-smiths',
        relationships: {
          'blog-posts': {
            data: [{
              id: '1',
              type: 'blog-posts'
            }]
          }
        }
      }]
    });
  });

  (0, _qunit.test)('it gracefully handles null belongs-to relationship', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['wordSmith']
      })
    });

    var blogPost = this.schema.blogPosts.create({ title: 'Lorem' });
    var result = registry.serialize(blogPost);

    assert.deepEqual(result, {
      data: {
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'word-smith': {
            data: null
          },
          'fine-comments': {
            data: []
          }
        }
      }
    });
  });

  (0, _qunit.test)('it can include a chain of belongs-to relationships', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['wordSmith']
      }),
      fineComment: _emberCliMirage.JSONAPISerializer.extend({
        include: ['blogPost']
      })
    });

    var wordSmith = this.schema.wordSmiths.create({ firstName: 'Link' });
    var post = wordSmith.createBlogPost({ title: 'Lorem' });
    var comment = post.createFineComment({ text: 'pwned' });

    var result = registry.serialize(comment);

    assert.deepEqual(result, {
      data: {
        type: 'fine-comments',
        id: '1',
        attributes: {
          text: 'pwned'
        },
        relationships: {
          'blog-post': {
            data: {
              id: '1',
              type: 'blog-posts'
            }
          }
        }
      },
      'included': [{
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'fine-comments': {
            data: [{
              id: '1',
              type: 'fine-comments'
            }]
          },
          'word-smith': {
            data: {
              type: 'word-smiths',
              id: '1'
            }
          }
        }
      }, {
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        },
        relationships: {
          'blog-posts': {
            data: [{
              id: '1',
              type: 'blog-posts'
            }]
          }
        }
      }]
    });
  });

  (0, _qunit.test)('it ignores relationships that refer to serialized ancestor resources', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      wordSmith: _emberCliMirage.JSONAPISerializer.extend({
        include: ['blogPosts']
      }),
      blogPost: _emberCliMirage.JSONAPISerializer.extend({
        include: ['wordSmith', 'fineComments']
      }),
      fineComment: _emberCliMirage.JSONAPISerializer.extend({
        include: ['blogPost']
      })
    });

    var wordSmith = this.schema.wordSmiths.create({ firstName: 'Link' });
    var post = wordSmith.createBlogPost({ title: 'Lorem' });
    wordSmith.createBlogPost({ title: 'Ipsum' });
    post.createFineComment({ text: 'pwned' });

    var result = registry.serialize(wordSmith);

    assert.deepEqual(result, {
      data: {
        attributes: {
          'first-name': 'Link'
        },
        id: '1',
        relationships: {
          'blog-posts': {
            data: [{ type: 'blog-posts', id: '1' }, { type: 'blog-posts', id: '2' }]
          }
        },
        type: 'word-smiths'
      },
      included: [{
        type: 'blog-posts',
        id: '1',
        attributes: {
          title: 'Lorem'
        },
        relationships: {
          'word-smith': {
            data: { type: 'word-smiths', id: '1' }
          },
          'fine-comments': {
            data: [{ type: 'fine-comments', id: '1' }]
          }
        }
      }, {
        type: 'fine-comments',
        id: '1',
        attributes: {
          text: 'pwned'
        },
        relationships: {
          'blog-post': {
            data: { type: 'blog-posts', id: '1' }
          }
        }
      }, {
        type: 'blog-posts',
        id: '2',
        attributes: {
          title: 'Ipsum'
        },
        relationships: {
          'word-smith': {
            data: { type: 'word-smiths', id: '1' }
          },
          'fine-comments': {
            data: []
          }
        }
      }]
    });
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/associations/model-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/json-api-serializer/associations/model-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/json-api-serializer/associations/model-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/attrs-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | Serializers | JSON API Serializer | Attrs List', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model,
        photograph: _emberCliMirage.Model
      });
    }
  });

  (0, _qunit.test)('it returns only the whitelisted attrs when serializing a model', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      wordSmith: _emberCliMirage.JSONAPISerializer.extend({
        attrs: ['firstName']
      })
    });
    var user = this.schema.wordSmiths.create({
      id: 1,
      firstName: 'Link',
      age: 123
    });

    var result = registry.serialize(user);

    assert.deepEqual(result, {
      data: {
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        }
      }
    });
  });

  (0, _qunit.test)('it returns only the whitelisted attrs when serializing a collection', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer,
      wordSmith: _emberCliMirage.JSONAPISerializer.extend({
        attrs: ['firstName']
      })
    });
    this.schema.wordSmiths.create({ id: 1, firstName: 'Link', age: 123 });
    this.schema.wordSmiths.create({ id: 2, firstName: 'Zelda', age: 456 });

    var collection = this.schema.wordSmiths.all();
    var result = registry.serialize(collection);

    assert.deepEqual(result, {
      data: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        }
      }, {
        type: 'word-smiths',
        id: '2',
        attributes: {
          'first-name': 'Zelda'
        }
      }]
    });
  });

  (0, _qunit.test)('it can use different attr whitelists for different serializers', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      wordSmith: _emberCliMirage.JSONAPISerializer.extend({
        attrs: ['firstName']
      }),
      photograph: _emberCliMirage.JSONAPISerializer.extend({
        attrs: ['title']
      })
    });

    var link = this.schema.wordSmiths.create({ id: 1, firstName: 'Link', age: 123 });
    assert.deepEqual(registry.serialize(link), {
      data: {
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link'
        }
      }
    });

    var photo = this.schema.photographs.create({ id: 1, title: 'Lorem ipsum', createdAt: '2010-01-01' });
    assert.deepEqual(registry.serialize(photo), {
      data: {
        type: 'photographs',
        id: '1',
        attributes: {
          'title': 'Lorem ipsum'
        }
      }
    });
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/attrs-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/json-api-serializer/attrs-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/json-api-serializer/attrs-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/base-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Integration | Serializers | JSON API Serializer | Base', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model
      });
      this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
        application: _emberCliMirage.JSONAPISerializer
      });
    }
  });

  (0, _qunit.test)('it includes all attributes for a model', function (assert) {
    var link = this.schema.wordSmiths.create({ firstName: 'Link', age: 123 });
    var result = this.registry.serialize(link);

    assert.deepEqual(result, {
      data: {
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link',
          age: 123
        }
      }
    });
  });

  (0, _qunit.test)('it includes all attributes for each model in a collection', function (assert) {
    this.schema.wordSmiths.create({ firstName: 'Link', age: 123 });
    this.schema.wordSmiths.create({ id: 1, firstName: 'Link', age: 123 });
    this.schema.wordSmiths.create({ id: 2, firstName: 'Zelda', age: 456 });

    var collection = this.schema.wordSmiths.all();
    var result = this.registry.serialize(collection);

    assert.deepEqual(result, {
      data: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first-name': 'Link',
          age: 123
        }
      }, {
        type: 'word-smiths',
        id: '2',
        attributes: {
          'first-name': 'Zelda',
          age: 456
        }
      }]
    });
  });

  (0, _qunit.test)('it can serialize an empty collection', function (assert) {
    var wordSmiths = this.schema.wordSmiths.all();
    var result = this.registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      data: []
    });
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/base-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/json-api-serializer/base-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/json-api-serializer/base-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/key-formatting-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'ember-cli-mirage', 'ember-cli-mirage/utils/inflector', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _emberCliMirage, _emberCliMirageUtilsInflector, _qunit) {

  (0, _qunit.module)('Integration | Serializers | JSON API Serializer | Key Formatting', {
    beforeEach: function beforeEach() {
      this.schema = new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirage.Model,
        photograph: _emberCliMirage.Model
      });
    }
  });

  (0, _qunit.test)('keyForAttribute formats the attributes of a model', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer.extend({
        keyForAttribute: function keyForAttribute(key) {
          return (0, _emberCliMirageUtilsInflector.underscore)(key);
        }
      })
    });
    var wordSmith = this.schema.wordSmiths.create({
      id: 1,
      firstName: 'Link',
      lastName: 'Jackson',
      age: 323
    });

    var result = registry.serialize(wordSmith);

    assert.deepEqual(result, {
      data: {
        type: 'word-smiths',
        id: '1',
        attributes: {
          age: 323,
          first_name: 'Link',
          last_name: 'Jackson'
        }
      }
    });
  });

  (0, _qunit.test)('keyForAttribute also formats the models in a collections', function (assert) {
    var registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
      application: _emberCliMirage.JSONAPISerializer.extend({
        keyForAttribute: function keyForAttribute(key) {
          return (0, _emberCliMirageUtilsInflector.underscore)(key);
        }
      })
    });

    this.schema.wordSmiths.create({ id: 1, 'firstName': 'Link', 'lastName': 'Jackson' });
    this.schema.wordSmiths.create({ id: 2, 'firstName': 'Zelda', 'lastName': 'Brown' });
    var wordSmiths = this.schema.wordSmiths.all();

    var result = registry.serialize(wordSmiths);

    assert.deepEqual(result, {
      data: [{
        type: 'word-smiths',
        id: '1',
        attributes: {
          'first_name': 'Link',
          'last_name': 'Jackson'
        }
      }, {
        type: 'word-smiths',
        id: '2',
        attributes: {
          'first_name': 'Zelda',
          'last_name': 'Brown'
        }
      }]
    });
  });
});
define('dummy/tests/integration/serializers/json-api-serializer/key-formatting-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/json-api-serializer/key-formatting-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/json-api-serializer/key-formatting-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/rest-serializer-test', ['exports', 'ember-cli-mirage/serializers/rest-serializer', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db', 'ember-cli-mirage/serializer-registry', 'qunit'], function (exports, _emberCliMirageSerializersRestSerializer, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb, _emberCliMirageSerializerRegistry, _qunit) {

  (0, _qunit.module)('Integration | Serializer | RestSerializer', {
    beforeEach: function beforeEach() {
      var db = new _emberCliMirageDb['default']();
      this.schema = new _emberCliMirageOrmSchema['default'](db);
      this.schema.registerModels({
        wordSmith: _emberCliMirageOrmModel['default'].extend({
          blogPosts: (0, _emberCliMirage.hasMany)()
        }),
        blogPost: _emberCliMirageOrmModel['default'].extend({
          wordSmith: (0, _emberCliMirage.belongsTo)()
        })
      });

      var link = this.schema.wordSmiths.create({ name: 'Link', age: 123 });
      link.createBlogPost({ title: 'Lorem' });
      link.createBlogPost({ title: 'Ipsum' });

      this.schema.wordSmiths.create({ name: 'Zelda', age: 230 });

      this.registry = new _emberCliMirageSerializerRegistry['default'](this.schema, {
        application: _emberCliMirageSerializersRestSerializer['default'],
        wordSmith: _emberCliMirageSerializersRestSerializer['default'].extend({
          attrs: ['id', 'name'],
          include: ['blogPosts']
        }),
        blogPost: _emberCliMirageSerializersRestSerializer['default'].extend({
          include: ['wordSmith']
        })
      });
    },

    afterEach: function afterEach() {
      this.schema.db.emptyData();
    }
  });

  (0, _qunit.test)('it sideloads associations and camel-cases relationships and attributes correctly for a model', function (assert) {
    var link = this.schema.wordSmiths.find(1);
    var result = this.registry.serialize(link);

    assert.deepEqual(result, {
      wordSmith: {
        id: '1',
        name: 'Link',
        blogPosts: ['1', '2']
      },
      blogPosts: [{
        id: '1',
        title: 'Lorem',
        wordSmith: '1'
      }, {
        id: '2',
        title: 'Ipsum',
        wordSmith: '1'
      }]
    });
  });
});
define('dummy/tests/integration/serializers/rest-serializer-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/rest-serializer-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/rest-serializer-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/serializers/schema-helper', ['exports', 'ember-cli-mirage', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/orm/model', 'ember-cli-mirage/db'], function (exports, _emberCliMirage, _emberCliMirageOrmSchema, _emberCliMirageOrmModel, _emberCliMirageDb) {
  exports['default'] = {

    setup: function setup() {
      return new _emberCliMirageOrmSchema['default'](new _emberCliMirageDb['default'](), {
        wordSmith: _emberCliMirageOrmModel['default'].extend({
          blogPosts: _emberCliMirage['default'].hasMany()
        }),
        blogPost: _emberCliMirageOrmModel['default'].extend({
          wordSmith: _emberCliMirage['default'].belongsTo(),
          fineComments: _emberCliMirage['default'].hasMany()
        }),
        fineComment: _emberCliMirageOrmModel['default'].extend({
          blogPost: _emberCliMirage['default'].belongsTo()
        }),
        greatPhoto: _emberCliMirageOrmModel['default'],

        foo: _emberCliMirageOrmModel['default'].extend({
          bar: _emberCliMirage['default'].belongsTo()
        }),
        bar: _emberCliMirageOrmModel['default'].extend({
          baz: _emberCliMirage['default'].belongsTo()
        }),
        baz: _emberCliMirageOrmModel['default'].extend({
          quuxes: _emberCliMirage['default'].hasMany()
        }),
        quux: _emberCliMirageOrmModel['default'].extend({
          zomgs: _emberCliMirage['default'].hasMany()
        }),
        zomg: _emberCliMirageOrmModel['default'].extend({
          lol: _emberCliMirage['default'].belongsTo()
        }),
        lol: _emberCliMirageOrmModel['default']
      });
    }

  };
});
define('dummy/tests/integration/serializers/schema-helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/serializers/schema-helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/serializers/schema-helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/server-config-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/server', 'ember-cli-mirage/serializers/active-model-serializer', 'ember-cli-mirage/serializers/rest-serializer'], function (exports, _qunit, _emberCliMirage, _emberCliMirageServer, _emberCliMirageSerializersActiveModelSerializer, _emberCliMirageSerializersRestSerializer) {

  (0, _qunit.module)('Integration | Server Config', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'development',
        models: {
          contact: _emberCliMirage.Model,
          post: _emberCliMirage.Model
        },
        serializers: {
          contact: _emberCliMirageSerializersActiveModelSerializer['default']
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('namespace can be configured', function (assert) {
    assert.expect(1);
    var done = assert.async();

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    this.server.db.loadData({
      contacts: contacts
    });
    this.server.namespace = 'api';
    this.server.get('/contacts');

    $.getJSON('/api/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
  });

  (0, _qunit.test)('urlPrefix can be configured', function (assert) {
    assert.expect(1);
    var done = assert.async();
    var server = this.server;

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    server.db.loadData({
      contacts: contacts
    });
    server.urlPrefix = 'http://localhost:3000';
    server.get('/contacts');

    $.getJSON('http://localhost:3000/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
  });

  (0, _qunit.test)('urlPrefix and namespace can be configured simultaneously', function (assert) {
    assert.expect(1);
    var done = assert.async();
    var server = this.server;

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    server.db.loadData({
      contacts: contacts
    });
    server.urlPrefix = 'http://localhost:3000';
    server.namespace = 'api';
    server.get('/contacts');

    $.getJSON('http://localhost:3000/api/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
  });

  (0, _qunit.test)('fully qualified domain names can be used in configuration', function (assert) {
    assert.expect(1);
    var done = assert.async();

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    this.server.db.loadData({
      contacts: contacts
    });
    this.server.get('http://example.org/api/contacts');

    $.getJSON('http://example.org/api/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
  });

  (0, _qunit.test)('urlPrefix/namespace are ignored when fully qualified domain names are used in configuration', function (assert) {
    assert.expect(1);
    var done = assert.async();
    var server = this.server;

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    server.db.loadData({
      contacts: contacts
    });
    this.urlPrefix = 'https://example.net';
    server.get('http://example.org/api/contacts');

    $.getJSON('http://example.org/api/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
  });

  (0, _qunit.test)('blank urlPrefix and namespace ends up as /', function (assert) {
    assert.expect(1);
    var done = assert.async();

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    this.server.db.loadData({
      contacts: contacts
    });
    this.server.namespace = '';
    this.server.urlPrefix = '';
    this.server.get('contacts');

    $.getJSON('/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
  });

  (0, _qunit.test)('namespace with no slash gets one', function (assert) {
    assert.expect(1);
    var done = assert.async();

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    this.server.db.loadData({
      contacts: contacts
    });
    this.server.namespace = 'api';
    this.server.get('contacts');

    $.getJSON('/api/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
  });

  (0, _qunit.test)('urlPrefix with no slash gets one', function (assert) {
    assert.expect(1);
    var done = assert.async();

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    this.server.db.loadData({
      contacts: contacts
    });
    this.server.urlPrefix = 'pre';
    this.server.get('contacts');

    $.getJSON('/pre/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
  });

  (0, _qunit.test)('namespace of / works', function (assert) {
    assert.expect(1);
    var done = assert.async();

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    this.server.db.loadData({
      contacts: contacts
    });
    this.server.namespace = '/';
    this.server.get('contacts');

    $.getJSON('/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
  });

  (0, _qunit.test)('redefining options using the config method works', function (assert) {
    assert.expect(5);
    var done = assert.async();
    var server = this.server;

    var contacts = [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }];
    server.config({
      namespace: 'api',
      urlPrefix: 'http://localhost:3000',
      timing: 1000,
      serializers: {
        post: _emberCliMirageSerializersRestSerializer['default']
      }
    });
    server.db.loadData({
      contacts: contacts
    });
    server.get('contacts');

    assert.equal(server.timing, 1000);
    $.getJSON('http://localhost:3000/api/contacts', function (data) {
      assert.deepEqual(data, { contacts: contacts });
      done();
    });
    var serializerMap = server.serializerOrRegistry._serializerMap;
    assert.equal(Object.keys(serializerMap).length, 2);
    assert.equal(serializerMap.contact, _emberCliMirageSerializersActiveModelSerializer['default']);
    assert.equal(serializerMap.post, _emberCliMirageSerializersRestSerializer['default']);
  });

  (0, _qunit.test)('changing the environment of the server throws an error', function (assert) {
    var server = this.server;

    assert.throws(function () {
      server.config({
        environment: 'test'
      });
    }, /You cannot modify Mirage's environment once the server is created/);
  });
});
define('dummy/tests/integration/server-config-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/server-config-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/server-config-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/server-with-orm-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirage, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Server with ORM', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'test',
        models: {
          blogPost: _emberCliMirage.Model
        },
        factories: {
          blogPost: _emberCliMirage.Factory
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('a single blogPost db collection is made', function (assert) {
    assert.equal(this.server.db._collections.length, 1);
    assert.equal(this.server.db._collections[0].name, 'blogPosts');
  });

  (0, _qunit.test)('create looks up the appropriate db collection', function (assert) {
    server.create('blog-post');

    assert.equal(this.server.db.blogPosts.length, 1);
  });
});
define('dummy/tests/integration/server-with-orm-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/server-with-orm-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/server-with-orm-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/server/custom-function-handler-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirage, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Server | Custom function handler', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'test',
        models: {
          contact: _emberCliMirage.Model
        },
        factories: {
          contact: _emberCliMirage.Factory
        },
        serializers: {
          application: _emberCliMirage.ActiveModelSerializer
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('a POJA of models defaults to responding with an array of each model\'s attrs', function (assert) {
    assert.expect(1);
    var done = assert.async();
    var server = this.server;

    server.createList('contact', 3);
    server.get('/contacts', function (schema) {
      return schema.contacts.all().models;
    });

    $.ajax({
      method: 'GET',
      url: '/contacts'
    }).done(function (res) {
      assert.deepEqual(res, [{ id: '1' }, { id: '2' }, { id: '3' }]);
      done();
    });
  });

  (0, _qunit.test)('#normalizedRequestAttrs returns an object with the primary resource\'s attrs and belongsTo keys camelized', function (assert) {
    assert.expect(1);
    var done = assert.async();
    var server = this.server;

    server.post('/contacts', function () {
      var attrs = this.normalizedRequestAttrs();

      assert.deepEqual(attrs, {
        firstName: 'Sam',
        lastName: 'Selikoff',
        teamId: 1
      });

      return {};
    });

    $.ajax({
      method: 'POST',
      url: '/contacts',
      contentType: 'application/json',
      data: JSON.stringify({
        contact: {
          first_name: 'Sam',
          last_name: 'Selikoff',
          team_id: 1
        }
      })
    }).done(function () {
      done();
    });
  });

  (0, _qunit.test)('#normalizedRequestAttrs parses a x-www-form-urlencoded request and returns a POJO', function (assert) {
    assert.expect(1);
    var done = assert.async();
    var server = this.server;

    server.post('/form-test', function () {
      var attrs = this.normalizedRequestAttrs();

      assert.deepEqual(attrs, {
        name: 'Sam Selikoff',
        company: 'TED',
        email: 'sam.selikoff@gmail.com'
      }, '#normalizedRequestAttrs successfully returned the parsed x-www-form-urlencoded request body');

      return {};
    });

    $.ajax({
      method: 'POST',
      url: '/form-test',
      data: 'name=Sam+Selikoff&company=TED&email=sam.selikoff@gmail.com'
    }).done(function () {
      done();
    });
  });
});
define('dummy/tests/integration/server/custom-function-handler-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/server/custom-function-handler-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/server/custom-function-handler-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/server/customized-normalize-method-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/utils/inflector', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirage, _emberCliMirageUtilsInflector, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Server | Customized normalize method', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'test',
        models: {
          contact: _emberCliMirage.Model
        },
        serializers: {
          application: _emberCliMirage.ActiveModelSerializer,
          contact: _emberCliMirage.ActiveModelSerializer.extend({
            normalize: function normalize(payload) {
              var attrs = payload.some.random[1].attrs;
              Object.keys(attrs).forEach(_emberCliMirageUtilsInflector.camelize);

              var jsonApiDoc = {
                data: {
                  type: 'contacts',
                  attributes: attrs
                }
              };
              return jsonApiDoc;
            }
          })
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('custom model-specific normalize functions are used', function (assert) {
    var server = this.server;

    assert.expect(3);
    var done = assert.async();

    server.post('/contacts');

    $.ajax({
      method: 'POST',
      url: '/contacts',
      data: JSON.stringify({
        some: {
          random: [{
            format: true
          }, {
            attrs: {
              first_name: 'Zelda'
            }
          }]
        }
      })
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 201);
      assert.equal(server.db.contacts.length, 1);
      assert.equal(server.db.contacts[0].firstName, 'Zelda');
      done();
    });
  });

  (0, _qunit.test)('custom model-specific normalize functions are used with custom function handlers', function (assert) {
    var server = this.server;

    var done = assert.async();

    server.put('/contacts/:id', function (schema, request) {
      var attrs = this.normalizedRequestAttrs();

      assert.deepEqual(attrs, {
        id: '1',
        firstName: 'Zelda'
      });

      return {};
    });

    $.ajax({
      method: 'PUT',
      url: '/contacts/1',
      contentType: 'application/json',
      data: JSON.stringify({
        some: {
          random: [{
            format: true
          }, {
            attrs: {
              first_name: 'Zelda'
            }
          }]
        }
      })
    }).done(function () {
      done();
    });
  });
});
define('dummy/tests/integration/server/customized-normalize-method-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/server/customized-normalize-method-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/server/customized-normalize-method-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/server/factory-creation-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirage, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Server | Factory creation', {
    beforeEach: function beforeEach() {
      this.Contact = _emberCliMirage.Model.extend();
      this.AmazingContact = _emberCliMirage.Model.extend();
      this.Post = _emberCliMirage.Model.extend({
        author: (0, _emberCliMirage.belongsTo)()
      });
      this.Author = _emberCliMirage.Model.extend({
        posts: (0, _emberCliMirage.hasMany)()
      });

      this.server = new _emberCliMirageServer['default']({
        environment: 'test',
        models: {
          contact: this.Contact,
          amazingContact: this.AmazingContact,
          post: this.Post,
          author: this.Author
        },
        factories: {
          contact: _emberCliMirage.Factory,
          amazingContact: _emberCliMirage.Factory
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('create returns a Model if one is defined', function (assert) {
    var contact = this.server.create('contact');

    assert.ok(contact instanceof this.Contact, 'expected a Contact');
  });

  (0, _qunit.test)('createList returns Models if one is defined', function (assert) {
    var contacts = this.server.createList('contact', 1);

    assert.ok(contacts[0] instanceof this.Contact, 'expected a Contactl');
  });

  (0, _qunit.test)('create returns a Model if one is defined, when using a compound name', function (assert) {
    var contact = this.server.create('amazing-contact');

    assert.ok(contact instanceof this.AmazingContact, 'expected an AmazingContact');
  });

  (0, _qunit.test)('createList returns Models if one is defined, when using a compound name', function (assert) {
    var contacts = this.server.createList('amazing-contact', 1);

    assert.ok(contacts[0] instanceof this.AmazingContact, 'expected an AmazingContact');
  });

  (0, _qunit.test)('create falls back to a model if no factory is defined', function (assert) {
    var post = this.server.create('post');

    assert.ok(post instanceof this.Post);
    assert.equal(post.id, 1);
  });

  (0, _qunit.test)('createList falls back to a model if no factory is defined', function (assert) {
    var posts = this.server.createList('post', 2);

    assert.ok(posts[0] instanceof this.Post);
    assert.equal(posts.length, 2);
    assert.equal(posts[0].id, 1);
  });

  (0, _qunit.test)('create sets up the db correctly when passing in fks', function (assert) {
    var author = server.create('author');
    var post = this.server.create('post', {
      authorId: author.id
    });
    author.reload();

    assert.equal(author.posts.models.length, 1);
    assert.deepEqual(post.author.attrs, author.attrs);
    assert.equal(this.server.db.posts[0].authorId, author.id);
  });

  (0, _qunit.test)('create sets up the db correctly when passing in models', function (assert) {
    var author = server.create('author');
    var post = this.server.create('post', {
      author: author
    });

    assert.equal(author.posts.models.length, 1);
    assert.deepEqual(post.author.attrs, author.attrs);
    assert.equal(this.server.db.posts[0].authorId, author.id);
  });
});
define('dummy/tests/integration/server/factory-creation-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/server/factory-creation-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/server/factory-creation-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/server/resource-shorthand-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirage, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Server | Resource shorthand', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'test',
        models: {
          contact: _emberCliMirage.Model
        },
        serializers: {
          application: _emberCliMirage.ActiveModelSerializer
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('resource generates get shorthand for index action', function (assert) {
    assert.expect(2);
    var done = assert.async();

    this.server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }, { id: 2, name: 'Zelda' }]
    });

    this.server.resource('contacts');

    $.ajax({
      method: 'GET',
      url: '/contacts'
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      assert.deepEqual(res, { contacts: [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }] });
      done();
    });
  });

  (0, _qunit.test)('resource generates get shorthand for show action', function (assert) {
    assert.expect(2);
    var done = assert.async();

    this.server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }, { id: 2, name: 'Zelda' }]
    });

    this.server.resource('contacts');

    $.ajax({
      method: 'GET',
      url: '/contacts/2'
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      assert.deepEqual(res, { contact: { id: '2', name: 'Zelda' } });
      done();
    });
  });

  (0, _qunit.test)('resource generates post shorthand', function (assert) {
    var server = this.server;

    assert.expect(2);
    var done = assert.async();

    server.resource('contacts');

    $.ajax({
      method: 'POST',
      url: '/contacts',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 201);
      assert.equal(server.db.contacts.length, 1);
      done();
    });
  });

  (0, _qunit.test)('resource generates put shorthand', function (assert) {
    var server = this.server;

    assert.expect(2);
    var done = assert.async();

    this.server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    server.resource('contacts');

    $.ajax({
      method: 'PUT',
      url: '/contacts/1',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      assert.equal(server.db.contacts[0].name, 'Zelda');
      done();
    });
  });

  (0, _qunit.test)('resource generates patch shorthand', function (assert) {
    var server = this.server;

    assert.expect(2);
    var done = assert.async();

    this.server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    server.resource('contacts');

    $.ajax({
      method: 'PATCH',
      url: '/contacts/1',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      assert.equal(server.db.contacts[0].name, 'Zelda');
      done();
    });
  });

  (0, _qunit.test)('resource generates delete shorthand works', function (assert) {
    var server = this.server;

    assert.expect(2);
    var done = assert.async();

    this.server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    server.resource('contacts');

    $.ajax({
      method: 'DELETE',
      url: '/contacts/1'
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 204);
      assert.equal(server.db.contacts.length, 0);
      done();
    });
  });

  (0, _qunit.test)('resource does not accept both :all and :except options', function (assert) {
    var server = this.server;

    assert.throws(function () {
      server.resource('contacts', { only: ['index'], except: ['create'] });
    }, 'cannot use both :only and :except options');
  });

  (0, _qunit.test)('resource generates shorthands which are whitelisted by :only option', function (assert) {
    var server = this.server;

    assert.expect(1);
    var done = assert.async();

    server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }, { id: 2, name: 'Zelda' }]
    });

    server.resource('contacts', { only: ['index'] });

    $.ajax({
      method: 'GET',
      url: '/contacts'
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      done();
    });
  });

  (0, _qunit.test)('resource does not generate shorthands which are not whitelisted with :only option', function (assert) {
    var server = this.server;

    assert.expect(5);

    server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    server.resource('contacts', { only: ['index'] });

    var doneForShow = assert.async();

    $.ajax({
      method: 'GET',
      url: '/contacts/1'
    }).fail(function (xhr, textStatus, error) {
      assert.ok(error.message.indexOf("Mirage: Your Ember app tried to GET '/contacts/1'") !== -1);
      doneForShow();
    });

    var doneForCreate = assert.async();

    $.ajax({
      method: 'POST',
      url: '/contacts',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).fail(function (xhr, textStatus, error) {
      assert.ok(error.message.indexOf("Mirage: Your Ember app tried to POST '/contacts'") !== -1);
      doneForCreate();
    });

    var doneForPut = assert.async();

    $.ajax({
      method: 'PUT',
      url: '/contacts/1',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).fail(function (xhr, textStatus, error) {
      assert.ok(error.message.indexOf("Mirage: Your Ember app tried to PUT '/contacts/1'") !== -1);
      doneForPut();
    });

    var doneForPatch = assert.async();

    $.ajax({
      method: 'PATCH',
      url: '/contacts/1',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).fail(function (xhr, textStatus, error) {
      assert.ok(error.message.indexOf("Mirage: Your Ember app tried to PATCH '/contacts/1'") !== -1);
      doneForPatch();
    });

    var doneForDelete = assert.async();

    $.ajax({
      method: 'DELETE',
      url: '/contacts/1'
    }).fail(function (xhr, textStatus, error) {
      assert.ok(error.message.indexOf("Mirage: Your Ember app tried to DELETE '/contacts/1'") !== -1);
      doneForDelete();
    });
  });

  (0, _qunit.test)('resource generates shorthands which are not blacklisted by :except option', function (assert) {
    var server = this.server;

    assert.expect(2);

    server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    server.resource('contacts', { except: ['create', 'update', 'delete'] });

    var doneForIndex = assert.async();

    $.ajax({
      method: 'GET',
      url: '/contacts'
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      doneForIndex();
    });

    var doneForShow = assert.async();

    $.ajax({
      method: 'GET',
      url: '/contacts'
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      doneForShow();
    });
  });

  (0, _qunit.test)('resource does not generate shorthands which are blacklisted by :except option', function (assert) {
    var server = this.server;

    assert.expect(4);

    server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    server.resource('contacts', { except: ['create', 'update', 'delete'] });

    var doneForCreate = assert.async();

    $.ajax({
      method: 'POST',
      url: '/contacts',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).fail(function (xhr, textStatus, error) {
      assert.ok(error.message.indexOf("Mirage: Your Ember app tried to POST '/contacts'") !== -1);
      doneForCreate();
    });

    var doneForPut = assert.async();

    $.ajax({
      method: 'PUT',
      url: '/contacts/1',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).fail(function (xhr, textStatus, error) {
      assert.ok(error.message.indexOf("Mirage: Your Ember app tried to PUT '/contacts/1'") !== -1);
      doneForPut();
    });

    var doneForPatch = assert.async();

    $.ajax({
      method: 'PATCH',
      url: '/contacts/1',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).fail(function (xhr, textStatus, error) {
      assert.ok(error.message.indexOf("Mirage: Your Ember app tried to PATCH '/contacts/1'") !== -1);
      doneForPatch();
    });

    var doneForDelete = assert.async();

    $.ajax({
      method: 'DELETE',
      url: '/contacts/1'
    }).fail(function (xhr, textStatus, error) {
      assert.ok(error.message.indexOf("Mirage: Your Ember app tried to DELETE '/contacts/1'") !== -1);
      doneForDelete();
    });
  });
});
define('dummy/tests/integration/server/resource-shorthand-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/server/resource-shorthand-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/server/resource-shorthand-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/integration/server/shorthand-sanity-test', ['exports', 'qunit', 'ember-cli-mirage', 'ember-cli-mirage/server'], function (exports, _qunit, _emberCliMirage, _emberCliMirageServer) {

  (0, _qunit.module)('Integration | Server | Shorthand sanity check', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({
        environment: 'test',
        models: {
          contact: _emberCliMirage.Model
        },
        serializers: {
          application: _emberCliMirage.ActiveModelSerializer
        }
      });
      this.server.timing = 0;
      this.server.logging = false;
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('a get shorthand works', function (assert) {
    assert.expect(2);
    var done = assert.async();

    this.server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    this.server.get('/contacts');

    $.ajax({
      method: 'GET',
      url: '/contacts'
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      assert.deepEqual(res, { contacts: [{ id: '1', name: 'Link' }] });
      done();
    });
  });

  (0, _qunit.test)('a post shorthand works', function (assert) {
    var server = this.server;

    assert.expect(2);
    var done = assert.async();

    server.post('/contacts');

    $.ajax({
      method: 'POST',
      url: '/contacts',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 201);
      assert.equal(server.db.contacts.length, 1);
      done();
    });
  });

  (0, _qunit.test)('a put shorthand works', function (assert) {
    var server = this.server;

    assert.expect(2);
    var done = assert.async();

    this.server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    server.put('/contacts/:id');

    $.ajax({
      method: 'PUT',
      url: '/contacts/1',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      assert.equal(server.db.contacts[0].name, 'Zelda');
      done();
    });
  });

  (0, _qunit.test)('a patch shorthand works', function (assert) {
    var server = this.server;

    assert.expect(2);
    var done = assert.async();

    this.server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    server.patch('/contacts/:id');

    $.ajax({
      method: 'PATCH',
      url: '/contacts/1',
      data: JSON.stringify({
        contact: {
          name: 'Zelda'
        }
      })
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 200);
      assert.equal(server.db.contacts[0].name, 'Zelda');
      done();
    });
  });

  (0, _qunit.test)('a delete shorthand works', function (assert) {
    var server = this.server;

    assert.expect(2);
    var done = assert.async();

    this.server.db.loadData({
      contacts: [{ id: 1, name: 'Link' }]
    });

    server.del('/contacts/:id');

    $.ajax({
      method: 'DELETE',
      url: '/contacts/1'
    }).done(function (res, status, xhr) {
      assert.equal(xhr.status, 204);
      assert.equal(server.db.contacts.length, 0);
      done();
    });
  });
});
define('dummy/tests/integration/server/shorthand-sanity-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - integration/server/shorthand-sanity-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'integration/server/shorthand-sanity-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/models/address.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - models/address.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'models/address.js should pass ESLint.\n');
  });
});
define('dummy/tests/models/blog-post.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - models/blog-post.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'models/blog-post.js should pass ESLint.\n');
  });
});
define('dummy/tests/models/contact.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - models/contact.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'models/contact.js should pass ESLint.\n');
  });
});
define('dummy/tests/models/friend.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - models/friend.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'models/friend.js should pass ESLint.\n');
  });
});
define('dummy/tests/models/pet.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - models/pet.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'models/pet.js should pass ESLint.\n');
  });
});
define('dummy/tests/models/word-smith.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - models/word-smith.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'models/word-smith.js should pass ESLint.\n');
  });
});
define('dummy/tests/resolver.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - resolver.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'resolver.js should pass ESLint.\n');
  });
});
define('dummy/tests/router.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - router.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'router.js should pass ESLint.\n');
  });
});
define('dummy/tests/routes/application.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - routes/application.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/application.js should pass ESLint.\n');
  });
});
define('dummy/tests/routes/close-friends.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - routes/close-friends.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/close-friends.js should pass ESLint.\n');
  });
});
define('dummy/tests/routes/contacts.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - routes/contacts.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/contacts.js should pass ESLint.\n');
  });
});
define('dummy/tests/routes/friends.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - routes/friends.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/friends.js should pass ESLint.\n');
  });
});
define('dummy/tests/routes/pets.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - routes/pets.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'routes/pets.js should pass ESLint.\n');
  });
});
define('dummy/tests/serializers/application.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - serializers/application.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'serializers/application.js should pass ESLint.\n');
  });
});
define('dummy/tests/serializers/blog-post.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - serializers/blog-post.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'serializers/blog-post.js should pass ESLint.\n');
  });
});
define('dummy/tests/serializers/word-smith.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - serializers/word-smith.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'serializers/word-smith.js should pass ESLint.\n');
  });
});
define('dummy/tests/test-helper', ['exports', 'dummy/tests/helpers/resolver', 'ember-qunit'], function (exports, _dummyTestsHelpersResolver, _emberQunit) {

  (0, _emberQunit.setResolver)(_dummyTestsHelpersResolver['default']);
});
define('dummy/tests/test-helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - test-helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'test-helper.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/addon-tree-test-node', ['exports'], function (exports) {
  /* eslint-env node */

  var expect = require('chai').expect;
  var EmberAddon = require('ember-cli/lib/broccoli/ember-addon');
  var path = require('path');

  function getMirageAddon(options) {
    options = options || {};
    options['ember-cli-mirage'] = options['ember-cli-mirage'] || {};
    options['ember-cli-mirage'].directory = options['ember-cli-mirage'].directory || path.resolve(__dirname, path.join('..', 'dummy', 'mirage'));

    var dummyApp = new EmberAddon(options);

    return findMirage(dummyApp);
  }

  function findMirage(app) {
    var addons = app.project.addons;
    for (var i = 0; i < addons.length; i++) {
      if (addons[i].name === 'ember-cli-mirage') {
        return addons[i];
      }
    }
  }

  describe('Addon', function () {
    this.timeout(15000);

    afterEach(function () {
      delete process.env.EMBER_ENV;
    });

    var treeForTests = function treeForTests(name) {
      it('returns an empty tree in production environment by default', function () {
        process.env.EMBER_ENV = 'production';
        var addonTree = getMirageAddon().treeFor(name);

        expect(addonTree).to.be.undefined;
      });

      ['development', 'test'].forEach(function (environment) {
        it('returns a tree in ' + environment + ' environment by default', function () {
          process.env.EMBER_ENV = environment;
          var addonTree = getMirageAddon().treeFor(name);

          expect(addonTree._inputNodes.length).to.not.equal(0);
        });
      });

      it('returns a tree in production environment when enabled is specified', function () {
        process.env.EMBER_ENV = 'production';
        var addon = getMirageAddon({ configPath: 'tests/fixtures/config/environment-production-enabled' });
        var addonTree = addon.treeFor(name);

        expect(addonTree._inputNodes.length).to.not.equal(0);
      });
    };

    describe('#treeFor addon', function () {
      treeForTests('addon');
    });

    describe('#treeFor app', function () {
      treeForTests('app');
    });
  });
});
define('dummy/tests/unit/addon-tree-test-node.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/addon-tree-test-node.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/addon-tree-test-node.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/collection-test', ['exports', 'ember-cli-mirage/orm/collection', 'qunit'], function (exports, _emberCliMirageOrmCollection, _qunit) {

  (0, _qunit.module)('Unit | Collection');

  (0, _qunit.test)('it can be instantiated', function (assert) {
    var collection = new _emberCliMirageOrmCollection['default']('plant');

    assert.ok(collection);
  });

  (0, _qunit.test)('it cannot be instantiated without a modelName', function (assert) {
    assert.throws(function () {
      new _emberCliMirageOrmCollection['default']();
    }, /must pass a `modelName`/);
  });

  (0, _qunit.test)('it knows its modelname', function (assert) {
    var collection = new _emberCliMirageOrmCollection['default']('author');

    assert.equal(collection.modelName, 'author');
  });

  (0, _qunit.test)('it can be instantiated with an array of models', function (assert) {
    var models = [{ id: 1 }, { id: 2 }, { id: 3 }];
    var collection = new _emberCliMirageOrmCollection['default']('author', models);

    assert.ok(collection);
  });

  (0, _qunit.test)('#models returns the underlying array', function (assert) {
    var models = [{ id: 1 }, { id: 2 }, { id: 3 }];
    var collection = new _emberCliMirageOrmCollection['default']('author', models);

    assert.deepEqual(collection.models, models);
  });

  (0, _qunit.test)('#length returns the number of elements', function (assert) {
    var models = [{ id: 1 }, { id: 2 }];
    var collection = new _emberCliMirageOrmCollection['default']('post', models);

    assert.equal(collection.length, 2);

    collection.models = [{ id: 1 }];
    assert.equal(collection.length, 1);
  });

  // test('collection.filter returns collection instance', function(assert) {
  //   let collection = new Collection('plant');
  //   let filteredCollection = collection.filter(Boolean);
  //   assert.ok(filteredCollection instanceof Collection);
  //   assert.equal(filteredCollection.modelName, 'plant');
  // });
  //
  // test('collection.mergeCollection works', function(assert) {
  //   let collection1 = new Collection('plant', { name: 'chrerry' }, { name: 'uchreaflier' });
  //   let collection2 = new Collection('plant', { name: 'vlip' });
  //   assert.equal(collection1.length, 2);
  //   assert.equal(collection2.length, 1);
  //   collection2.mergeCollection(collection1);
  //   assert.equal(collection2.length, 3);
  //   assert.equal(collection2.modelName, 'plant');
  // });
  //
});
define('dummy/tests/unit/collection-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/collection-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/collection-test.js should pass ESLint.\n');
  });
});
define("dummy/tests/unit/controller-test", ["exports"], function (exports) {});
// import Controller from 'ember-cli-mirage/controller';
// import Db from 'ember-cli-mirage/db';
// import Response from 'ember-cli-mirage/response';

// import {module, test} from 'qunit';

// var contacts = [{id: 1, name: 'Link', address_ids: [1]}, {id: 2, name: 'Zelda', address_ids: [2]}];
// var addresses = [{id: 1, name: '123 Hyrule Way', contact_id: 1}, {id: 2, name: '456 Hyrule Way', contact_id: 2}];
// var db;
// module('mirage:controller', {
//   beforeEach: function() {
//     db = new Db();
//     db.createCollections('contacts', 'addresses');
//     db.contacts.insert(contacts);
//     db.addresses.insert(addresses);

//     var serializerDouble = {
//       serialize: function(res) {return res; }
//     };
//     this.controller = new Controller(serializerDouble);
//   }
// });

// test("function handler works", function(assert) {
//   var response = this.controller.handle('get', function(db, request) {
//     return db.contacts;
//   }, db, {params: {id: 1}});

//   assert.deepEqual(response[2], contacts);
// });

// test("function handler works with custom response", function(assert) {
//   var response = this.controller.handle('get', function(db, request) {
//     return new Response(201, {some: 'header'}, {some: 'data'});
//   }, db);

//   assert.deepEqual(response, [201, {some: 'header'}, {some: 'data'}]);
// });

// test('its default response is 200 if the verb is get', function(assert) {
//   var response = this.controller.handle('get', {});
//   assert.equal(response[0], 200);
// });

// test('its default response is 204 if the verb is put and the response is empty', function(assert) {
//   var response = this.controller.handle('put', {});
//   assert.equal(response[0], 204);
// });

// test('its default response is 200 if the verb is put and the response is not empty and no specific code passed', function(assert) {
//   var response = this.controller.handle('put', function() {
//     return { text: 'thanks' };
//   });
//   assert.equal(response[0], 200, 'Returning a non-empty object changes the default code to 200');

//   var response2 = this.controller.handle('put', function() {
//     return [];
//   });
//   assert.equal(response2[0], 200, 'An empty array IS NOT an empty response');

//   var response3 = this.controller.handle('put', function() {
//     return;
//   });
//   assert.equal(response3[0], 204, 'undefined is considered an empty response');

//   var response4 = this.controller.handle('put', function() {
//     return '';
//   });
//   assert.equal(response4[0], 204, 'An empty string is considered and empty response');

//   var response5 = this.controller.handle('put', function() {
//     return;
//   }, 204);
//   assert.equal(response5[0], 204, 'If the response code is forced, that takes precedence');

//   var response6 = this.controller.handle('put', function() {
//     return {};
//   }, 204);
//   assert.equal(response6[0], 204, 'An empty object is considered and empty response');
// });

// test('its default response is 201 if the verb is post', function(assert) {
//   var response = this.controller.handle('put', {});
//   assert.equal(response[0], 204);
// });

// test('its default response is 204 if the verb is delete and the response is empty', function(assert) {
//   var response = this.controller.handle('delete', {});
//   assert.equal(response[0], 204);
// });

// test('its default response is 200 if the verb is delete and the response is not empty and no specific code passed', function(assert) {
//   var response = this.controller.handle('delete', function() {
//     return { text: 'thanks' };
//   });
//   assert.equal(response[0], 200, 'Returning a non-empty object changes the default code to 200');

//   var response2 = this.controller.handle('delete', function() {
//     return [];
//   });
//   assert.equal(response2[0], 200, 'An empty array IS NOT an empty response');

//   var response3 = this.controller.handle('delete', function() {
//     return;
//   });
//   assert.equal(response3[0], 204, 'undefined is considered an empty response');

//   var response4 = this.controller.handle('delete', function() {
//     return '';
//   });
//   assert.equal(response4[0], 204, 'An empty string is considered and empty response');

//   var response5 = this.controller.handle('delete', function() {
//     return;
//   }, 204);
//   assert.equal(response5[0], 204, 'If the response code is forced, that takes precedence');

//   var response6 = this.controller.handle('delete', function() {
//     return {};
//   }, 204);
//   assert.equal(response6[0], 204, 'An empty object is considered and empty response');
// });

// // TODO: Use spies to ensure get#shorthand is called with appropriate args
// // module('mirage:controller#get');
// // module('mirage:controller#post');
// // module('mirage:controller#put');
// // module('mirage:controller#delete');
define('dummy/tests/unit/controller-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/controller-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/controller-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/db-test', ['exports', 'ember-cli-mirage/db', 'qunit'], function (exports, _emberCliMirageDb, _qunit) {

  var db = undefined;
  (0, _qunit.module)('Unit | Db');

  (0, _qunit.test)('it can be instantiated', function (assert) {
    db = new _emberCliMirageDb['default']();
    assert.ok(db);
  });

  (0, _qunit.test)('it can load data on instantiation', function (assert) {
    db = new _emberCliMirageDb['default']({
      users: [{ id: 1, name: 'Link' }],
      addresses: [{ id: 1, name: '123 Hyrule Way' }, { id: 2, name: 'Lorem ipsum' }]
    });

    assert.equal(db.users.length, 1);
    assert.equal(db.addresses.length, 2);
  });

  (0, _qunit.test)('it can empty its data', function (assert) {
    db = new _emberCliMirageDb['default']({
      users: [{ id: 1, name: 'Link' }],
      addresses: [{ id: 1, name: '123 Hyrule Way' }, { id: 2, name: 'Lorem ipsum' }]
    });

    db.emptyData();

    assert.equal(db.users.length, 0);
    assert.equal(db.addresses.length, 0);
  });

  (0, _qunit.module)('Unit | Db #createCollection', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']();
    },
    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('it can create an empty collection', function (assert) {
    db.createCollection('contacts');

    assert.ok(db.contacts);
  });

  (0, _qunit.test)('it can create many collections', function (assert) {
    db.createCollections('contacts', 'addresses');

    assert.ok(db.contacts);
    assert.ok(db.addresses);
  });

  (0, _qunit.module)('Unit | Db #loadData', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']();
    },
    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('it can load an object of data', function (assert) {
    var data = {
      contacts: [{ id: '1', name: 'Link' }],
      addresses: [{ id: '1', name: '123 Hyrule Way' }]
    };
    db.loadData(data);

    assert.deepEqual(db.contacts, data.contacts);
    assert.deepEqual(db.addresses, data.addresses);
  });

  (0, _qunit.module)('Unit | Db #all', {
    beforeEach: function beforeEach() {
      this.data = {
        contacts: [{ id: '1', name: 'Link' }],
        addresses: [{ id: '1', name: '123 Hyrule Way' }]
      };

      db = new _emberCliMirageDb['default'](this.data);
    },
    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('it can return a collection', function (assert) {
    assert.deepEqual(db.contacts, this.data.contacts);
    assert.deepEqual(db.addresses, this.data.addresses);
  });

  (0, _qunit.test)('the collection is a copy', function (assert) {
    var _db = db;
    var contacts = _db.contacts;

    assert.deepEqual(contacts, this.data.contacts);
    contacts[0].name = 'Zelda';

    assert.deepEqual(db.contacts, this.data.contacts);
  });

  (0, _qunit.module)('Unit | Db #insert', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']();
      db.createCollection('contacts');
    },

    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('it inserts an object and returns it', function (assert) {
    var link = db.contacts.insert({ name: 'Link' });
    var expectedRecord = {
      id: '1',
      name: 'Link'
    };

    assert.deepEqual(db.contacts, [expectedRecord]);
    assert.deepEqual(link, expectedRecord);
  });

  (0, _qunit.test)('it returns a copy', function (assert) {
    var link = db.contacts.insert({ name: 'Link' });
    var expectedRecord = {
      id: '1',
      name: 'Link'
    };

    assert.deepEqual(link, expectedRecord);

    link.name = 'Young link';

    assert.deepEqual(db.contacts.find(1), expectedRecord);
  });

  (0, _qunit.test)('it can insert objects sequentially', function (assert) {
    db.contacts.insert({ name: 'Link' });
    db.contacts.insert({ name: 'Ganon' });

    var records = [{ id: '1', name: 'Link' }, { id: '2', name: 'Ganon' }];

    assert.deepEqual(db.contacts, records);
  });

  (0, _qunit.test)('it does not add an id if present', function (assert) {
    var attrs = { id: '5', name: 'Link' };

    db.contacts.insert(attrs);

    assert.deepEqual(db.contacts, [attrs]);
  });

  (0, _qunit.test)('it can insert an array and return it', function (assert) {
    db.contacts.insert({ name: 'Link' });

    var contacts = db.contacts.insert([{ name: 'Zelda' }, { name: 'Ganon' }]);

    assert.deepEqual(db.contacts, [{ id: '1', name: 'Link' }, { id: '2', name: 'Zelda' }, { id: '3', name: 'Ganon' }]);
    assert.deepEqual(contacts, [{ id: '2', name: 'Zelda' }, { id: '3', name: 'Ganon' }]);
  });

  (0, _qunit.test)('it does not add ids to array data if present', function (assert) {
    db.contacts.insert([{ id: 2, name: 'Link' }, { id: 1, name: 'Ganon' }]);

    assert.deepEqual(db.contacts, [{ id: '1', name: 'Ganon' }, { id: '2', name: 'Link' }]);
  });

  (0, _qunit.test)('it can insert a record with an id of 0', function (assert) {
    db.contacts.insert({ id: 0, name: 'Link' });

    assert.deepEqual(db.contacts, [{ id: '0', name: 'Link' }]);
  });

  (0, _qunit.test)('IDs increment correctly, even after a record is removed', function (assert) {
    var records = db.contacts.insert([{ name: 'Link' }, { name: 'Ganon' }]);

    db.contacts.remove(records[0]);

    var record = db.contacts.insert({ name: 'Zelda' });

    assert.equal(record.id, 3);
  });

  (0, _qunit.test)('inserting a record with an already used ID throws an error', function (assert) {
    assert.expect(2);

    db.contacts.insert({ id: 1, name: 'Duncan McCleod' });

    assert.throws(function () {
      db.contacts.insert({ id: 1, name: 'Duncan McCleod' });
    });

    db.contacts.insert({ id: 'atp', name: 'Adenosine Triphosphate' });

    assert.throws(function () {
      db.contacts.insert({ id: 'atp', name: 'Adenosine Triphosphate' });
    });
  });

  (0, _qunit.test)('tracks the correct IDs being used', function (assert) {
    db.contacts.insert({ name: 'Vegeta' });
    db.contacts.insert({ id: 2, name: 'Krilli' });

    assert.equal(db.contacts.length, 2);
  });

  (0, _qunit.module)('Unit | Db #findBy', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']();
      db.createCollection('contacts');
      db.contacts.insert([{ name: 'Zelda' }, { name: 'Link' }, { name: 'Epona', race: 'Horse' }, { name: 'Epona', race: 'Centaur' }, { id: 'abc', name: 'Ganon' }]);
    },
    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('returns a record that matches the given name', function (assert) {
    var contact = db.contacts.findBy({ 'name': 'Link' });

    assert.deepEqual(contact, { id: '2', name: 'Link' });
  });

  (0, _qunit.test)('returns a copy not a reference', function (assert) {
    var contact = db.contacts.findBy({ 'name': 'Link' });

    contact.name = 'blah';

    assert.deepEqual(db.contacts.find(2), { id: '2', name: 'Link' });
  });

  (0, _qunit.test)('returns the first record matching the criteria', function (assert) {
    var contact = db.contacts.findBy({ 'name': 'Epona' });

    assert.deepEqual(contact, { id: '3', name: 'Epona', race: 'Horse' });
  });

  (0, _qunit.test)('returns a record only matching multiple criteria', function (assert) {
    var contact = db.contacts.findBy({ 'name': 'Epona', 'race': 'Centaur' });

    assert.deepEqual(contact, { id: '4', name: 'Epona', race: 'Centaur' });
  });

  (0, _qunit.test)('returns null when no record is found', function (assert) {
    var contact = db.contacts.findBy({ 'name': 'Fi' });

    assert.equal(contact, null);
  });

  (0, _qunit.module)('Unit | Db #find', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']();
      db.createCollection('contacts');
      db.contacts.insert([{ name: 'Zelda' }, { name: 'Link' }, { id: 'abc', name: 'Ganon' }]);
    },
    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('returns a record that matches a numerical id', function (assert) {
    var contact = db.contacts.find(2);

    assert.deepEqual(contact, { id: '2', name: 'Link' });
  });

  (0, _qunit.test)('returns a copy not a reference', function (assert) {
    var contact = db.contacts.find(2);

    assert.deepEqual(contact, { id: '2', name: 'Link' });

    contact.name = 'blah';

    assert.deepEqual(db.contacts.find(2), { id: '2', name: 'Link' });
  });

  (0, _qunit.test)('returns a record that matches a string id', function (assert) {
    var contact = db.contacts.find('abc');

    assert.deepEqual(contact, { id: 'abc', name: 'Ganon' });
  });

  (0, _qunit.test)('returns multiple record that matches an array of ids', function (assert) {
    var contacts = db.contacts.find([1, 2]);

    assert.deepEqual(contacts, [{ id: '1', name: 'Zelda' }, { id: '2', name: 'Link' }]);
  });

  (0, _qunit.test)('returns a record whose id is a string that start with numbers', function (assert) {
    db.contacts.insert({
      id: '123-456',
      name: 'Epona'
    });

    var contact = db.contacts.find('123-456');
    assert.deepEqual(contact, { id: '123-456', name: 'Epona' });
  });

  (0, _qunit.test)('returns multiple record that match an array of ids', function (assert) {
    var contacts = db.contacts.find([1, 2]);

    assert.deepEqual(contacts, [{ id: '1', name: 'Zelda' }, { id: '2', name: 'Link' }]);
  });

  (0, _qunit.test)('returns an empty array when it doesnt find multiple ids', function (assert) {
    var contacts = db.contacts.find([99, 100]);

    assert.deepEqual(contacts, []);
  });

  (0, _qunit.module)('Unit | Db #where', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']();
      db.createCollection('contacts');
      db.contacts.insert([{ name: 'Link', evil: false, age: 17 }, { name: 'Zelda', evil: false, age: 17 }, { name: 'Ganon', evil: true, age: 45 }]);
    },
    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('returns an array of records that match the query', function (assert) {
    var result = db.contacts.where({ evil: true });

    assert.deepEqual(result, [{ id: '3', name: 'Ganon', evil: true, age: 45 }]);
  });

  (0, _qunit.test)('it coerces query params to strings', function (assert) {
    var result = db.contacts.where({ age: '45' });

    assert.deepEqual(result, [{ id: '3', name: 'Ganon', evil: true, age: 45 }]);
  });

  (0, _qunit.test)('returns a copy, not a referecne', function (assert) {
    var result = db.contacts.where({ evil: true });

    assert.deepEqual(result, [{ id: '3', name: 'Ganon', evil: true, age: 45 }]);

    result[0].evil = false;

    assert.deepEqual(db.contacts.where({ evil: true }), [{ id: '3', name: 'Ganon', evil: true, age: 45 }]);
  });

  (0, _qunit.test)('returns an empty array if no records match the query', function (assert) {
    var result = db.contacts.where({ name: 'Link', evil: true });

    assert.deepEqual(result, []);
  });

  (0, _qunit.test)('accepts a filter function', function (assert) {
    var result = db.contacts.where(function (record) {
      return record.age === 45;
    });

    assert.deepEqual(result, [{ id: '3', name: 'Ganon', evil: true, age: 45 }]);
  });

  (0, _qunit.module)('Unit | Db #update', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']();
      db.createCollection('contacts');
      db.contacts.insert([{ name: 'Link', evil: false }, { name: 'Zelda', evil: false }, { name: 'Ganon', evil: true }, { id: '123-abc', name: 'Epona', evil: false }]);
    },
    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('it can update the whole collection', function (assert) {
    db.contacts.update({ name: 'Sam', evil: false });

    var actualContacts = db.contacts;

    var expectedContacts = [{ id: '123-abc', name: 'Sam', evil: false }, { id: '1', name: 'Sam', evil: false }, { id: '2', name: 'Sam', evil: false }, { id: '3', name: 'Sam', evil: false }];

    assert.deepEqual(actualContacts, expectedContacts, [actualContacts.map(function (r) {
      return r.id;
    }).join(','), expectedContacts.map(function (r) {
      return r.id;
    }).join(',')].join(';'));
  });

  (0, _qunit.test)('it can update a record by id', function (assert) {
    db.contacts.update(3, { name: 'Ganondorf', evil: false });
    var ganon = db.contacts.find(3);

    assert.deepEqual(ganon, { id: '3', name: 'Ganondorf', evil: false });
  });

  (0, _qunit.test)('it can update a record by id when the id is a string', function (assert) {
    db.contacts.update('123-abc', { evil: true });
    var epona = db.contacts.find('123-abc');

    assert.deepEqual(epona, { id: '123-abc', name: 'Epona', evil: true });
  });

  (0, _qunit.test)('it can update multiple records by ids', function (assert) {
    db.contacts.update([1, 2], { evil: true });
    var link = db.contacts.find(1);
    var zelda = db.contacts.find(2);

    assert.equal(link.evil, true);
    assert.equal(zelda.evil, true);
  });

  (0, _qunit.test)('it can update records by query', function (assert) {
    db.contacts.update({ evil: false }, { name: 'Sam' });

    assert.deepEqual(db.contacts, [{ id: '123-abc', name: 'Sam', evil: false }, { id: '1', name: 'Sam', evil: false }, { id: '2', name: 'Sam', evil: false }, { id: '3', name: 'Ganon', evil: true }]);
  });

  (0, _qunit.test)('updating a single record returns that record', function (assert) {
    var ganon = db.contacts.update(3, { name: 'Ganondorf' });
    assert.deepEqual(ganon, { id: '3', name: 'Ganondorf', evil: true });
  });

  (0, _qunit.test)('updating a collection returns the updated records', function (assert) {
    var characters = db.contacts.update({ evil: true });
    assert.deepEqual(characters, [{ id: '123-abc', name: 'Epona', evil: true }, { id: '1', name: 'Link', evil: true }, { id: '2', name: 'Zelda', evil: true }]);
  });

  (0, _qunit.test)('updating multiple records returns the updated records', function (assert) {
    var characters = db.contacts.update({ evil: false }, { evil: true });
    assert.deepEqual(characters, [{ id: '123-abc', name: 'Epona', evil: true }, { id: '1', name: 'Link', evil: true }, { id: '2', name: 'Zelda', evil: true }]);
  });

  (0, _qunit.test)('throws when updating an ID is attempted', function (assert) {
    assert.expect(1);

    assert.throws(function () {
      db.contacts.update(1, { id: 3 });
    });
  });

  (0, _qunit.module)('Unit | Db #remove', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']();
      db.createCollection('contacts');
      db.contacts.insert([{ name: 'Link', evil: false }, { name: 'Zelda', evil: false }, { name: 'Ganon', evil: true }, { id: '123-abc', name: 'Epona', evil: false }]);
    },

    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('it can remove an entire collection', function (assert) {
    db.contacts.remove();

    assert.deepEqual(db.contacts, []);
  });

  (0, _qunit.test)('it can remove a single record by id', function (assert) {
    db.contacts.remove(1);

    assert.deepEqual(db.contacts, [{ id: '123-abc', name: 'Epona', evil: false }, { id: '2', name: 'Zelda', evil: false }, { id: '3', name: 'Ganon', evil: true }]);
  });

  (0, _qunit.test)('it can remove a single record when the id is a string', function (assert) {
    db.contacts.remove('123-abc');

    assert.deepEqual(db.contacts, [{ id: '1', name: 'Link', evil: false }, { id: '2', name: 'Zelda', evil: false }, { id: '3', name: 'Ganon', evil: true }]);
  });

  (0, _qunit.test)('it can remove multiple records by ids', function (assert) {
    db.contacts.remove([1, 2]);

    assert.deepEqual(db.contacts, [{ id: '123-abc', name: 'Epona', evil: false }, { id: '3', name: 'Ganon', evil: true }]);
  });

  (0, _qunit.test)('it can remove multiple records by query', function (assert) {
    db.contacts.remove({ evil: false });

    assert.deepEqual(db.contacts, [{ id: '3', name: 'Ganon', evil: true }]);
  });

  (0, _qunit.test)('it can add a record after removing all records', function (assert) {
    db.contacts.remove();
    db.contacts.insert({ name: 'Foo' });

    assert.equal(db.contacts.length, 1);
    assert.deepEqual(db.contacts, [{ id: '1', name: 'Foo' }]);
  });

  (0, _qunit.module)('Unit | Db #firstOrCreate', {
    beforeEach: function beforeEach() {
      db = new _emberCliMirageDb['default']();
      db.createCollection('contacts');
      db.contacts.insert([{ id: 1, name: 'Link', evil: false }, { id: 2, name: 'Zelda', evil: false }, { id: 3, name: 'Ganon', evil: true }]);
    },

    afterEach: function afterEach() {
      db.emptyData();
    }
  });

  (0, _qunit.test)('it can find the first record available from the query', function (assert) {
    var record = db.contacts.firstOrCreate({ name: 'Link' });

    assert.deepEqual(record, { id: '1', name: 'Link', evil: false });
  });

  (0, _qunit.test)('it creates a new record from query + attrs if none found', function (assert) {
    var record = db.contacts.firstOrCreate({ name: 'Mario' }, { evil: false });

    assert.equal(record.name, 'Mario');
    assert.equal(record.evil, false);
    assert.ok(record.id);
  });

  (0, _qunit.test)('does not require attrs', function (assert) {
    var record = db.contacts.firstOrCreate({ name: 'Luigi' });

    assert.equal(record.name, 'Luigi');
    assert.ok(record.id);
  });
});
define('dummy/tests/unit/db-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/db-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/db-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/db/identity-manager-test', ['exports', 'ember-cli-mirage/db-collection', 'qunit'], function (exports, _emberCliMirageDbCollection, _qunit) {

  (0, _qunit.module)('Unit | DB | IdentityManager');

  (0, _qunit.test)('it can be instantiated', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();
    assert.ok(manager);
  });

  (0, _qunit.test)('fetch returns the latest number', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();

    assert.equal(manager.fetch(), 1);
    assert.equal(manager.fetch(), 2);
    assert.equal(manager.fetch(), 3);
  });

  (0, _qunit.test)('get returns the upcoming id used for fetch', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();

    assert.equal(manager.fetch(), 1);
    assert.equal(manager.get(), 2);
    assert.equal(manager.fetch(), 2);
  });

  (0, _qunit.test)('set indicates an id is being used', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();
    manager.set('abc');

    assert.throws(function () {
      manager.set('abc');
    }, /already been used/);
  });

  (0, _qunit.test)('a numerical value passed into set affects future ids used by fetch', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();
    manager.set(5);

    assert.equal(manager.fetch(), 6);
    assert.equal(manager.fetch(), 7);
  });

  (0, _qunit.test)('multiple numerical values passed into set affects future ids used by fetch', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();
    manager.set(5);
    manager.set(6);

    assert.equal(manager.fetch(), 7);
    assert.equal(manager.fetch(), 8);
  });

  (0, _qunit.test)('an int as a string passed into set affects future ids used by fetch', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();
    manager.set('5');

    assert.equal(manager.fetch(), 6);
    assert.equal(manager.fetch(), 7);
  });

  (0, _qunit.test)('multiple ints as a string passed into set affects future ids used by fetch', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();
    manager.set('5');
    manager.set('6');

    assert.equal(manager.fetch(), 7);
    assert.equal(manager.fetch(), 8);
  });

  (0, _qunit.test)('a string value that doesn\'t parse as an int passed into set doesn\'t affect future ids used by fetch', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();
    manager.set('123-abc');

    assert.equal(manager.fetch(), 1);
    assert.equal(manager.fetch(), 2);
  });

  (0, _qunit.test)('reset clears the managers memory', function (assert) {
    var manager = new _emberCliMirageDbCollection.IdentityManager();
    manager.set('abc');
    manager.reset();
    manager.set('abc');

    assert.ok(true);
  });
});
define('dummy/tests/unit/db/identity-manager-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/db/identity-manager-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/db/identity-manager-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/factory-test', ['exports', 'ember-cli-mirage', 'qunit'], function (exports, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Unit | Factory');

  (0, _qunit.test)('it exists', function (assert) {
    assert.ok(_emberCliMirage['default'].Factory);
  });

  (0, _qunit.test)('the base class builds empty objects', function (assert) {
    var f = new _emberCliMirage['default'].Factory();
    var data = f.build();

    assert.deepEqual(data, {});
  });

  (0, _qunit.test)('a noop extension builds empty objects', function (assert) {
    var EmptyFactory = _emberCliMirage['default'].Factory.extend();
    var f = new EmptyFactory();
    var data = f.build();

    assert.deepEqual(data, {});
  });

  (0, _qunit.test)('it works with strings, numbers and booleans', function (assert) {
    var AFactory = _emberCliMirage['default'].Factory.extend({
      name: 'Sam',
      age: 28,
      alive: true
    });

    var f = new AFactory();
    var data = f.build();

    assert.deepEqual(data, { name: 'Sam', age: 28, alive: true });
  });

  (0, _qunit.test)('it supports inheritance', function (assert) {
    var PersonFactory = _emberCliMirage['default'].Factory.extend({
      species: 'human'
    });
    var ManFactory = PersonFactory.extend({
      gender: 'male'
    });
    var SamFactory = ManFactory.extend({
      name: 'Sam'
    });

    var p = new PersonFactory();
    var m = new ManFactory();
    var s = new SamFactory();

    assert.deepEqual(p.build(), { species: 'human' });
    assert.deepEqual(m.build(), { species: 'human', gender: 'male' });
    assert.deepEqual(s.build(), { species: 'human', gender: 'male', name: 'Sam' });
  });

  (0, _qunit.test)('it can use sequences', function (assert) {
    var PostFactory = _emberCliMirage['default'].Factory.extend({
      likes: function likes(i) {
        return 5 * i;
      }
    });

    var p = new PostFactory();
    var post1 = p.build(1);
    var post2 = p.build(2);

    assert.deepEqual(post1, { likes: 5 });
    assert.deepEqual(post2, { likes: 10 });
  });

  (0, _qunit.test)('it can reuse static properties', function (assert) {
    var BazFactory = _emberCliMirage['default'].Factory.extend({
      foo: 5,
      bar: function bar(i) {
        return this.foo * i;
      }
    });

    var b = new BazFactory();
    var baz1 = b.build(1);
    var baz2 = b.build(2);

    assert.deepEqual(baz1, { foo: 5, bar: 5 });
    assert.deepEqual(baz2, { foo: 5, bar: 10 });
  });

  (0, _qunit.test)('it can reuse dynamic properties', function (assert) {
    var BazFactory = _emberCliMirage['default'].Factory.extend({
      foo: function foo(i) {
        return 5 * i;
      },
      bar: function bar() {
        return this.foo * 2;
      }
    });

    var b = new BazFactory();
    var baz1 = b.build(1);
    var baz2 = b.build(2);

    assert.deepEqual(baz1, { foo: 5, bar: 10 });
    assert.deepEqual(baz2, { foo: 10, bar: 20 });
  });

  (0, _qunit.test)('it can have dynamic properties that depend on another', function (assert) {
    var BazFactory = _emberCliMirage['default'].Factory.extend({
      name: function name() {
        return 'foo';
      },
      bar: function bar() {
        return this.name.substr(1);
      }
    });

    var b = new BazFactory();
    var baz1 = b.build(1);

    assert.deepEqual(baz1, { name: 'foo', bar: 'oo' });
  });

  (0, _qunit.test)('it can reference properties out of order', function (assert) {
    var BazFactory = _emberCliMirage['default'].Factory.extend({
      bar: function bar() {
        return this.foo + 2;
      },

      baz: 6,

      foo: function foo(i) {
        return this.baz * i;
      }
    });

    var b = new BazFactory();
    var baz1 = b.build(1);
    var baz2 = b.build(2);

    assert.deepEqual(baz1, { baz: 6, foo: 6, bar: 8 });
    assert.deepEqual(baz2, { baz: 6, foo: 12, bar: 14 });
  });

  (0, _qunit.test)('it can reference multiple properties in any order', function (assert) {
    var FooFactory = _emberCliMirage['default'].Factory.extend({
      foo: function foo() {
        return this.bar + this.baz;
      },

      bar: 6,

      baz: 10
    });

    var BarFactory = _emberCliMirage['default'].Factory.extend({
      bar: 6,

      foo: function foo() {
        return this.bar + this.baz;
      },

      baz: 10
    });

    var BazFactory = _emberCliMirage['default'].Factory.extend({
      bar: 6,

      baz: 10,

      foo: function foo() {
        return this.bar + this.baz;
      }
    });

    var Foo = new FooFactory();
    var Bar = new BarFactory();
    var Baz = new BazFactory();

    var foo = Foo.build(1);
    var bar = Bar.build(1);
    var baz = Baz.build(1);

    assert.deepEqual(foo, { foo: 16, bar: 6, baz: 10 });
    assert.deepEqual(bar, { foo: 16, bar: 6, baz: 10 });
    assert.deepEqual(baz, { foo: 16, bar: 6, baz: 10 });
  });

  (0, _qunit.test)('it can reference properties on complex object', function (assert) {
    var AbcFactory = _emberCliMirage['default'].Factory.extend({
      a: function a(i) {
        return this.b + i;
      },
      b: function b() {
        return this.c + 1;
      },
      c: function c() {
        return this.f + 1;
      },
      d: function d(i) {
        return this.e + i;
      },
      e: function e() {
        return this.c + 1;
      },
      f: 1,
      g: 2,
      h: 3
    });

    var b = new AbcFactory();
    var abc1 = b.build(1);
    var abc2 = b.build(2);

    assert.deepEqual(abc1, { a: 4, b: 3, c: 2, d: 4, e: 3, f: 1, g: 2, h: 3 });
    assert.deepEqual(abc2, { a: 5, b: 3, c: 2, d: 5, e: 3, f: 1, g: 2, h: 3 });
  });

  (0, _qunit.test)('throws meaningfull exception on circular reference', function (assert) {
    var BazFactory = _emberCliMirage['default'].Factory.extend({
      bar: function bar() {
        return this.foo;
      },

      foo: function foo() {
        return this.bar;
      }
    });

    var b = new BazFactory();
    assert.throws(function () {
      b.build(1);
    }, function (e) {
      return e.toString() === 'Error: Cyclic dependency in properties ["foo","bar"]';
    });
  });

  (0, _qunit.test)('#build skips invoking `afterCreate`', function (assert) {
    var skipped = true;
    var PostFactory = _emberCliMirage['default'].Factory.extend({
      afterCreate: function afterCreate() {
        skipped = false;
      }
    });

    var factory = new PostFactory();
    var post = factory.build(0);

    assert.ok(skipped, 'skips invoking `afterCreate`');
    assert.equal(typeof post.afterCreate, 'undefined', 'does not build `afterCreate` attribute');
  });

  (0, _qunit.test)('extractAfterCreateCallbacks returns all afterCreate callbacks from factory with the base one being first', function (assert) {
    var PostFactory = _emberCliMirage['default'].Factory.extend({
      published: (0, _emberCliMirage.trait)({
        afterCreate: function afterCreate() {
          return 'from published';
        }
      }),

      withComments: (0, _emberCliMirage.trait)({
        afterCreate: function afterCreate() {
          return 'from withComments';
        }
      }),

      otherTrait: (0, _emberCliMirage.trait)({}),

      afterCreate: function afterCreate() {
        return 'from base';
      }
    });

    var callbacks = PostFactory.extractAfterCreateCallbacks();
    assert.equal(callbacks.length, 3);
    assert.deepEqual(callbacks.map(function (cb) {
      return cb();
    }), ['from base', 'from published', 'from withComments']);
  });

  (0, _qunit.test)('extractAfterCreateCallbacks filters traits from which the afterCreate callbacks will be extracted from', function (assert) {
    var PostFactory = _emberCliMirage['default'].Factory.extend({
      published: (0, _emberCliMirage.trait)({
        afterCreate: function afterCreate() {
          return 'from published';
        }
      }),

      withComments: (0, _emberCliMirage.trait)({
        afterCreate: function afterCreate() {
          return 'from withComments';
        }
      }),

      otherTrait: (0, _emberCliMirage.trait)({}),

      afterCreate: function afterCreate() {
        return 'from base';
      }
    });

    assert.equal(PostFactory.extractAfterCreateCallbacks({ traits: [] }).length, 1);
    assert.deepEqual(PostFactory.extractAfterCreateCallbacks({ traits: [] }).map(function (cb) {
      return cb();
    }), ['from base']);

    assert.equal(PostFactory.extractAfterCreateCallbacks({ traits: ['withComments'] }).length, 2);
    assert.deepEqual(PostFactory.extractAfterCreateCallbacks({ traits: ['withComments'] }).map(function (cb) {
      return cb();
    }), ['from base', 'from withComments']);

    assert.equal(PostFactory.extractAfterCreateCallbacks({ traits: ['withComments', 'published'] }).length, 3);
    assert.deepEqual(PostFactory.extractAfterCreateCallbacks({ traits: ['withComments', 'published'] }).map(function (cb) {
      return cb();
    }), ['from base', 'from withComments', 'from published']);

    assert.equal(PostFactory.extractAfterCreateCallbacks({ traits: ['withComments', 'otherTrait'] }).length, 2);
    assert.deepEqual(PostFactory.extractAfterCreateCallbacks({ traits: ['withComments', 'otherTrait'] }).map(function (cb) {
      return cb();
    }), ['from base', 'from withComments']);
  });

  (0, _qunit.test)('isTrait returns true if there is a trait with given name', function (assert) {
    var PostFactory = _emberCliMirage['default'].Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true
      }),

      someNestedObject: {
        value: 'nested'
      }
    });

    assert.ok(!PostFactory.isTrait('title'));
    assert.ok(PostFactory.isTrait('published'));
    assert.ok(!PostFactory.isTrait('someNestedObject'));
    assert.ok(!PostFactory.isTrait('notdefined'));
  });
});
define('dummy/tests/unit/factory-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/factory-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/factory-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/faker-test', ['exports', 'ember-cli-mirage/faker', 'qunit'], function (exports, _emberCliMirageFaker, _qunit) {

  (0, _qunit.module)('Unit | Faker');

  (0, _qunit.test)('#cycle - returns a function', function (assert) {
    var callback = _emberCliMirageFaker['default'].list.cycle('first', 'second');
    assert.ok(typeof callback === 'function', 'result is a function');
  });

  (0, _qunit.test)('#cycle - cycles the passed data', function (assert) {
    var callback = _emberCliMirageFaker['default'].list.cycle('first', 'second', 'third');

    assert.equal(callback(0), 'first', 'return the first result for sequence 0');
    assert.equal(callback(1), 'second', 'return the first result for sequence 1');
    assert.equal(callback(2), 'third', 'return the first result for sequence 2');
    assert.equal(callback(3), 'first', 'return the first result for sequence 3');
  });

  (0, _qunit.test)('#random - returns random element from a list', function (assert) {
    var callback = _emberCliMirageFaker['default'].list.random('first', 'second', 'third');

    assert.notEqual(['first', 'second', 'third'].indexOf(callback()), -1, 'returns random value');
  });

  (0, _qunit.test)('#range - creates a random number in a range', function (assert) {
    var min = 0;
    var max = 10;

    var callback = _emberCliMirageFaker['default'].random.number.range(min, max);
    assert.equal(callback() >= min, true, 'result is higher or equal than low value');
    assert.equal(callback() <= max, true, 'result is lower or equal than high value');
  });
});
define('dummy/tests/unit/faker-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/faker-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/faker-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/import-files-test-node', ['exports'], function (exports) {
  /* eslint-env node */

  var expect = require('chai').expect;
  var EmberAddon = require('ember-cli/lib/broccoli/ember-addon');
  var _ = require('lodash');

  describe('import files', function () {
    this.timeout(15000);

    afterEach(function () {
      delete process.env.EMBER_ENV;
    });

    it('doesn\'t include third party libraries in production environment by default', function () {
      process.env.EMBER_ENV = 'production';
      var addon = new EmberAddon();

      expect(_.values(addon._scriptOutputFiles)[0]).to.not.include.members(['vendor/fake-xml-http-request/fake_xml_http_request.js', 'vendor/route-recognizer/dist/route-recognizer.js', 'vendor/pretender/pretender.js', 'vendor/faker/build/build/faker.js', 'vendor/ember-cli-mirage/pretender-shim.js']);
    });

    ['development', 'test'].forEach(function (environment) {
      it('includes third party libraries in ' + environment + ' environment by default', function () {
        process.env.EMBER_ENV = environment;
        var addon = new EmberAddon();

        expect(_.values(addon._scriptOutputFiles)[0]).to.include.members(['vendor/fake-xml-http-request/fake_xml_http_request.js', 'vendor/route-recognizer/dist/route-recognizer.js', 'vendor/pretender/pretender.js', 'vendor/faker/build/build/faker.js', 'vendor/ember-cli-mirage/pretender-shim.js']);
      });
    });

    it('includes third party libraries in production when enabled is set to true', function () {
      process.env.EMBER_ENV = 'production';
      var addon = new EmberAddon({ configPath: 'tests/fixtures/config/environment-production-enabled' });

      expect(_.values(addon._scriptOutputFiles)[0]).to.include.members(['vendor/fake-xml-http-request/fake_xml_http_request.js', 'vendor/route-recognizer/dist/route-recognizer.js', 'vendor/pretender/pretender.js', 'vendor/faker/build/build/faker.js', 'vendor/ember-cli-mirage/pretender-shim.js']);
    });
  });
});
define('dummy/tests/unit/import-files-test-node.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/import-files-test-node.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/import-files-test-node.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/inflector-test', ['exports', 'ember-cli-mirage/utils/inflector', 'qunit'], function (exports, _emberCliMirageUtilsInflector, _qunit) {

  (0, _qunit.module)('Unit | Inflector');

  (0, _qunit.test)('can singularize', function (assert) {
    assert.equal((0, _emberCliMirageUtilsInflector.singularize)('tests'), 'test');
    assert.equal((0, _emberCliMirageUtilsInflector.singularize)('watches'), 'watch');
    assert.equal((0, _emberCliMirageUtilsInflector.singularize)('sheep'), 'sheep');
  });

  (0, _qunit.test)('can pluralize', function (assert) {
    assert.equal((0, _emberCliMirageUtilsInflector.pluralize)('test'), 'tests');
    assert.equal((0, _emberCliMirageUtilsInflector.pluralize)('watch'), 'watches');
    assert.equal((0, _emberCliMirageUtilsInflector.pluralize)('sheep'), 'sheep');
  });
});
define('dummy/tests/unit/inflector-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/inflector-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/inflector-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/model-test', ['exports', 'ember-cli-mirage/orm/model', 'qunit'], function (exports, _emberCliMirageOrmModel, _qunit) {

  (0, _qunit.module)('Unit | Model');

  (0, _qunit.test)('it can be instantiated', function (assert) {
    var model = new _emberCliMirageOrmModel['default']({}, 'user');
    assert.ok(model);
  });

  (0, _qunit.test)('it cannot be instantiated without a schema', function (assert) {
    assert.throws(function () {
      new _emberCliMirageOrmModel['default']();
    }, /requires a schema/);
  });

  (0, _qunit.test)('it cannot be instantiated without a modelName', function (assert) {
    assert.throws(function () {
      new _emberCliMirageOrmModel['default']({});
    }, /requires a modelName/);
  });

  (0, _qunit.test)('findBelongsToAssociation returns association for given type if defined', function (assert) {
    var ModelClass = _emberCliMirageOrmModel['default'].extend();
    var authorAssociationMock = {};
    ModelClass.prototype.belongsToAssociations = {
      author: authorAssociationMock
    };

    assert.equal(ModelClass.findBelongsToAssociation('article'), null);
    assert.deepEqual(ModelClass.findBelongsToAssociation('author'), authorAssociationMock);
  });
});
define('dummy/tests/unit/model-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/model-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/model-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/reference-sort-test', ['exports', 'ember-cli-mirage/utils/reference-sort', 'qunit'], function (exports, _emberCliMirageUtilsReferenceSort, _qunit) {

  (0, _qunit.module)('mirage:reference-sort');

  (0, _qunit.test)('it sorts property references', function (assert) {
    var sorted = (0, _emberCliMirageUtilsReferenceSort['default'])([['propA'], ['propB', 'propC'], ['propC', 'propA'], ['propD']]);

    assert.deepEqual(sorted, ['propD', 'propA', 'propC', 'propB']);
  });

  (0, _qunit.test)('it throws on circular dependency', function (assert) {
    assert.throws(function () {
      (0, _emberCliMirageUtilsReferenceSort['default'])([['propA', 'propB'], ['propB', 'propA']]);
    }, function (e) {
      return e.toString() === 'Error: Cyclic dependency in properties ["propB","propA"]';
    });
  });

  (0, _qunit.test)('it works with no references', function (assert) {
    var sorted = (0, _emberCliMirageUtilsReferenceSort['default'])([['propA'], ['propB'], ['propC'], ['propD']]);

    assert.deepEqual(sorted, ['propD', 'propC', 'propB', 'propA']);
  });
});
define('dummy/tests/unit/reference-sort-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/reference-sort-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/reference-sort-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/response-test', ['exports', 'ember-cli-mirage/response', 'qunit'], function (exports, _emberCliMirageResponse, _qunit) {

  (0, _qunit.module)('Unit | Response');

  (0, _qunit.test)('it can be instantiated and return a rack response', function (assert) {
    var response = new _emberCliMirageResponse['default'](404, {}, {});

    assert.ok(response);
    assert.ok(response.toRackResponse());
  });

  (0, _qunit.test)('it can be instantiated with just a response code', function (assert) {
    var response = new _emberCliMirageResponse['default'](404);

    assert.ok(response);
    assert.ok(response.toRackResponse());
  });
});
define('dummy/tests/unit/response-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/response-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/response-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/route-handlers/shorthands/base-test', ['exports', 'ember-cli-mirage/route-handlers/shorthands/base', 'qunit'], function (exports, _emberCliMirageRouteHandlersShorthandsBase, _qunit) {

  (0, _qunit.module)('Unit | Route handlers | Shorthands | BaseShorthandRouteHandler', {
    beforeEach: function beforeEach() {
      this.handler = new _emberCliMirageRouteHandlersShorthandsBase['default']();
      this.request = { params: { id: '' } };
    }
  });

  (0, _qunit.test)('it returns a number if it\'s a number', function (assert) {
    this.request.params.id = 2;
    assert.equal(this.handler._getIdForRequest(this.request), 2, 'it returns a number');
  });

  (0, _qunit.test)('it returns a number if it\'s a string represented number', function (assert) {
    this.request.params.id = '2';
    assert.equal(this.handler._getIdForRequest(this.request), 2, 'it returns a number');
  });

  (0, _qunit.test)('it returns a string it\'s a dasherized number', function (assert) {
    this.request.params.id = '2-1';
    assert.equal(this.handler._getIdForRequest(this.request), '2-1', 'it returns a number');
  });

  (0, _qunit.test)('it returns a string if it\'s a string', function (assert) {
    this.request.params.id = 'someID';
    assert.equal(this.handler._getIdForRequest(this.request), 'someID', 'it returns a number');
  });

  (0, _qunit.test)('getModelClassFromPath works', function (assert) {
    var urlWithSlash = '/api/fancy-users';
    var urlWithIdAndSlash = '/api/fancy-users/:id';

    assert.equal(this.handler.getModelClassFromPath(urlWithSlash), 'fancy-user', 'it returns a singular model name');
    assert.equal(this.handler.getModelClassFromPath(urlWithIdAndSlash, true), 'fancy-user', 'it returns a singular model name');
  });

  (0, _qunit.test)('it can read the id from the url', function (assert) {
    var request = { params: { id: 'test-id' } };
    assert.equal(this.handler._getIdForRequest(request), 'test-id', 'it returns id from url parameters.');
  });

  (0, _qunit.test)('it can read the id from the request body', function (assert) {
    var request = { params: {} };
    var jsonApiDoc = { data: { id: 'jsonapi-id' } };
    assert.equal(this.handler._getIdForRequest(request, jsonApiDoc), 'jsonapi-id', 'it returns id from json api data.');
  });

  (0, _qunit.test)('_getAttrsForRequest works with attributes and relationships', function (assert) {
    var payload = {
      'data': {
        'attributes': {
          'does-mirage': true,
          'name': 'Sam'
        },
        'relationships': {
          'company': {
            'data': {
              'id': '1',
              'type': 'companies'
            }
          },
          'github-account': {
            'data': {
              'id': '1',
              'type': 'github-accounts'
            }
          },
          'something': {
            'data': null
          },
          'many-things': {
            'data': []
          }
        },
        'type': 'github-account'
      }
    };

    this.handler._getJsonApiDocForRequest = function () {
      return payload;
    };

    var attrs = this.handler._getAttrsForRequest(this.request, 'user');

    assert.deepEqual(attrs, {
      name: 'Sam',
      doesMirage: true,
      companyId: '1',
      githubAccountId: '1',
      somethingId: null
    }, 'it normalizes data correctly.');
  });

  (0, _qunit.test)('_getAttrsForRequest works with just relationships', function (assert) {
    var payload = {
      'data': {
        'relationships': {
          'company': {
            'data': {
              'id': '1',
              'type': 'companies'
            }
          }
        },
        'type': 'github-account'
      }
    };

    this.handler._getJsonApiDocForRequest = function () {
      return payload;
    };

    var attrs = this.handler._getAttrsForRequest(this.request, 'user');

    assert.deepEqual(attrs, {
      companyId: '1'
    }, 'it normalizes data correctly.');
  });

  (0, _qunit.test)('_getAttrsForRequest works with just type', function (assert) {
    var payload = {
      'data': {
        'type': 'github-account'
      }
    };

    this.handler._getJsonApiDocForRequest = function (request, modelName) {
      return payload;
    };

    var attrs = this.handler._getAttrsForRequest(this.request, 'user');

    assert.deepEqual(attrs, {});
  });
});
define('dummy/tests/unit/route-handlers/shorthands/base-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/route-handlers/shorthands/base-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/route-handlers/shorthands/base-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/schema-test', ['exports', 'ember-cli-mirage/orm/schema', 'ember-cli-mirage/db', 'ember-cli-mirage', 'qunit'], function (exports, _emberCliMirageOrmSchema, _emberCliMirageDb, _emberCliMirage, _qunit) {

  (0, _qunit.module)('Unit | Schema');

  (0, _qunit.test)('it can be instantiated', function (assert) {
    var dbMock = {};
    var schema = new _emberCliMirageOrmSchema['default'](dbMock);
    assert.ok(schema);
  });

  (0, _qunit.test)('it cannot be instantiated without a db', function (assert) {
    assert.throws(function () {
      new _emberCliMirageOrmSchema['default']();
    }, /requires a db/);
  });

  (0, _qunit.test)('modelFor returns model for given type if registered', function (assert) {
    var db = new _emberCliMirageDb['default']();
    var schema = new _emberCliMirageOrmSchema['default'](db);

    assert.equal(schema.modelFor('article'), null);

    var authorModel = _emberCliMirage.Model.extend({});
    var articleModel = _emberCliMirage.Model.extend({
      author: (0, _emberCliMirage.belongsTo)()
    });
    schema.registerModel('article', articleModel);
    schema.registerModel('author', authorModel);

    assert.deepEqual(schema.modelFor('article').foreignKeys, ['authorId']);
    assert.deepEqual(schema.modelFor('author').foreignKeys, []);
  });
});
define('dummy/tests/unit/schema-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/schema-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/schema-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/serializers/active-model-serializer-test', ['exports', 'ember-cli-mirage/serializers/active-model-serializer', 'qunit'], function (exports, _emberCliMirageSerializersActiveModelSerializer, _qunit) {

  (0, _qunit.module)('Unit | Serializers | ActiveModelSerializer', {
    beforeEach: function beforeEach() {
      this.serializer = new _emberCliMirageSerializersActiveModelSerializer['default']();
    }
  });

  (0, _qunit.test)('normalize works', function (assert) {
    var payload = {
      contact: {
        id: 1,
        name: 'Link'
      }
    };
    var jsonApiDoc = this.serializer.normalize(payload);

    assert.deepEqual(jsonApiDoc, {
      data: {
        type: 'contacts',
        id: 1,
        attributes: {
          name: 'Link'
        }
      }
    });
  });

  (0, _qunit.test)('it hyphenates snake_cased words', function (assert) {
    var payload = {
      contact: {
        id: 1,
        first_name: 'Link'
      }
    };
    var jsonApiDoc = this.serializer.normalize(payload);

    assert.deepEqual(jsonApiDoc, {
      data: {
        type: 'contacts',
        id: 1,
        attributes: {
          'first-name': 'Link'
        }
      }
    });
  });

  (0, _qunit.test)('it works without an id', function (assert) {
    var payload = {
      contact: {
        first_name: 'Link',
        last_name: 'zor'
      }
    };
    var jsonApiDoc = this.serializer.normalize(payload);

    assert.deepEqual(jsonApiDoc, {
      data: {
        type: 'contacts',
        attributes: {
          'first-name': 'Link',
          'last-name': 'zor'
        }
      }
    });
  });
});
define('dummy/tests/unit/serializers/active-model-serializer-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/serializers/active-model-serializer-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/active-model-serializer-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/serializers/rest-serializer-test', ['exports', 'ember-cli-mirage/serializers/rest-serializer', 'qunit'], function (exports, _emberCliMirageSerializersRestSerializer, _qunit) {

  (0, _qunit.module)('Unit | Serializers | RestSerializer', {
    beforeEach: function beforeEach() {
      this.serializer = new _emberCliMirageSerializersRestSerializer['default']();
    }
  });

  (0, _qunit.test)('it hyphenates camelized words', function (assert) {
    var payload = {
      'person': {
        'id': 1,
        'firstName': 'Rick',
        'lastName': 'Sanchez'
      }
    };
    var jsonApiDoc = this.serializer.normalize(payload);

    assert.deepEqual(jsonApiDoc, {
      data: {
        type: 'people',
        id: 1,
        attributes: {
          'first-name': 'Rick',
          'last-name': 'Sanchez'
        }
      }
    });
  });
});
define('dummy/tests/unit/serializers/rest-serializer-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/serializers/rest-serializer-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/serializers/rest-serializer-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/server-test', ['exports', 'ember-cli-mirage/server', 'qunit', 'ember-cli-mirage'], function (exports, _emberCliMirageServer, _qunit, _emberCliMirage) {

  (0, _qunit.module)('Unit | Server');

  (0, _qunit.test)('it can be instantiated', function (assert) {
    var server = new _emberCliMirageServer['default']({ environment: 'test' });

    assert.ok(server);

    server.shutdown();
  });

  (0, _qunit.test)('it runs the default scenario in non-test environments', function (assert) {
    assert.expect(1);

    var server = new _emberCliMirageServer['default']({
      environment: 'development',
      scenarios: {
        'default': function _default() {
          assert.ok(true);
        }
      }
    });

    server.shutdown();
  });

  (0, _qunit.module)('Unit | Server #loadConfig');

  (0, _qunit.test)('forces timing to 0 in test environment', function (assert) {
    var server = new _emberCliMirageServer['default']({ environment: 'test' });

    server.loadConfig(function () {
      this.timing = 50;
    });

    assert.equal(server.timing, 0);

    server.shutdown();
  });

  (0, _qunit.test)("doesn't modify user's timing config in other environments", function (assert) {
    var server = new _emberCliMirageServer['default']({ environment: 'blah' });

    server.loadConfig(function () {
      this.timing = 50;
    });

    assert.equal(server.timing, 50);

    server.shutdown();
  });

  (0, _qunit.module)('Unit | Server #db');

  (0, _qunit.test)('its db is isolated across instances', function (assert) {
    var server1 = new _emberCliMirageServer['default']({ environment: 'test' });

    server1.db.createCollection('contacts');
    server1.db.contacts.insert({ name: 'Sam' });

    server1.shutdown();

    var server2 = new _emberCliMirageServer['default']({ environment: 'test' });

    assert.equal(server2.contacts, undefined);

    server2.shutdown();
  });

  (0, _qunit.module)('Unit | Server #create');

  (0, _qunit.test)('create fails when no factories or models are registered', function (assert) {
    var server = new _emberCliMirageServer['default']({ environment: 'test' });

    assert.throws(function () {
      server.create('contact');
    });

    server.shutdown();
  });

  (0, _qunit.test)('create fails when an expected factory isn\'t registered', function (assert) {
    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        address: _emberCliMirage.Factory
      }
    });

    assert.throws(function () {
      server.create('contact');
    }, /no model or factory was found/);

    server.shutdown();
  });

  (0, _qunit.test)('create works when models but no factories are registered', function (assert) {
    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      models: {
        contact: _emberCliMirage.Model
      }
    });

    server.create('contact');

    assert.equal(server.db.contacts.length, 1);

    server.shutdown();
  });

  (0, _qunit.test)('create adds the data to the db', function (assert) {
    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        contact: _emberCliMirage.Factory.extend({
          name: 'Sam'
        })
      }
    });

    server.create('contact');
    var contactsInDb = server.db.contacts;

    assert.equal(contactsInDb.length, 1);
    assert.deepEqual(contactsInDb[0], { id: '1', name: 'Sam' });

    server.shutdown();
  });

  (0, _qunit.test)('create returns the new data in the db', function (assert) {
    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        contact: _emberCliMirage.Factory.extend({
          name: 'Sam'
        })
      }
    });

    var contact = server.create('contact');

    assert.deepEqual(contact, { id: '1', name: 'Sam' });

    server.shutdown();
  });

  (0, _qunit.test)('create allows for attr overrides', function (assert) {
    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        contact: _emberCliMirage.Factory.extend({
          name: 'Sam'
        })
      }
    });

    var sam = server.create('contact');
    var link = server.create('contact', { name: 'Link' });

    assert.deepEqual(sam, { id: '1', name: 'Sam' });
    assert.deepEqual(link, { id: '2', name: 'Link' });

    server.shutdown();
  });

  (0, _qunit.test)('create allows for attr overrides with extended factories', function (assert) {
    var ContactFactory = _emberCliMirage.Factory.extend({
      name: 'Link',
      age: 500
    });
    var FriendFactory = ContactFactory.extend({
      is_young: function is_young() {
        return this.age < 18;
      }
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        contact: ContactFactory,
        friend: FriendFactory
      }
    });

    var link = server.create('friend');
    var youngLink = server.create('friend', { age: 10 });

    assert.deepEqual(link, { id: '1', name: 'Link', age: 500, is_young: false });
    assert.deepEqual(youngLink, { id: '2', name: 'Link', age: 10, is_young: true });

    server.shutdown();
  });

  (0, _qunit.test)('create allows for attr overrides with arrays', function (assert) {
    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        contact: _emberCliMirage.Factory.extend({
          name: ['Sam', 'Carl']
        })
      }
    });

    var sam = server.create('contact');
    var link = server.create('contact', { name: ['Link'] });
    var noname = server.create('contact', { name: [] });

    assert.deepEqual(sam, { id: '1', name: ['Sam', 'Carl'] });
    assert.deepEqual(link, { id: '2', name: ['Link'] });
    assert.deepEqual(noname, { id: '3', name: [] });

    server.shutdown();
  });

  (0, _qunit.test)('create allows for nested attr overrides', function (assert) {
    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        contact: _emberCliMirage.Factory.extend({
          address: {
            streetName: 'Main',
            streetAddress: function streetAddress(i) {
              return 1000 + i;
            }
          }
        })
      }
    });

    var contact1 = server.create('contact');
    var contact2 = server.create('contact');

    assert.deepEqual(contact1, { id: '1', address: { streetName: 'Main', streetAddress: 1000 } });
    assert.deepEqual(contact2, { id: '2', address: { streetName: 'Main', streetAddress: 1001 } });

    server.shutdown();
  });

  (0, _qunit.test)('factories can have dynamic properties that depend on attr overrides', function (assert) {
    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        baz: _emberCliMirage.Factory.extend({
          bar: function bar() {
            return this.name.substr(1);
          }
        })
      }
    });

    var baz1 = server.create('baz', { name: 'foo' });

    assert.deepEqual(baz1, { id: '1', name: 'foo', bar: 'oo' });

    server.shutdown();
  });

  (0, _qunit.test)('create allows for arrays of attr overrides', function (assert) {
    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        contact: _emberCliMirage.Factory.extend({
          websites: ['http://example.com', function (i) {
            return 'http://placekitten.com/' + (320 + i) + '/' + (240 + i);
          }]
        })
      }
    });

    var contact1 = server.create('contact');
    var contact2 = server.create('contact');

    assert.deepEqual(contact1, { id: '1', websites: ['http://example.com', 'http://placekitten.com/320/240'] });
    assert.deepEqual(contact2, { id: '2', websites: ['http://example.com', 'http://placekitten.com/321/241'] });

    server.shutdown();
  });

  (0, _qunit.test)('create allows to extend factory with trait', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      })
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory
      }
    });

    var article = server.create('article');
    var publishedArticle = server.create('article', 'published');

    assert.deepEqual(article, { id: '1', title: 'Lorem ipsum' });
    assert.deepEqual(publishedArticle, { id: '2', title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00' });

    server.shutdown();
  });

  (0, _qunit.test)('create allows to extend factory with multiple traits', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      withContent: (0, _emberCliMirage.trait)({
        content: 'content'
      })
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory
      }
    });

    var article = server.create('article');
    var publishedArticle = server.create('article', 'published');
    var publishedArticleWithContent = server.create('article', 'published', 'withContent');

    assert.deepEqual(article, { id: '1', title: 'Lorem ipsum' });
    assert.deepEqual(publishedArticle, { id: '2', title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00' });
    assert.deepEqual(publishedArticleWithContent, { id: '3', title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00', content: 'content' });

    server.shutdown();
  });

  (0, _qunit.test)('create allows to extend factory with traits containing afterCreate callbacks', function (assert) {
    var CommentFactory = _emberCliMirage.Factory.extend({
      content: 'content'
    });
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      withComments: (0, _emberCliMirage.trait)({
        afterCreate: function afterCreate(article, server) {
          server.createList('comment', 3, { article: article });
        }
      })
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory,
        comment: CommentFactory
      }
    });

    var articleWithComments = server.create('article', 'withComments');

    assert.deepEqual(articleWithComments, { id: '1', title: 'Lorem ipsum' });
    assert.equal(server.db.comments.length, 3);

    server.shutdown();
  });

  (0, _qunit.test)('create does not execute afterCreate callbacks from traits that are not applied', function (assert) {
    var CommentFactory = _emberCliMirage.Factory.extend({
      content: 'content'
    });
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      withComments: (0, _emberCliMirage.trait)({
        afterCreate: function afterCreate(article, server) {
          server.createList('comment', 3, { article: article });
        }
      })
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory,
        comment: CommentFactory
      }
    });

    var articleWithComments = server.create('article');

    assert.deepEqual(articleWithComments, { id: '1', title: 'Lorem ipsum' });
    assert.equal(server.db.comments.length, 0);

    server.shutdown();
  });

  (0, _qunit.test)('create allows to extend with multiple traits and to apply attr overrides', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      withContent: (0, _emberCliMirage.trait)({
        content: 'content'
      })
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory
      }
    });

    var overrides = {
      publishedAt: '2012-01-01 10:00:00'
    };
    var publishedArticleWithContent = server.create('article', 'published', 'withContent', overrides);

    assert.deepEqual(publishedArticleWithContent, { id: '1', title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2012-01-01 10:00:00', content: 'content' });

    server.shutdown();
  });

  (0, _qunit.test)('create throws errors when using trait that is not defined and distinquishes between traits and non-traits', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      'private': {
        someAttr: 'value'
      }
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory
      }
    });

    assert.throws(function () {
      server.create('article', 'private');
    }, /'private' trait is not registered in 'article' factory/);

    server.shutdown();
  });

  (0, _qunit.test)('create allows to create objects with associations', function (assert) {
    var AuthorFactory = _emberCliMirage.Factory.extend({
      name: 'Sam'
    });
    var CategoryFactory = _emberCliMirage.Factory.extend({
      name: 'splendid software'
    });
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      withCategory: (0, _emberCliMirage.trait)({
        awesomeCategory: (0, _emberCliMirage.association)()
      }),

      author: (0, _emberCliMirage.association)()
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      models: {
        author: _emberCliMirage.Model.extend({
          articles: (0, _emberCliMirage.hasMany)()
        }),
        category: _emberCliMirage.Model.extend({}),
        article: _emberCliMirage.Model.extend({
          author: (0, _emberCliMirage.belongsTo)(),
          awesomeCategory: (0, _emberCliMirage.belongsTo)('category')
        })
      },
      factories: {
        article: ArticleFactory,
        author: AuthorFactory,
        category: CategoryFactory
      }
    });

    var article = server.create('article', 'withCategory');

    assert.deepEqual(article.attrs, { title: 'Lorem ipsum', id: '1', authorId: '1', awesomeCategoryId: '1' });
    assert.equal(server.db.authors.length, 1);
    assert.equal(server.db.categories.length, 1);

    var anotherArticle = server.create('article', 'withCategory');
    assert.deepEqual(anotherArticle.attrs, { title: 'Lorem ipsum', id: '2', authorId: '2', awesomeCategoryId: '2' });
    assert.equal(server.db.authors.length, 2);
    assert.equal(server.db.categories.length, 2);
  });

  (0, _qunit.test)('create allows to create objects with associations with traits and overrides for associations', function (assert) {
    var CategoryFactory = _emberCliMirage.Factory.extend({
      name: 'splendid software',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2014-01-01 10:00:00'
      })
    });
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      withCategory: (0, _emberCliMirage.trait)({
        category: (0, _emberCliMirage.association)('published', { publishedAt: '2016-01-01 12:00:00' })
      })
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory,
        category: CategoryFactory
      },
      models: {
        category: _emberCliMirage.Model.extend({}),
        article: _emberCliMirage.Model.extend({
          category: (0, _emberCliMirage.belongsTo)('category')
        })
      }
    });

    var article = server.create('article', 'withCategory');

    assert.deepEqual(article.attrs, { title: 'Lorem ipsum', id: '1', categoryId: '1' });
    assert.equal(server.db.categories.length, 1);
    assert.deepEqual(server.db.categories[0], { name: 'splendid software', id: '1', isPublished: true, publishedAt: '2016-01-01 12:00:00' });
  });

  (0, _qunit.module)('Unit | Server #createList', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({ environment: 'test' });
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('createList adds the given number of elements to the db', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: 'Sam' })
    });

    this.server.createList('contact', 3);
    var contactsInDb = this.server.db.contacts;

    assert.equal(contactsInDb.length, 3);
    assert.deepEqual(contactsInDb[0], { id: '1', name: 'Sam' });
    assert.deepEqual(contactsInDb[1], { id: '2', name: 'Sam' });
    assert.deepEqual(contactsInDb[2], { id: '3', name: 'Sam' });
  });

  (0, _qunit.test)('createList returns the created elements', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: 'Sam' })
    });

    this.server.create('contact');
    var contacts = this.server.createList('contact', 3);

    assert.equal(contacts.length, 3);
    assert.deepEqual(contacts[0], { id: '2', name: 'Sam' });
    assert.deepEqual(contacts[1], { id: '3', name: 'Sam' });
    assert.deepEqual(contacts[2], { id: '4', name: 'Sam' });
  });

  (0, _qunit.test)('createList respects sequences', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({
        name: function name(i) {
          return 'name' + i;
        }
      })
    });

    var contacts = this.server.createList('contact', 3);

    assert.deepEqual(contacts[0], { id: '1', name: 'name0' });
    assert.deepEqual(contacts[1], { id: '2', name: 'name1' });
    assert.deepEqual(contacts[2], { id: '3', name: 'name2' });
  });

  (0, _qunit.test)('createList respects attr overrides', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: 'Sam' })
    });

    var sams = this.server.createList('contact', 2);
    var links = this.server.createList('contact', 2, { name: 'Link' });

    assert.deepEqual(sams[0], { id: '1', name: 'Sam' });
    assert.deepEqual(sams[1], { id: '2', name: 'Sam' });
    assert.deepEqual(links[0], { id: '3', name: 'Link' });
    assert.deepEqual(links[1], { id: '4', name: 'Link' });
  });

  (0, _qunit.test)('createList respects traits', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      withContent: (0, _emberCliMirage.trait)({
        content: 'content'
      })
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    var articles = this.server.createList('article', 2, 'published', 'withContent');

    assert.deepEqual(articles[0], { id: '1', title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00', content: 'content' });
    assert.deepEqual(articles[1], { id: '2', title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00', content: 'content' });
  });

  (0, _qunit.test)('createList respects traits with attr overrides', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      withContent: (0, _emberCliMirage.trait)({
        content: 'content'
      })
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    var overrides = { publishedAt: '2012-01-01 10:00:00' };
    var articles = this.server.createList('article', 2, 'published', 'withContent', overrides);

    assert.deepEqual(articles[0], { id: '1', title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2012-01-01 10:00:00', content: 'content' });
    assert.deepEqual(articles[1], { id: '2', title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2012-01-01 10:00:00', content: 'content' });
  });

  (0, _qunit.test)('createList throws errors when using trait that is not defined and distinquishes between traits and non-traits', function (assert) {
    var _this = this;

    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      'private': {
        someAttr: 'value'
      }
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    assert.throws(function () {
      _this.server.createList('article', 2, 'private');
    }, /'private' trait is not registered in 'article' factory/);
  });

  (0, _qunit.test)('createList throws an error if the second argument is not an integer', function (assert) {
    var _this2 = this;

    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      })
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    assert.throws(function () {
      _this2.server.createList('article', 'published');
    }, /second argument has to be an integer, you passed: string/);
  });

  (0, _qunit.module)('Unit | Server #build', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({ environment: 'test' });
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('build does not add the data to the db', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: 'Sam' })
    });

    this.server.build('contact');
    var contactsInDb = this.server.db.contacts;

    assert.equal(contactsInDb.length, 0);
  });

  (0, _qunit.test)('build returns the new attrs with no id', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: 'Sam' })
    });

    var contact = this.server.build('contact');

    assert.deepEqual(contact, { name: 'Sam' });
  });

  (0, _qunit.test)('build allows for attr overrides', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: 'Sam' })
    });

    var sam = this.server.build('contact');
    var link = this.server.build('contact', { name: 'Link' });

    assert.deepEqual(sam, { name: 'Sam' });
    assert.deepEqual(link, { name: 'Link' });
  });

  (0, _qunit.test)('build allows for attr overrides with extended factories', function (assert) {
    var ContactFactory = _emberCliMirage.Factory.extend({
      name: 'Link',
      age: 500
    });
    var FriendFactory = ContactFactory.extend({
      is_young: function is_young() {
        return this.age < 18;
      }
    });
    this.server.loadFactories({
      contact: ContactFactory,
      friend: FriendFactory
    });

    var link = this.server.build('friend');
    var youngLink = this.server.build('friend', { age: 10 });

    assert.deepEqual(link, { name: 'Link', age: 500, is_young: false });
    assert.deepEqual(youngLink, { name: 'Link', age: 10, is_young: true });
  });

  (0, _qunit.test)('build allows for attr overrides with arrays', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: ['Sam', 'Carl'] })
    });

    var sam = this.server.build('contact');
    var link = this.server.build('contact', { name: ['Link'] });
    var noname = this.server.build('contact', { name: [] });

    assert.deepEqual(sam, { name: ['Sam', 'Carl'] });
    assert.deepEqual(link, { name: ['Link'] });
    assert.deepEqual(noname, { name: [] });
  });

  (0, _qunit.test)('build allows for nested attr overrides', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({
        address: {
          streetName: 'Main',
          streetAddress: function streetAddress(i) {
            return 1000 + i;
          }
        }
      })
    });

    var contact1 = this.server.build('contact');
    var contact2 = this.server.build('contact');

    assert.deepEqual(contact1, { address: { streetName: 'Main', streetAddress: 1000 } });
    assert.deepEqual(contact2, { address: { streetName: 'Main', streetAddress: 1001 } });
  });

  (0, _qunit.test)('build allows for arrays of attr overrides', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({
        websites: ['http://example.com', function (i) {
          return 'http://placekitten.com/' + (320 + i) + '/' + (240 + i);
        }]
      })
    });

    var contact1 = this.server.build('contact');
    var contact2 = this.server.build('contact');

    assert.deepEqual(contact1, { websites: ['http://example.com', 'http://placekitten.com/320/240'] });
    assert.deepEqual(contact2, { websites: ['http://example.com', 'http://placekitten.com/321/241'] });
  });

  (0, _qunit.test)('build allows to extend factory with trait', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      })
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    var article = this.server.build('article');
    var publishedArticle = this.server.build('article', 'published');

    assert.deepEqual(article, { title: 'Lorem ipsum' });
    assert.deepEqual(publishedArticle, { title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00' });
  });

  (0, _qunit.test)('build allows to extend factory with multiple traits', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      withContent: (0, _emberCliMirage.trait)({
        content: 'content'
      })
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    var article = this.server.build('article');
    var publishedArticle = this.server.build('article', 'published');
    var publishedArticleWithContent = this.server.build('article', 'published', 'withContent');

    assert.deepEqual(article, { title: 'Lorem ipsum' });
    assert.deepEqual(publishedArticle, { title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00' });
    assert.deepEqual(publishedArticleWithContent, { title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00', content: 'content' });
  });

  (0, _qunit.test)('build allows to extend with multiple traits and to apply attr overrides', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      withContent: (0, _emberCliMirage.trait)({
        content: 'content'
      })
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    var overrides = {
      publishedAt: '2012-01-01 10:00:00'
    };
    var publishedArticleWithContent = this.server.build('article', 'published', 'withContent', overrides);

    assert.deepEqual(publishedArticleWithContent, { title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2012-01-01 10:00:00', content: 'content' });
  });

  (0, _qunit.test)('build allows to build objects with associations', function (assert) {
    var AuthorFactory = _emberCliMirage.Factory.extend({
      name: 'Yehuda'
    });
    var CategoryFactory = _emberCliMirage.Factory.extend({
      name: 'splendid software'
    });
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      withCategory: (0, _emberCliMirage.trait)({
        awesomeCategory: (0, _emberCliMirage.association)()
      }),

      someOtherTrait: (0, _emberCliMirage.trait)({
        user: (0, _emberCliMirage.association)()
      }),

      author: (0, _emberCliMirage.association)()
    });

    this.server.loadFactories({
      article: ArticleFactory,
      author: AuthorFactory,
      category: CategoryFactory
    });
    this.server.schema.registerModels({
      author: _emberCliMirage.Model.extend({
        articles: (0, _emberCliMirage.hasMany)()
      }),
      category: _emberCliMirage.Model.extend({}),
      article: _emberCliMirage.Model.extend({
        author: (0, _emberCliMirage.belongsTo)(),
        awesomeCategory: (0, _emberCliMirage.belongsTo)('category')
      })
    });

    var article = this.server.build('article', 'withCategory');

    assert.deepEqual(article, { title: 'Lorem ipsum', authorId: '1', awesomeCategoryId: '1' });
    assert.equal(server.db.authors.length, 1);
    assert.equal(server.db.categories.length, 1);
  });

  (0, _qunit.test)('build allows to build objects with associations with traits and overrides for associations', function (assert) {
    var CategoryFactory = _emberCliMirage.Factory.extend({
      name: 'splendid software',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2014-01-01 10:00:00'
      })
    });
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      withCategory: (0, _emberCliMirage.trait)({
        category: (0, _emberCliMirage.association)('published', { publishedAt: '2016-01-01 12:00:00' })
      })
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory,
        category: CategoryFactory
      },
      models: {
        category: _emberCliMirage.Model.extend({}),
        article: _emberCliMirage.Model.extend({
          category: (0, _emberCliMirage.belongsTo)()
        })
      }
    });

    var article = server.build('article', 'withCategory');

    assert.deepEqual(article, { title: 'Lorem ipsum', categoryId: '1' });
    assert.equal(server.db.categories.length, 1);
    assert.deepEqual(server.db.categories[0], { name: 'splendid software', id: '1', isPublished: true, publishedAt: '2016-01-01 12:00:00' });
  });

  (0, _qunit.test)('build throws errors when using trait that is not defined and distinquishes between traits and non-traits', function (assert) {
    var _this3 = this;

    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      'private': {
        someAttr: 'value'
      }
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    assert.throws(function () {
      _this3.server.build('article', 'private');
    }, /'private' trait is not registered in 'article' factory/);
  });

  (0, _qunit.test)('build does not build objects and throws error if model is not registered and association helper is used', function (assert) {
    var CategoryFactory = _emberCliMirage.Factory.extend({
      name: 'splendid software',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2014-01-01 10:00:00'
      })
    });
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      withCategory: (0, _emberCliMirage.trait)({
        category: (0, _emberCliMirage.association)('published', { publishedAt: '2016-01-01 12:00:00' })
      })
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory,
        category: CategoryFactory
      },
      models: {
        category: _emberCliMirage.Model.extend({})
      }
    });

    assert.throws(function () {
      server.build('article', 'withCategory');
    }, /Model not registered: article/);
  });

  (0, _qunit.test)('build does not build objects and throws error if model for given association is not registered', function (assert) {
    var CategoryFactory = _emberCliMirage.Factory.extend({
      name: 'splendid software',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2014-01-01 10:00:00'
      })
    });
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      withCategory: (0, _emberCliMirage.trait)({
        category: (0, _emberCliMirage.association)('published', { publishedAt: '2016-01-01 12:00:00' })
      })
    });

    var server = new _emberCliMirageServer['default']({
      environment: 'test',
      factories: {
        article: ArticleFactory,
        category: CategoryFactory
      },
      models: {
        article: _emberCliMirage.Model.extend()
      }
    });

    assert.throws(function () {
      server.build('article', 'withCategory');
    }, /You're using the `association` factory helper on the 'category' attribute/);
  });

  (0, _qunit.module)('Unit | Server #buildList', {
    beforeEach: function beforeEach() {
      this.server = new _emberCliMirageServer['default']({ environment: 'test' });
    },
    afterEach: function afterEach() {
      this.server.shutdown();
    }
  });

  (0, _qunit.test)('buildList does not add elements to the db', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: 'Sam' })
    });

    this.server.buildList('contact', 3);
    var contactsInDb = this.server.db.contacts;

    assert.equal(contactsInDb.length, 0);
  });

  (0, _qunit.test)('buildList returns the built elements without ids', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: 'Sam' })
    });

    this.server.create('contact');
    var contacts = this.server.buildList('contact', 3);

    assert.equal(contacts.length, 3);
    assert.deepEqual(contacts[0], { name: 'Sam' });
    assert.deepEqual(contacts[1], { name: 'Sam' });
    assert.deepEqual(contacts[2], { name: 'Sam' });
  });

  (0, _qunit.test)('buildList respects sequences', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({
        name: function name(i) {
          return 'name' + i;
        }
      })
    });

    var contacts = this.server.buildList('contact', 3);

    assert.deepEqual(contacts[0], { name: 'name0' });
    assert.deepEqual(contacts[1], { name: 'name1' });
    assert.deepEqual(contacts[2], { name: 'name2' });
  });

  (0, _qunit.test)('buildList respects attr overrides', function (assert) {
    this.server.loadFactories({
      contact: _emberCliMirage.Factory.extend({ name: 'Sam' })
    });

    var sams = this.server.buildList('contact', 2);
    var links = this.server.buildList('contact', 2, { name: 'Link' });

    assert.deepEqual(sams[0], { name: 'Sam' });
    assert.deepEqual(sams[1], { name: 'Sam' });
    assert.deepEqual(links[0], { name: 'Link' });
    assert.deepEqual(links[1], { name: 'Link' });
  });

  (0, _qunit.test)('buildList respects traits', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      withContent: (0, _emberCliMirage.trait)({
        content: 'content'
      })
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    var articles = this.server.buildList('article', 2, 'published', 'withContent');

    assert.deepEqual(articles[0], { title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00', content: 'content' });
    assert.deepEqual(articles[1], { title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2010-01-01 10:00:00', content: 'content' });
  });

  (0, _qunit.test)('buildList respects traits with attr overrides', function (assert) {
    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      withContent: (0, _emberCliMirage.trait)({
        content: 'content'
      })
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    var overrides = { publishedAt: '2012-01-01 10:00:00' };
    var articles = this.server.buildList('article', 2, 'published', 'withContent', overrides);

    assert.deepEqual(articles[0], { title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2012-01-01 10:00:00', content: 'content' });
    assert.deepEqual(articles[1], { title: 'Lorem ipsum', isPublished: true,
      publishedAt: '2012-01-01 10:00:00', content: 'content' });
  });

  (0, _qunit.test)('buildList throws errors when using trait that is not defined and distinquishes between traits and non-traits', function (assert) {
    var _this4 = this;

    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      }),

      'private': {
        someAttr: 'value'
      }
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    assert.throws(function () {
      _this4.server.buildList('article', 2, 'private');
    }, /'private' trait is not registered in 'article' factory/);
  });

  (0, _qunit.test)('buildList throws an error if the second argument is not an integer', function (assert) {
    var _this5 = this;

    var ArticleFactory = _emberCliMirage.Factory.extend({
      title: 'Lorem ipsum',

      published: (0, _emberCliMirage.trait)({
        isPublished: true,
        publishedAt: '2010-01-01 10:00:00'
      })
    });

    this.server.loadFactories({
      article: ArticleFactory
    });

    assert.throws(function () {
      _this5.server.buildList('article', 'published');
    }, /second argument has to be an integer, you passed: string/);
  });

  (0, _qunit.module)('Unit | Server #defaultPassthroughs');

  (0, _qunit.test)('server configures default passthroughs when useDefaultPassthroughs is true', function (assert) {
    var server = new _emberCliMirageServer['default']({ useDefaultPassthroughs: true });

    assert.expect(_emberCliMirageServer.defaultPassthroughs.length);
    _emberCliMirageServer.defaultPassthroughs.forEach(function (passthroughUrl) {
      var passthroughRequest = { method: 'GET', url: passthroughUrl };
      var isPassedThrough = server.pretender.checkPassthrough(passthroughRequest);

      assert.ok(isPassedThrough);
    });

    server.shutdown();
  });

  (0, _qunit.test)('server does not configure default passthroughs when useDefaultPassthroughs is false', function (assert) {
    var server = new _emberCliMirageServer['default']({ useDefaultPassthroughs: false });

    assert.expect(_emberCliMirageServer.defaultPassthroughs.length);
    _emberCliMirageServer.defaultPassthroughs.forEach(function (passthroughUrl) {
      var passthroughRequest = { method: 'GET', url: passthroughUrl };
      var isPassedThrough = server.pretender.checkPassthrough(passthroughRequest);

      assert.ok(!isPassedThrough);
    });

    server.shutdown();
  });
});
define('dummy/tests/unit/server-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/server-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/server-test.js should pass ESLint.\n');
  });
});
define('dummy/tests/unit/utils/normalize-name-test', ['exports', 'ember-cli-mirage/utils/normalize-name', 'ember-inflector', 'qunit'], function (exports, _emberCliMirageUtilsNormalizeName, _emberInflector, _qunit) {

  (0, _qunit.module)('Unit | Normalize name');

  (0, _qunit.test)('can convert Model name to DbCollection name', function (assert) {
    assert.equal((0, _emberCliMirageUtilsNormalizeName.toCollectionName)('test'), 'tests');
    assert.equal((0, _emberCliMirageUtilsNormalizeName.toCollectionName)('hard-test'), 'hardTests');
  });

  (0, _qunit.test)('can convert DbCollection name to Model name', function (assert) {
    assert.equal((0, _emberCliMirageUtilsNormalizeName.toModelName)('tests'), 'test');
    assert.equal((0, _emberCliMirageUtilsNormalizeName.toModelName)('hardTests'), 'hard-test');
  });

  (0, _qunit.test)('can convert Model name to DbCollection using custom inflector rules', function (assert) {
    _emberInflector['default'].inflector.irregular('head-of-state', 'heads-of-state');
    assert.equal((0, _emberCliMirageUtilsNormalizeName.toCollectionName)('head-of-state'), 'headsOfState');
  });

  (0, _qunit.test)('can convert DbCollection name to Model name using custom inflector rules', function (assert) {
    _emberInflector['default'].inflector.irregular('head-of-state', 'heads-of-state');
    assert.equal((0, _emberCliMirageUtilsNormalizeName.toModelName)('headsOfState'), 'head-of-state');
  });
});
define('dummy/tests/unit/utils/normalize-name-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint - unit/utils/normalize-name-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'unit/utils/normalize-name-test.js should pass ESLint.\n');
  });
});
/* jshint ignore:start */

require('dummy/tests/test-helper');
EmberENV.TESTS_FILE_LOADED = true;

/* jshint ignore:end */
//# sourceMappingURL=tests.map
